---
id: arrays-l2-searching-and-testing
title: "Searching & Testing (find, some, every, includes)"
topic: arrays
level: 2
lesson: 2.4
prereqs:
  - arrays-l1-overview
  - arrays-l1-adding-removing-basics
  - arrays-l1-iteration-101
  - arrays-l1-copying-and-slicing-basics
outcomes:
  - Choose the right tool among `find`, `findIndex`, `findLast`, `findLastIndex`, `some`, `every`, and `includes`
  - Explain equality semantics (`SameValueZero` vs strict) and how holes are treated
  - Use `fromIndex`/negative indices correctly
  - Compose predicates cleanly and avoid early-exit anti-patterns
  - Implement utilities `none`, `partition`, `findLastIndex` polyfill, `containsAll`
tags: ["arrays","search","predicates","includes","find","some","every"]
est_minutes: 35
checks:
  - type: quiz
    id: arrays-l2-searching-quiz
  - type: unit
    entry: none.ts
    tests: none.test.ts
  - type: unit
    entry: partition.ts
    tests: partition.test.ts
  - type: unit
    entry: findLastIndexPolyfill.ts
    tests: findLastIndexPolyfill.test.ts
  - type: unit
    entry: containsAll.ts
    tests: containsAll.test.ts
---

## Why this matters

Most problems boil down to **“does anything match?”**, **“do all match?”**, or **“find the first/last that matches.”** Picking the right method gives you **clarity** and **early exit** for free.

---

## Mental model & complexity

All these scan at most **O(n)** and **short-circuit** as soon as the answer is known:

- `find(pred)` → first **value** matching, or `undefined`
- `findIndex(pred)` → first **index** matching, or `-1`
- `findLast(pred)` → last **value** matching, or `undefined`
- `findLastIndex(pred)` → last **index** matching, or `-1`
- `some(pred)` → `true` if **any** match
- `every(pred)` → `true` if **all** match
- `includes(value, fromIndex=0)` → `true` if array **contains** the value by **SameValueZero** equality

> **Holes:** predicate-based methods (`find*`, `some`, `every`) **skip holes** (they do not call your callback for missing indices). `includes` also ignores holes—matching `undefined` requires an **actual** `undefined` element, not a hole.

---

## API quick guide

### `find` / `findIndex`
```ts
const users = [{id:1, admin:false}, {id:2, admin:true}];
users.find(u => u.admin);      // {id:2, admin:true}
users.findIndex(u => u.admin); // 1
````

> **Pitfall:** `find` returns the **value**, not the index.

### `findLast` / `findLastIndex` (modern)

Like `find`/`findIndex`, but search from the **end**.

```ts
[1,2,3,2].findLast(x => x === 2);      // 2
[1,2,3,2].findLastIndex(x => x === 2); // 3
```

If targeting older runtimes, provide a polyfill (exercise below).

### `some` / `every`

```ts
[1,2,3].some(x => x > 2);  // true
[1,2,3].every(x => x > 0); // true
```

* `some` short-circuits on first `true`.
* `every` short-circuits on first `false`.

### `includes(value, fromIndex = 0)`

* Uses **SameValueZero**: `NaN` equals `NaN`, `+0` equals `-0`.

```ts
[NaN].includes(NaN); // true
[0].includes(-0);    // true
```

* **Holes** don’t count as `undefined`. `[ , ].includes(undefined)` → `false`.

### `indexOf` / `lastIndexOf` (strict equality)

* Use `===` semantics: `NaN` is **not equal** to `NaN`.

```ts
[NaN].indexOf(NaN); // -1
```

* Already built a `lastIndexOf` polyfill earlier? Great. We’ll focus on `findLastIndex` here.

---

## `fromIndex` & negative indices

Many methods accept a `fromIndex`. When negative, it’s interpreted as `length + fromIndex` (clamped at 0).

```ts
const a = [1,2,3,2];
a.includes(2, -2);       // true (searches from index 2)
a.indexOf(2, -2);        // 3
a.lastIndexOf(2, -2);    // 1 (searching backward from length-2)
```

---

## Common pitfalls

* Using `find` when you need an **index**; prefer `findIndex` (or `findLastIndex`).
* Using `indexOf` for `NaN` — it never matches. Prefer `includes` or a predicate.
* Forgetting that holes are skipped; a “missing” element won’t trigger your predicate.
* Emulating `any`/`all` via manual loops instead of `some`/`every`.

---

## Walkthrough: guard & fetch

**Task:** If any user is admin, get the **last** admin’s id; else return `null`.

```ts
type User = { id: number; admin: boolean };

const lastAdminIdOrNull = (users: User[]): number | null => {
  if (!users.some(u => u.admin)) return null;      // cheap guard
  const last = users.findLast(u => u.admin);       // value
  return last ? last.id : null;
};
```

---

## Exercises

### 1) `none<T>(arr, pred)` — the opposite of `some`

Return `true` if **no** elements satisfy `pred`.

**Starter — `none.ts`**

```ts
export function none<T>(arr: T[], pred: (x: T, i: number, a: T[]) => boolean): boolean {
  // Implement using some/every (prefer clarity)
  return true;
}
```

---

### 2) `partition<T>(arr, pred)` — split into matches & rest

Return a tuple `[yes, no]`, preserving order.

**Starter — `partition.ts`**

```ts
export function partition<T>(
  arr: T[],
  pred: (x: T, i: number, a: T[]) => boolean
): [T[], T[]] {
  // Build in one pass
  return [[], []];
}
```

---

### 3) `findLastIndexPolyfill<T>(arr, pred)` — no runtime mutation

Create a **pure** helper that mimics `Array.prototype.findLastIndex`.

**Starter — `findLastIndexPolyfill.ts`**

```ts
export function findLastIndexPolyfill<T>(
  arr: T[],
  pred: (x: T, i: number, a: T[]) => boolean
): number {
  // Iterate from end to start; skip holes (use i in arr)
  return -1;
}
```

**Requirements**

* Do not modify `Array.prototype`.
* Skip holes: test with `if (!(i in arr)) continue`.

---

### 4) `containsAll(haystack, needles)` — with SameValueZero semantics

Return `true` if every element of `needles` is present in `haystack` by `includes` (so `NaN` works).

**Starter — `containsAll.ts`**

```ts
export function containsAll<T>(haystack: T[], needles: T[]): boolean {
  // Use Array.prototype.includes for each needle
  return false;
}
```

**Note:** This is O(n·m). Later we’ll speed this up with `Set`.

---

## Quiz (checks)

1. Which method uses **SameValueZero** equality?
   A) `indexOf`
   B) `lastIndexOf`
   C) `includes` ✅
   D) `findIndex`

2. What does `find` return when nothing matches?
   A) `-1`
   B) `null`
   C) `undefined` ✅
   D) `false`

3. Which statement is true?
   A) `some` examines all elements even after finding a match.
   B) `every` stops at the first element that fails the predicate. ✅
   C) `findIndex` returns the value, not the index.
   D) `includes` treats holes as `undefined`.

4. For older runtimes lacking `findLastIndex`, the safest approach is:
   A) Patch `Array.prototype` globally.
   B) Write a standalone **pure helper** that scans from the end. ✅
   C) Use `indexOf` with a reversed copy.
   D) Use `reduceRight` (always faster).

5. Which call is **true**?
   A) `[ , ].includes(undefined)`
   B) `[undefined].includes(undefined)` ✅
   C) `[NaN].indexOf(NaN) !== -1`
   D) `[1,2,3].every(x => x < 3)` is `true`

---

## Takeaways

* Use `find*` for the **item**/**index** (first or last), `some`/`every` for **any/all**, `includes` for **membership**.
* `includes` matches `NaN`; `indexOf` does not.
* Predicates skip holes; `includes(undefined)` requires a real `undefined` slot.
* Prefer built-ins for **short-circuiting** and clarity over manual loops.

---

## What’s next

Head to **Arrays L2 — Utilities & Misc** to round out the API: `join`, `fill`, `copyWithin`, `at`, iterators, and modern change-by-copy helpers like `toReversed` and `with`.
