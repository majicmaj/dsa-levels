---
id: arrays-l2-utilities-and-misc
title: "Utilities & Misc (join, fill, copyWithin, at, iterators, toReversed, with)"
topic: arrays
level: 2
lesson: 2.5
prereqs:
  - arrays-l1-overview
  - arrays-l1-iteration-101
  - arrays-l1-copying-and-slicing-basics
  - arrays-l2-slice-vs-splice-vs-toSpliced
outcomes:
  - Use `join`, `fill`, `copyWithin`, `at`, and the iterators (`keys/values/entries`) confidently
  - Explain which of these APIs mutate vs return copies and their typical complexities
  - Apply modern “change-by-copy” methods `toReversed`, `with` (and when to prefer them)
  - Avoid pitfalls such as `fill` with objects and overlapping ranges in `copyWithin`
  - Implement small utilities `range`, `repeatSequence`, `rotateRightInPlace`, `atPolyfill`
tags: ["arrays","utilities","join","fill","copyWithin","at","iterators","toReversed","with","immutability"]
est_minutes: 35
checks:
  - type: quiz
    id: arrays-l2-utilities-quiz
  - type: unit
    entry: range.ts
    tests: range.test.ts
  - type: unit
    entry: repeatSequence.ts
    tests: repeatSequence.test.ts
  - type: unit
    entry: rotateRightCopyWithin.ts
    tests: rotateRightCopyWithin.test.ts
  - type: unit
    entry: atPolyfill.ts
    tests: atPolyfill.test.ts
---

## Why this matters

These “misc” methods are the glue you’ll use everywhere: formatting arrays into strings, fast mass-initialization, in-place block moves, ergonomic negative indexing, and safe immutable edits with the new **change-by-copy** APIs.

---

## Mental model & mutation table

| API | Mutates? | What it does | Typical use | Complexity (rough) |
|---|---|---|---|---|
| `join(sep=',')` | **No** | Stringify elements and join with `sep` | CSV-like output, logs | O(n·toString) |
| `fill(value, start=0, end=len)` | **Yes** | Write `value` into `[start,end)` | Init/reset segments | O(k) |
| `copyWithin(target, start, end=len)` | **Yes** | Copy slice `[start,end)` onto index `target` (in-place) | Shifts/rotations, block moves | O(k) |
| `at(index)` | **No** | Element by index; supports negatives | Readable `arr.at(-1)` | O(1) |
| `keys/values/entries()` | **No** | Iterators for indices/values/pairs (skip holes) | Clean iteration | O(n) to consume |
| `toReversed()` | **No** | Return reversed copy | Immutable reverse | O(n) |
| `with(index, value)` | **No** | Copy, but replace one element | Immutable single-edit | O(n) |

> Reminder: many array iterators and callbacks **skip holes**. See L1 Iteration.

---

## `join` — turn arrays into strings

- Default separator is **comma**.
- Non-strings are converted via `String(x)`; `null`/`undefined` become empty string.

```ts
[1, 2, 3].join();        // "1,2,3"
["a", "b"].join("-");    // "a-b"
[null, undefined, 0].join("|"); // "| |0"
````

---

## `fill` — fast mass assignment (mutates)

```ts
const a = new Array(5).fill(0);        // [0,0,0,0,0]
a.fill(9, 1, 3);                       // [0,9,9,0,0]
```

**Pitfall:** When `value` is an **object/array**, every slot points to the **same reference**.

```ts
const rows = new Array(3).fill([]); // [[], [], []] — but all the same array!
rows[0].push(1);
console.log(rows[1]); // [1]  (oops)
```

**Fix:** create per-slot values (e.g., `Array.from({length:n}, () => [])`).

---

## `copyWithin` — in-place block moves

Signature: `arr.copyWithin(target, start, end = arr.length)`

* Copies the slice `[start,end)` onto **starting at** `target`.
* Handles **overlaps** correctly (like `memmove`), but be careful with expectations.
* **Mutates** the array; length unchanged.

```ts
const a = [0,1,2,3,4,5];
a.copyWithin(1, 3);  // copy [3,4,5] to index 1 → [0,3,4,5,4,5]
a.copyWithin(0, 1, 3); // copy [3,4] to index 0 → [3,4,4,5,4,5]
```

Use cases: quick shifts/rotations, duplicating ranges, sliding windows in-place.

---

## `at` — ergonomic negative indexing

```ts
const xs = [10,20,30];
xs.at(-1); // 30
xs.at(0);  // 10
```

Prefer this over `xs[xs.length - 1]` for readability.

---

## Iterators: `keys()`, `values()`, `entries()`

```ts
const arr = ["a","b","c"];
for (const i of arr.keys()) console.log(i);       // 0,1,2
for (const v of arr.values()) console.log(v);     // "a","b","c"
for (const [i,v] of arr.entries()) console.log(i,v);
```

They **skip holes** (like other iterators).

---

## Change-by-copy: `toReversed`, `with`

Immutable twins that return **new arrays** without mutating the original.

```ts
const a = [1,2,3];
const b = a.toReversed();   // [3,2,1], a unchanged

const c = a.with(1, 99);    // [1,99,3], a unchanged
```

Use these in React reducers or anywhere immutability reads clearer.

---

## Common pitfalls

* `fill` with objects/arrays → shared references.
* `copyWithin` **overwrites** data at the target; don’t expect insertion.
* Negative indices with `at` are clearer, but remember `at(-1)` reads, it doesn’t remove.
* `toReversed`/`with` return **copies**; if you intended to mutate, use `reverse`/direct assignment.

---

## Walkthrough: rotate right in place (k steps)

One way (not the only way) is using `copyWithin` twice plus a temp buffer:

```ts
function rotateRightInPlace<T>(arr: T[], k: number): void {
  const n = arr.length;
  if (n === 0) return;
  k = ((k % n) + n) % n;
  if (k === 0) return;

  // Save the tail
  const tail = arr.slice(n - k);               // copy (size k)

  // Shift left the head [0, n-k) into [k, n)
  arr.copyWithin(k, 0, n - k);

  // Write saved tail into the first k positions
  for (let i = 0; i < k; i++) arr[i] = tail[i];
}
```

We’ll practice this in an exercise.

---

## Exercises

### 1) `range(n, start = 0)` — create a simple range

Return `[start, start+1, ..., start+n-1]`. `n <= 0` → `[]`.

**Starter — `range.ts`**

```ts
export function range(n: number, start: number = 0): number[] {
  // Prefer Array.from with a mapper
  return [];
}
```

---

### 2) `repeatSequence(seq, times)` — repeat without aliasing

Return a new array that is `seq` repeated `times` times. Must **not** share inner references if `seq` contains objects.

**Starter — `repeatSequence.ts`**

```ts
export function repeatSequence<T>(seq: T[], times: number): T[] {
  // Avoid new Array(times).fill(seq) because it repeats the same reference
  // Consider Array.from(..., () => seq) and then flatten a copy of seq each time
  return [];
}
```

**Examples**

```ts
repeatSequence([1,2], 3); // [1,2,1,2,1,2]
```

---

### 3) `rotateRightCopyWithin(arr, k)` — in-place rotation using `copyWithin`

Mutate `arr` to rotate right by `k` (see walkthrough for one valid strategy).

**Starter — `rotateRightCopyWithin.ts`**

```ts
export function rotateRightCopyWithin<T>(arr: T[], k: number): T[] {
  // Implement in-place; return arr for chaining
  return arr;
}
```

**Requirements**

* Work for negative and large `k` (normalize with modulo).
* O(n) time, O(k) extra space (buffer allowed), or O(1) extra if you choose another correct approach.

---

### 4) `atPolyfill(arr, index)` — emulate negative indexing

Return `arr.at(index)` without using `at`. Support negative indices.

**Starter — `atPolyfill.ts`**

```ts
export function atPolyfill<T>(arr: T[], index: number): T | undefined {
  // Translate negative index to length + index and bounds-check
  return undefined;
}
```

---

## Quiz (checks)

1. Which methods **mutate** the array? *(choose all)*

* `fill` ✅
* `copyWithin` ✅
* `join`
* `toReversed`
* `with`

2. What does `copyWithin(0, 2, 4)` do?
   A) Inserts elements at the front.
   B) Copies `[arr[2], arr[3]]` to positions `0` and `1`. ✅
   C) Deletes indices 2–3.
   D) Returns a new array.

3. `new Array(3).fill([])` results in:
   A) Three **independent** arrays.
   B) Three references to the **same** array. ✅
   C) A TypeError.
   D) `[[undefined],[undefined],[undefined]]`.

4. `['a','b','c'].at(-1)` returns:
   A) `undefined`
   B) `'a'`
   C) `'c'` ✅
   D) Throws

5. Choose the **immutable** single-element replacement:
   A) `arr[2] = x; arr`
   B) `arr.with(2, x)` ✅
   C) `arr.splice(2, 1, x); arr`
   D) `arr.copyWithin(2, 3, 4)`

---

## Takeaways

* Learn the mutation profile: `fill`/`copyWithin` **mutate**; `join`/`at`/iterators **don’t**; `toReversed`/`with` are **immutable** helpers.
* Avoid `fill` with object references unless you truly want shared aliases.
* `copyWithin` does block copy/overwrite, not insert—great for shifts/rotations.
* Prefer `at(-1)` for readable last-element access.

---

## What’s next

Move on to **Arrays L3 — Dynamic Array Internals** to see how arrays grow, why appends are amortized O(1), and to implement a tiny `DynamicArray<T>` yourself.