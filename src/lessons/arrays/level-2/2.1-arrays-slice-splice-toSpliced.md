---
id: arrays-l2-slice-vs-splice-vs-toSpliced
title: "Slice vs Splice vs toSpliced"
topic: arrays
level: 2
lesson: 2.1
prereqs:
  - arrays-l1-overview
  - arrays-l1-adding-removing-basics
  - arrays-l1-copying-and-slicing-basics
outcomes:
  - Distinguish when to use `slice`, `splice`, and `toSpliced` and explain mutation vs. non-mutation
  - Handle indices correctly (positive/negative/out-of-range) and `deleteCount` semantics
  - Perform immutable edits with `toSpliced` and write a safe fallback for older runtimes
  - "Implement common tasks: extract ranges, remove/insert/replace segments"
  - Avoid off-by-one errors and reason about time/space complexity
tags: ["arrays","slice","splice","toSpliced","immutability","basics","complexity"]
est_minutes: 35
checks:
  - type: quiz
    id: arrays-l2-slice-splice-quiz
  - type: unit
    entry: removeWhereSplice.ts
    tests: removeWhereSplice.test.ts
  - type: unit
    entry: insertAtToSpliced.ts
    tests: insertAtToSpliced.test.ts
  - type: unit
    entry: toSplicedPolyfill.ts
    tests: toSplicedPolyfill.test.ts
---

## Why this matters

These three are the **surgery tools** for arrays. Use the right one and your code is clear and safe; use the wrong one and you’ll mutate state by accident, drop elements, or fight off-by-one bugs.

---

## Quick comparison

| Method        | Mutates original? | Signature                                   | Returns                            | Typical uses                                  |
|---|---|---|---|---|
| `slice(s, e?)` | **No**            | `(start, endExclusive?)`                    | **Extracted copy**                 | Copy subarray; immutable “view”               |
| `splice(s, del?, ...items)` | **Yes** | `(start, deleteCount?, ...items)`          | **Removed items**                  | Remove/insert/replace **in place**            |
| `toSpliced(s, del?, ...items)` | **No** | `(start, deleteCount?, ...items)`          | **New array with edits**           | Immutable remove/insert/replace (copy-by-change) |

**Complexity (rough):**
- `slice` → O(k) for k extracted; `toSpliced`/`splice` → O(n) due to shifts/copies.

---

## Index rules you must remember

- **Negative `start`** counts from the end: `-1` is last element.
- **Out-of-range `start`** is clamped to `[0, length]`.
- `slice(start, endExclusive)` stops **before** `endExclusive`.
- `splice/toSpliced(start, deleteCount, ...items)`:
  - Missing `deleteCount` → delete to end.
  - `deleteCount` < 0 → treated as 0.
  - Returns differ: `splice` returns removed items; `toSpliced` returns the **new array**.

---

## Examples at a glance

```ts
const a = [10, 20, 30, 40, 50];

// slice — copy only:
a.slice(1, 3);      // [20, 30]
a.slice(-2);        // [40, 50]
a;                  // unchanged

// splice — mutate + return removed:
const removed = a.splice(1, 2, 99); // a becomes [10, 99, 40, 50]; removed = [20, 30]

// toSpliced — do the same immutably:
const b = [10, 20, 30, 40, 50];
const out = b.toSpliced(1, 2, 99);  // out = [10, 99, 40, 50]; b unchanged
````

---

## When to use which

* **Need a subarray** and keep original intact → **`slice`**.
* **Need to surgically edit the original** (performance or API requires mutation) → **`splice`**.
* **Immutable edit** (React state, pure functions) → **`toSpliced`** (or a fallback built from `slice` + spreads).

---

## Common pitfalls

* Using `splice` when you meant `slice` (accidental mutation).
* Forgetting `slice`’s **end is exclusive**.
* Passing a single arg to `splice(start)` and accidentally deleting **to the end**.
* Negative `start` off-by-one (e.g., `-1` targets the last element, not “after the last”).

---

## Walkthrough: replace a window immutably

Goal: replace 2 elements starting at index 3 with `['X','Y']` **without** changing the input.

```ts
const data = [0,1,2,3,4,5,6];
// ✅ toSpliced (cleanest):
const out1 = data.toSpliced(3, 2, 'X', 'Y'); // [0,1,2,'X','Y',6]

// Fallback: slice + spreads
const start = 3, del = 2;
const out2 = [...data.slice(0, start), 'X', 'Y', ...data.slice(start + del)];
```

---

## Exercises

### 1) Remove by predicate (mutating with `splice`)

Implement `removeWhereSplice(arr, predicate)` that **mutates** `arr` by removing all elements for which `predicate(v, i)` is true. Return the array for chaining.

**Starter — `removeWhereSplice.ts`**

```ts
export function removeWhereSplice<T>(
  arr: T[],
  predicate: (value: T, index: number, array: T[]) => boolean
): T[] {
  // Tip: iterate backwards to avoid index drift when splicing
  return arr;
}
```

**Requirements**

* Must iterate from end to start to avoid skipping.
* Complexity: O(n) checks + up to O(n) shifts.

---

### 2) Insert at index (immutable with `toSpliced`)

Implement `insertAtToSpliced(arr, index, ...items)` that returns a **new array** inserting `items` at `index` without deleting anything. Support negative `index`.

**Starter — `insertAtToSpliced.ts`**

```ts
export function insertAtToSpliced<T>(arr: T[], index: number, ...items: T[]): T[] {
  // Normalize index into [0, arr.length]
  // Use toSpliced if available; otherwise fallback (handled in Ex. 3)
  return arr;
}
```

**Requirements**

* Clamp index: `<0` → `length + index` (min 0), `>length` → `length`.
* Should not mutate `arr`.

---

### 3) `toSpliced` polyfill (pure function)

Write `toSplicedPolyfill(arr, start, deleteCount = arr.length - start, ...items)` that returns a **new array** with the splicing applied, **without** changing `arr`.

**Starter — `toSplicedPolyfill.ts`**

```ts
export function toSplicedPolyfill<T>(
  arr: T[],
  start: number,
  deleteCount?: number,
  ...items: T[]
): T[] {
  // Steps:
  // 1) Normalize start (handle negatives, clamp)
  // 2) Normalize deleteCount (default to arr.length - start, clamp >=0)
  // 3) Build: prefix + items + suffix (using slice)
  return arr;
}
```

**Edge cases**

* `start` negative and past the beginning → clamp to 0.
* `start` greater than length → clamp to `length`.
* `deleteCount` > available → clamp to available.
* Returning a **new** array every time.

---

## Quiz (checks)

1. Which statement is true?
   A) `slice` mutates the array.
   B) `splice` mutates and returns removed items. ✅
   C) `toSpliced` mutates and returns removed items.
   D) `splice` returns the new array.

2. What does `splice(2)` do?
   A) Deletes nothing.
   B) Deletes from index 2 to the end. ✅
   C) Deletes from 0 to 2.
   D) Throws unless `deleteCount` is given.

3. Choose the **immutable** way to remove 1 element at index `i`:
   A) `arr.splice(i, 1); arr`
   B) `arr.toSpliced(i, 1)` ✅
   C) `arr.slice(i, 1)`
   D) `arr = arr.splice(i, 1)`

4. With `slice(start, end)`, the element at `end` is:
   A) Included
   B) Excluded ✅
   C) Deleted
   D) Duplicated

---

## Takeaways

* **`slice` extracts**, **`splice` mutates**, **`toSpliced` immutably edits**.
* Normalize indices; mind `deleteCount` defaults and exclusive `end`.
* Prefer `toSpliced` (or the fallback) when you need **immutable** edits.
* Iterate **backwards** when removing multiple items with `splice`.

---

## What’s next

Head to **Arrays L2 — map, filter, reduce, flat, flatMap** to master single-pass transformations and composition patterns you’ll use everywhere.