---
id: arrays-l2-sort-and-compare
title: "Sort & Compare (numbers, strings, objects)"
topic: arrays
level: 2
lesson: 2.3
prereqs:
  - arrays-l1-overview
  - arrays-l1-copying-and-slicing-basics
  - arrays-l2-slice-vs-splice-vs-toSpliced
outcomes:
  - Explain default `sort` behavior and why numbers need a comparator
  - Write correct comparators for numbers, strings, dates, and objects (single & multi-key)
  - Choose between `sort` (mutates) and `toSorted` (immutable)
  - Understand stability and apply tie-breakers safely
  - Implement reusable helpers `numericSort`, `sortBy`, and `compareBy`
tags: ["arrays","sort","comparator","toSorted","immutability","stability"]
est_minutes: 40
checks:
  - type: quiz
    id: arrays-l2-sort-quiz
  - type: unit
    entry: numericSort.ts
    tests: numericSort.test.ts
  - type: unit
    entry: sortBy.ts
    tests: sortBy.test.ts
  - type: unit
    entry: compareBy.ts
    tests: compareBy.test.ts
crosslinks:
  - { to: strings-l1-basic-search-compare, why: "Locale-aware compare and case-insensitive sorting basics" }
  - { to: strings-l3-split-join-composition, why: "Character sorting pipelines and Unicode caveats" }
  - { to: strings-l2-utf16-code-units-vs-code-points, why: "Default sort compares by code units; know Unicode implications" }
---

## Why this matters

Sorting is everywhere: leaderboards, UI tables, logs, search results. Knowing **how JS sorts**, when it **mutates**, and how to write **stable, composable comparators** keeps your code correct and predictable.

---

## Mental model

- `Array.prototype.sort(compareFn?)` sorts **in place** and **returns the same array**.
- Without `compareFn`, elements are compared as **strings** (Unicode code unit order).  
  → Numbers go wrong: `[2, 11, 3].sort()` → `["11","2","3"]` → `[11, 2, 3]`
- With `compareFn(a, b)`, return:
  - `< 0` → `a` comes **before** `b`
  - `0`  → leave order (important for **stability**)
  - `> 0` → `a` comes **after** `b`
- `toSorted(compareFn?)` returns a **new array** (does not mutate).

**Complexity:** typically **O(n log n)** comparisons; comparators should be **pure** and **fast**.

---

## Numbers: always pass a comparator

```ts
[2, 11, 3].sort((a, b) => a - b);      // [2, 3, 11]
[2, 11, 3].toSorted((a, b) => b - a);  // [11, 3, 2]  (immutable)
````

> **Pitfall:** Returning booleans like `a > b` is wrong. It must be a negative/zero/positive **number**.

---

## Strings: locale vs binary comparisons

* **Simple ASCII / case-sensitive:** default string compare often suffices after mapping to strings.
* **Human-friendly / case-insensitive / numeric segments:** use `localeCompare`.

```ts
["Z", "a", "b"].toSorted();                          // ["Z","a","b"] (code unit order)
["Z", "a", "b"].toSorted((a,b)=>a.localeCompare(b)); // ["Z","a","b"]

// Case-insensitive (and handle accents properly for many locales):
["Z", "a", "b"].toSorted((a,b)=>a.localeCompare(b, undefined, { sensitivity: "base" }));
// "file2" < "file10":
["file2", "file10"].toSorted((a,b)=>a.localeCompare(b, undefined, { numeric: true }));
```

> `localeCompare` is powerful but heavier—use it when you need human ordering.

---

## Dates & derived keys

Always compare **primitive keys** (numbers/strings), not objects:

```ts
const posts = [{d:new Date("2024-02-01")},{d:new Date("2023-12-01")}];
posts.toSorted((a, b) => a.d.getTime() - b.d.getTime());
```

---

## Objects: single & multi-key

### Single key (numeric or string)

```ts
type User = { name: string; score: number };
users.toSorted((a, b) => a.score - b.score);
users.toSorted((a, b) => a.name.localeCompare(b.name));
```

### Multi-key tie-breakers

Use **OR-chaining** with numeric comparators or compose `localeCompare` results:

```ts
// score DESC, then name ASC (case-insensitive)
users.toSorted((a, b) =>
  (b.score - a.score) ||
  a.name.localeCompare(b.name, undefined, { sensitivity: "base" })
);
```

This preserves relative order when primary keys are equal (**stable**).

---

## Stability & DSU (decorate–sort–undecorate)

Modern JS engines implement **stable** sort; equal elements keep their relative order.
For tricky scenarios, you can enforce stability with DSU:

```ts
const withIndex = arr.map((v, i) => ({ v, i }));
withIndex.sort((a, b) => compare(a.v, b.v) || (a.i - b.i));
const out = withIndex.map(x => x.v);
```

---

## Choosing `sort` vs `toSorted`

* Mutating pipelines or performance-critical in-place work → `sort`.
* UI state / reducers / functional style → `toSorted` (clearer, safer).

---

## Common pitfalls

* **Forgetting comparator for numbers** → lexicographic order.
* **Boolean comparator** (`a > b`) → undefined behavior.
* **Mixed types** (strings & numbers) — normalize to a single type first.
* **Expensive comparator** (e.g., regex, heavy `localeCompare`) → slow sorts.

---

## Walkthrough: table-like sorting

```ts
type Row = { name: string; region: string; score: number; };
const rows: Row[] = [
  { name: "Émile", region: "eu", score: 10 },
  { name: "emile", region: "eu", score: 10 },
  { name: "Zoe",   region: "us", score: 12 },
];

// region ASC, score DESC, name ASC (case-insensitive, human-friendly)
const sorted = rows.toSorted((a, b) =>
  a.region.localeCompare(b.region) ||
  (b.score - a.score) ||
  a.name.localeCompare(b.name, undefined, { sensitivity: "base" })
);
```

---

## Reusable helpers

### 1) `numericSort` — numbers asc/desc immutably

**Starter — `numericSort.ts`**

```ts
export type Order = "asc" | "desc";

export function numericSort(xs: number[], order: Order = "asc"): number[] {
  const cmp = order === "asc" ? (a: number, b: number) => a - b
                              : (a: number, b: number) => b - a;
  // Prefer toSorted if available; otherwise copy+sort
  return xs.toSorted ? xs.toSorted(cmp) : xs.slice().sort(cmp);
}
```

---

### 2) `sortBy` — sort by a projected key

**Starter — `sortBy.ts`**

```ts
export function sortBy<T, K>(
  arr: T[],
  keyFn: (x: T) => K,
  opts?: { order?: "asc" | "desc"; collator?: Intl.Collator }
): T[] {
  const order = opts?.order ?? "asc";
  const collator = opts?.collator;
  const cmp = (a: T, b: T) => {
    const ka = keyFn(a);
    const kb = keyFn(b);
    let res: number;
    if (typeof ka === "string" && typeof kb === "string" && collator) {
      res = collator.compare(ka, kb);
    } else if (typeof ka === "number" && typeof kb === "number") {
      res = ka - kb;
    } else {
      // Fallback compare via default string coercion
      res = String(ka).localeCompare(String(kb));
    }
    return order === "asc" ? res : -res;
  };
  return arr.toSorted ? arr.toSorted(cmp) : arr.slice().sort(cmp);
}
```

> Pass `new Intl.Collator(undefined, { sensitivity: "base", numeric: true })` for human-friendly strings.

---

### 3) `compareBy` — compose multiple comparators

**Starter — `compareBy.ts`**

```ts
export type Comparator<T> = (a: T, b: T) => number;

export function compareBy<T>(...cmps: Comparator<T>[]): Comparator<T> {
  return (a, b) => {
    for (const cmp of cmps) {
      const r = cmp(a, b);
      if (r !== 0) return r;
    }
    return 0;
  };
}

// helpers to build comparators from key functions
export const asc = <T, K extends number | string>(key: (x: T) => K): Comparator<T> =>
  (a, b) => {
    const ka = key(a), kb = key(b);
    return typeof ka === "number" && typeof kb === "number"
      ? ka - kb
      : String(ka).localeCompare(String(kb));
  };

export const desc = <T, K extends number | string>(key: (x: T) => K): Comparator<T> =>
  (a, b) => -asc(key)(a, b);
```

**Example usage**

```ts
const cmp = compareBy<Row>(
  asc(r => r.region),
  desc(r => r.score),
  asc(r => r.name.toLowerCase())
);
rows.slice().sort(cmp);
```

---

## Quiz (checks)

1. Default `sort` without a comparator compares elements as:
   A) Numbers
   B) Booleans
   C) **Strings (code units)** ✅
   D) Dates

2. Which comparator is **correct** for ascending numbers?
   A) `(a,b) => a > b`
   B) `(a,b) => (a > b ? 1 : -1)`
   C) `(a,b) => a - b` ✅
   D) `(a,b) => Number(a > b)`

3. Which statement is true?
   A) `sort` is immutable.
   B) `toSorted` mutates the array.
   C) `sort` mutates; `toSorted` returns a new array. ✅
   D) Both are immutable.

4. To sort `["file2","file10","file1"]` into natural numeric order, you’d use:
   A) `(a,b)=>a.localeCompare(b, undefined, { numeric: true })` ✅
   B) `(a,b)=>a-b`
   C) `(a,b)=>Number(a)-Number(b)`
   D) Default `sort()`

5. For stable multi-key ordering, the pattern is:
   A) `(a,b)=>a.k1-b.k1 && a.k2-b.k2`
   B) `(a,b)=>(a.k1-b.k1) || (a.k2-b.k2)` ✅
   C) `(a,b)=>a.k2-b.k2 || a.k1-b.k1` only
   D) `(a,b)=>0`

---

## Takeaways

* **Always** pass a comparator for numbers; default is string comparison.
* Prefer **`toSorted`** for immutable code; use `sort` when you intentionally mutate.
* Build robust comparators: return numbers, handle ties, keep them pure.
* Compose multi-key ordering via `||` or `compareBy`.

---

## What’s next

Continue to **Arrays L2 — Searching & Testing** to master `find`, `findIndex`, `some`, `every`, and `includes`—the tools for fast queries and clear predicates.
