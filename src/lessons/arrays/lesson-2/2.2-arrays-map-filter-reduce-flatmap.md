---
id: arrays-l2-map-filter-reduce-flat-flatMap
title: "map, filter, reduce, flat, flatMap"
topic: arrays
level: 2
lesson: 2.2
prereqs:
  - arrays-l1-overview
  - arrays-l1-adding-removing-basics
  - arrays-l1-iteration-101
  - arrays-l1-copying-and-slicing-basics
  - arrays-l2-slice-vs-splice-vs-toSpliced
outcomes:
  - Use `map`, `filter`, `reduce`, `flat`, and `flatMap` fluently and know their Big-O
  - Avoid common traps `map(parseInt)`, missing `reduce` initial value, `flat` depth defaults
  - Choose between chaining vs single-pass reductions and articulate trade-offs
  - Implement small, reusable utilities `sumBy`, `flattenDepth`, `groupBy`
  - Understand holes behavior and callback signatures
tags: ["arrays","map","filter","reduce","flat","flatMap","functional","complexity"]
est_minutes: 40
checks:
  - type: quiz
    id: arrays-l2-mfrf-quiz
  - type: unit
    entry: sumBy.ts
    tests: sumBy.test.ts
  - type: unit
    entry: flattenDepth.ts
    tests: flattenDepth.test.ts
  - type: unit
    entry: groupBy.ts
    tests: groupBy.test.ts
  - type: unit
    entry: parseNumbers.ts
    tests: parseNumbers.test.ts
---

## Why this matters

These five methods are the **everyday power tools** of array processing. Master them and you’ll write cleaner code, reason about performance, and compose solutions quickly.

---

## Mental model & complexity

- **`map(fn)`** → transforms each existing element into a new array. **O(n)** time, **O(n)** extra space.
- **`filter(pred)`** → keeps elements that satisfy the predicate. **O(n)** time, **≤ O(n)** space.
- **`reduce(reducer, init?)`** → folds values into a single result. **O(n)** time, space depends on accumulator.
- **`flat(depth = 1)`** → concatenates nested arrays up to `depth`. **O(n)** over visited elements.
- **`flatMap(fn)`** → `map` then `flat(1)` in one pass. **O(n + output)** time.

> **Holes:** `map`, `filter`, `reduce`, `flat`, `flatMap` all **skip holes** (missing indices). See L1 for holes vs `undefined`.

**Callback signature** (for `map`/`filter`/`reduce`-reducer):
```ts
(value, index, array) => ...
````

---

## `map` — transform values

```ts
const xs = [1, 2, 3];
const doubled = xs.map(x => x * 2); // [2, 4, 6]
```

**Gotcha — `map(parseInt)` trap**

```ts
['10','11','12'].map(parseInt) // [10, NaN, 1]
/*
  parseInt(val, radix) sees (value, index) → radix=0,1,2!
  Fix:
*/
['10','11','12'].map(x => parseInt(x, 10)); // [10,11,12]
['10','11','12'].map(Number);               // [10,11,12]
```

---

## `filter` — keep what matches

```ts
const evens = [1,2,3,4,5,6].filter(x => x % 2 === 0); // [2,4,6]
```

**Tip:** Prefer `Boolean` to remove falsy values:

```ts
["", "ok", null, "yes", 0].filter(Boolean) // ["ok","yes"]
```

---

## `reduce` — fold to a single value

```ts
const sum = [1,2,3].reduce((acc, x) => acc + x, 0); // 6
```

**Critical:** Always consider the **initial value**.

* No initial value on empty array → **TypeError**.
* No initial value on non-empty → first element becomes initial and iteration starts at index 1.

**Patterns**

* Aggregation: sums, min/max, grouping.
* Building new structures (arrays/objects/Maps) in one pass.

---

## `flat(depth = 1)` — flatten arrays

```ts
[1, [2, [3, 4]]].flat()      // [1, 2, [3,4]]
[1, [2, [3, 4]]].flat(2)     // [1, 2, 3, 4]
```

**Default depth is 1**. Use larger depths consciously; deep flattening can be expensive.

---

## `flatMap(fn)` — map then flatten one level

```ts
const words = ["a b", "c"];
words.flatMap(w => w.split(" ")) // ["a","b","c"]
```

Equivalent to `words.map(fn).flat(1)` but typically **more efficient** and clearer.

---

## Chaining vs single-pass

* **Chaining** is readable:

  ```ts
  const out = xs.filter(p).map(f);
  ```
* **Single-pass reduce** can be faster for hot paths:

  ```ts
  const out = xs.reduce((acc, x) => (p(x) && acc.push(f(x)), acc), []);
  ```

Pick **clarity first**; optimize when profiling justifies it (we’ll benchmark in L5).

---

## Common pitfalls

* `map(parseInt)` → radix trap (use `Number` or explicit radix).
* `reduce` without an initial value → empty arrays throw; types widen oddly in TS.
* `flat` only flattens **one** level by default.
* Transforming large arrays with many intermediate copies — consider `reduce` or `flatMap`.

---

## Walkthrough: derive a leaderboard slice

Given users with scores, produce the **top 3 usernames** above a threshold:

```ts
type User = { name: string; score: number };

const top3 = (users: User[], minScore: number) =>
  users
    .filter(u => u.score >= minScore)
    .sort((a, b) => b.score - a.score)
    .slice(0, 3)
    .map(u => u.name);
```

> Reads cleanly by chaining. Later, we’ll explore immutable `toSorted` and perf trade-offs.

---

## Exercises

### 1) `sumBy<T>(arr, fn)` — sum with a projector

Return the sum of `fn(x)` over all elements. Empty array → `0`.

**Starter — `sumBy.ts`**

```ts
export function sumBy<T>(arr: T[], fn: (x: T, i: number) => number): number {
  // Use reduce with initial 0
  return 0;
}
```

**Edge cases**

* Empty array → 0
* Non-number results? Assume `fn` returns numbers (TS enforces).

---

### 2) `flattenDepth(arr, depth = 1)` — like `flat`

Implement your own `flattenDepth` without using `Array.prototype.flat`.

**Starter — `flattenDepth.ts`**

```ts
export function flattenDepth(arr: any[], depth: number = 1): any[] {
  // Iterative or recursive; clamp depth at 0+
  return [];
}
```

**Requirements**

* `depth <= 0` → return a **shallow copy**.
* Only flatten arrays (not array-likes).
* Preserve order.

---

### 3) `groupBy<T, K extends PropertyKey>(arr, keyFn)` — bucket items

Group items into an object keyed by `keyFn(value)`. (We’ll revisit a Map-based variant in L4.)

**Starter — `groupBy.ts`**

```ts
export function groupBy<T, K extends PropertyKey>(
  arr: T[],
  keyFn: (x: T) => K
): Record<K, T[]> {
  // Build with reduce; initialize buckets lazily
  return {} as Record<K, T[]>;
}
```

**Examples**

```ts
groupBy(["a","bb","c"], w => w.length as 1|2) // {1:["a","c"], 2:["bb"]}
```

---

### 4) `parseNumbers(strings)` — avoid the `parseInt` trap

Convert an array of numeric strings to numbers correctly.

**Starter — `parseNumbers.ts`**

```ts
export function parseNumbers(xs: string[]): number[] {
  // Use Number or x => parseInt(x, 10)
  return [];
}
```

---

## Quiz (checks)

1. What does `['10','11','12'].map(parseInt)` produce?
   A) `[10,11,12]`
   B) `[10, NaN, 1]` ✅
   C) Throws
   D) `["10","11","12"]`

2. Which statement about `reduce` is true?
   A) On an empty array without an initial value, it returns `undefined`.
   B) On an empty array without an initial value, it throws. ✅
   C) It always starts at index 0 even with an initial value.
   D) It visits holes.

3. `flatMap(fn)` is equivalent to:
   A) `map(fn).flat(1)` ✅
   B) `map(fn).flat()`
   C) `flat().map(fn)`
   D) `reduce(fn)`

4. Which methods **skip holes**? *(choose all)*

* `map` ✅
* `filter` ✅
* `reduce` ✅
* `flat` ✅

5. Default depth for `flat` is:
   A) `0`
   B) `1` ✅
   C) `2`
   D) `Infinity`

---

## Takeaways

* `map`/`filter`/`reduce`/`flat`/`flatMap` are **O(n)** over visited elements and **skip holes**.
* Beware `map(parseInt)`; always provide a radix or use `Number`.
* Always pick an **initial value** for `reduce`.
* Prefer readable chaining; optimize to single-pass only when it matters.

---

## What’s next

Head to **Arrays L2 — Sort & Compare** to sort primitives and objects correctly, avoid default lexicographic pitfalls, and write robust comparators.