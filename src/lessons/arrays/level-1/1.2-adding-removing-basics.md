---
id: arrays-l1-adding-removing-basics
title: "Adding & Removing (Basics)"
topic: arrays
level: 1
lesson: 1.2
prereqs: ["arrays-l1-overview"]
outcomes:
  - Use push/pop/shift/unshift correctly and explain their time complexity
  - Choose between mutating and non-mutating patterns for insert/remove at ends
  - Perform membership checks with includes/indexOf/lastIndexOf and know edge cases
  - Understand NaN, +0/-0, and equality semantics for search methods
  - "Implement small utilities: uniquePush, removeFirst, lastIndexOf polyfill"
tags: ["arrays","mutation","copying","membership","complexity"]
est_minutes: 30
checks:
  - type: quiz
    id: arrays-l1-adding-removing-quiz
  - type: unit
    entry: uniquePush.ts
    tests: uniquePush.test.ts
  - type: unit
    entry: removeFirst.ts
    tests: removeFirst.test.ts
  - type: unit
    entry: lastIndexOfPolyfill.ts
    tests: lastIndexOfPolyfill.test.ts
---

## Why this matters

Most real-world array work is: **add something**, **remove something**, or **check if it’s there**. Doing this confidently—and knowing when it’s O(1) vs O(n)—sets you up for clean, predictable code and better performance instincts.

---

## Mental model (recap)

- Arrays are indexed containers. End operations (`push/pop`) are cheap; front operations (`shift/unshift`) require **shifting** elements (costly).
- Membership checks are **linear scans** (O(n)) unless you pair arrays with a `Set`/`Map` (covered later).

---

## Add/remove at the ends

### `push(...items)` — append to the end *(amortized O(1))*
```ts
const xs = [1, 2];
xs.push(3);        // [1,2,3]
xs.push(4, 5);     // [1,2,3,4,5]
````

### `pop()` — remove from the end *(O(1))*

```ts
const last = xs.pop();  // returns removed value or undefined if empty
```

### `unshift(...items)` — insert at the front *(O(n))*

```ts
const ys = [3, 4];
ys.unshift(1, 2);  // [1,2,3,4]  ← shifts existing elements right
```

### `shift()` — remove from the front *(O(n))*

```ts
const first = ys.shift(); // returns removed value, shifts the rest left
```

> **Rule of thumb:** prefer pushing/popping at the end for performance; use front ops only when you really need queue-like semantics.

---

## Membership & searching

### `includes(value, fromIndex = 0)`

* Uses **SameValueZero** equality: `NaN` is considered equal to `NaN`, `+0` equals `-0`.

```ts
[NaN].includes(NaN);   // true
[0].includes(-0);      // true
```

### `indexOf(value, fromIndex = 0)` / `lastIndexOf(value, fromIndex?)`

* Use **strict equality** (`===`) semantics (with the classic `+0 === -0` gotcha: it’s true).
* `indexOf(NaN)` **fails**: `NaN === NaN` is false → returns `-1`.

```ts
[NaN].indexOf(NaN);    // -1
[1,2,1].lastIndexOf(1); // 2
```

When you specifically need to detect `NaN`, use `includes` or predicate-based methods like `findIndex(Number.isNaN)`.

---

## Mutating vs non-mutating patterns

### Mutating

* End insert/remove: `push/pop`
* Front insert/remove: `unshift/shift`

### Non-mutating (copy first, then change)

* End insert: `const out = [...arr, x]`
* End remove: `const out = arr.slice(0, -1)`
* Front insert: `const out = [x, ...arr]`
* Front remove: `const out = arr.slice(1)`

Prefer non-mutating variants when working with **immutable state** (e.g., React reducers). We’ll explore modern *change-by-copy* APIs (`toSpliced`, `toSorted`, etc.) later.

---

## Common pitfalls

* **Cost surprise:** `unshift/shift` are O(n). Repeated use in loops can become quadratic.
* **`indexOf(NaN)`:** always `-1`. Use `includes(NaN)` or a predicate.
* **Aliasing:** Mutating a shared reference updates all aliases (see previous lesson).

---

## Walkthrough: pick the right approach

**Scenario:** Append if *not already present*.

* Small arrays, one-off check: `includes` + `push` is fine.
* Hot path / large dataset: consider a companion `Set` for O(1) membership checks (covered in Set L2).

```ts
const xs = [1,2,3];
if (!xs.includes(3)) xs.push(3); // no-op here
```

---

## Exercises

### 1) `uniquePush(arr, value)` — append only if missing

**Goal:** Return the **same array** after appending `value` if it’s not already present. Use membership checks correctly.

**Starter — `uniquePush.ts`**

```ts
export function uniquePush<T>(arr: T[], value: T): T[] {
  // mutate arr only if needed; return arr
  // Use includes(...) for membership (handles NaN)
  return arr;
}
```

**Requirements**

* If `value` exists (by `includes`), do nothing.
* Otherwise `push` and return the original array.
* Complexity: O(n) (membership), O(1) append (amortized).

---

### 2) `removeFirst(arr, value)` — remove first occurrence (mutating & non-mutating)

**Goal:** Implement two variants:

* `removeFirstMutating(arr, value): boolean` — removes in place and returns whether removed.
* `removeFirstImmutable(arr, value): { out: typeof arr, removed: boolean }` — returns a new array with first occurrence removed.

**Starter — `removeFirst.ts`**

```ts
export function removeFirstMutating<T>(arr: T[], value: T): boolean {
  // Use indexOf (strict equality); handle -1
  return false;
}

export function removeFirstImmutable<T>(arr: T[], value: T): { out: T[]; removed: boolean } {
  // Build a new array without mutating the input
  return { out: arr, removed: false };
}
```

**Requirements**

* Mutating version may use `indexOf` then `splice(i,1)`.
* Immutable version may use slices: `[...arr.slice(0,i), ...arr.slice(i+1)]`.

---

### 3) `lastIndexOfPolyfill(arr, value, fromIndex?)`

**Goal:** Recreate `Array.prototype.lastIndexOf` semantics for learning. Do **not** actually patch the prototype; just export a function.

**Starter — `lastIndexOfPolyfill.ts`**

```ts
export function lastIndexOfPolyfill<T>(arr: T[], value: T, fromIndex?: number): number {
  // Implement per spec basics:
  // - default fromIndex = arr.length - 1
  // - if fromIndex < 0, search from arr.length + fromIndex (clamp to -1)
  // - strict equality (===) comparisons
  return -1;
}
```

**Edge cases to cover**

* Empty array
* Negative `fromIndex`
* Value not present
* Multiple matches

---

## Quiz (checks)

1. **Complexity:** Which pair is *typically* O(1) (amortized) vs O(n)?
   A) `push` O(1), `unshift` O(n) ✅
   B) `push` O(n), `unshift` O(1)
   C) `pop` O(n), `shift` O(1)
   D) `pop` O(1), `shift` O(1)

2. `indexOf(NaN)` returns:
   A) `0`
   B) `-1` ✅
   C) `true`
   D) throws

3. Which method considers `NaN` equal to `NaN`?
   A) `indexOf`
   B) `lastIndexOf`
   C) `includes` ✅
   D) `findIndex`

4. Which operations **mutate** the array? *(choose all)*

* `push` ✅
* `pop` ✅
* `slice`
* `unshift` ✅
* `shift` ✅

---

## Takeaways

* Prefer end operations (`push/pop`) when possible; front ops (`unshift/shift`) are O(n).
* `includes` is often the safest membership check (handles `NaN`), while `indexOf`/`lastIndexOf` use strict equality.
* Know when to **mutate** vs when to **copy** for immutability.

---

## What’s next

Move on to **Arrays L1 — Iteration 101** to select the right looping construct and learn how holes affect callbacks and iteration methods.
