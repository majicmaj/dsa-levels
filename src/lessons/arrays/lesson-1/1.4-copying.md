---
id: arrays-l1-copying-and-slicing-basics
title: "Arrays L1 — Copying & Slicing Basics"
topic: arrays
level: 1
prereqs: ["arrays-l1-overview","arrays-l1-adding-removing-basics","arrays-l1-iteration-101"]
outcomes:
  - Produce shallow copies safely with slice/spread/Array.from and know when each is handy
  - Extract subarrays with slice(start, end) using positive/negative indices
  - Concatenate arrays immutably with concat/spread
  - Perform simple immutable edits (append, prepend, insert, remove) without mutating the original
  - Explain why these are shallow copies and the implications for nested objects
tags: ["arrays","copying","slice","concat","immutability","basics"]
est_minutes: 30
checks:
  - type: quiz
    id: arrays-l1-copying-quiz
  - type: unit
    entry: safeAppend.ts
    tests: safeAppend.test.ts
  - type: unit
    entry: copyRange.ts
    tests: copyRange.test.ts
  - type: unit
    entry: insertRemoveImmutable.ts
    tests: insertRemoveImmutable.test.ts
---

## Why this matters

Immutability keeps state predictable (think React reducers). Mastering **copy without mutate**—and reading slices fluently—prevents subtle bugs and makes refactors safer.

---

## Copying (shallow)

All techniques below produce **shallow** copies: top-level elements are copied, nested objects are still shared.

### `slice()` with no args
```ts
const a = [1, 2, 3];
const b = a.slice();   // new array
````

### Spread `[...]`

```ts
const b = [...a];
```

### `Array.from(a)`

```ts
const b = Array.from(a);
```

> For nested structures, you still share inner references. Deep cloning is out of scope for L1.

---

## `slice(start?, end?)` — subarrays (non-mutating)

* Returns elements from **start** (inclusive) to **end** (exclusive).
* Negative indices count from the end (`-1` is last element).
* Out-of-range indices are clamped.

```ts
const a = [10, 20, 30, 40, 50];

a.slice(1, 3);   // [20, 30]
a.slice(-3);     // [30, 40, 50]
a.slice(0, -1);  // [10, 20, 30, 40]
a.slice(999);    // []
```

> Contrast for later: `splice` **mutates**; `slice` does **not**.

---

## Concatenation (non-mutating)

### `concat(...)`

```ts
[1,2].concat([3,4], 5); // [1,2,3,4,5]
```

### Spread

```ts
const out = [...[1,2], ...[3,4], 5];
```

---

## Immutable “edits” you’ll use constantly

**Append:**

```ts
const out = [...arr, x];
```

**Prepend:**

```ts
const out = [x, ...arr];
```

**Insert at index `i`:**

```ts
const out = [...arr.slice(0, i), x, ...arr.slice(i)];
```

**Remove at index `i`:**

```ts
const out = [...arr.slice(0, i), ...arr.slice(i + 1)];
```

**Replace element at `i` (copy-by-change):**

```ts
const out = [...arr.slice(0, i), newVal, ...arr.slice(i + 1)];
```

> These are the building blocks used later when we compare to modern “change-by-copy” APIs.

---

## Common pitfalls

* **Shallow only:** nested objects are shared. Mutating a nested object changes all copies that reference it.
* **Off-by-one:** remember `slice` excludes the end index.
* **Negative indexes:** `slice(0, -1)` drops the last element (handy), but `slice(-1, 0)` is `[]` (start > end).

---

## Walkthrough: keep original untouched

You have a list of scores; you need a version without the lowest and another with a bonus appended.

```ts
const scores = [4, 9, 6];

// remove first element (immutable)
const withoutFirst = scores.slice(1);       // [9, 6]

// append bonus (immutable)
const withBonus = [...scores, 10];          // [4, 9, 6, 10]

// original remains
console.log(scores);                        // [4, 9, 6]
```

---

## Exercises

### 1) `safeAppend(arr, x)` — append immutably

Return a **new** array with `x` appended. Do not mutate `arr`.

**Starter — `safeAppend.ts`**

```ts
export function safeAppend<T>(arr: T[], x: T): T[] {
  // Your code here (spread or slice+concat are fine)
  return arr;
}
```

**Requirements**

* Must return a different reference than `arr`.
* Original array remains unchanged.

---

### 2) `copyRange(arr, start, end)` — slice re-implementation

Return a new array containing elements from `start` (inclusive) to `end` (exclusive), supporting negative indices similar to `slice`.

**Starter — `copyRange.ts`**

```ts
export function copyRange<T>(arr: T[], start?: number, end?: number): T[] {
  // Normalize start/end (handle undefined, negatives, clamp to [0, arr.length])
  // Build result without using arr.slice directly
  return [];
}
```

**Edge cases**

* `start` or `end` undefined → default to 0 and arr.length.
* `start` >= `end` → `[]`.
* Negative indices count from end; clamp to bounds.

---

### 3) `insertRemoveImmutable` — tiny immutable toolkit

Export two functions:

* `insertAt<T>(arr: T[], i: number, x: T): T[]`
* `removeAt<T>(arr: T[], i: number): T[]`

**Starter — `insertRemoveImmutable.ts`**

```ts
export function insertAt<T>(arr: T[], i: number, x: T): T[] {
  // Use slices to keep it immutable
  return arr;
}

export function removeAt<T>(arr: T[], i: number): T[] {
  // Guard out-of-bounds; otherwise join slices
  return arr;
}
```

**Requirements**

* Out-of-bounds: return a **copy** of `arr` unchanged.
* In-bounds: return a new array with element inserted/removed.
* Do not mutate `arr`.

---

## Quiz (checks)

1. Which operation **mutates**?
   A) `slice`
   B) `concat`
   C) `spread [...]`
   D) `splice` ✅

2. What does `slice(1, -1)` do?
   A) Removes element at index 1 (mutating)
   B) Returns all but the first and last elements ✅
   C) Returns the last element only
   D) Throws on negative end

3. Which statement is true about copies here?

```ts
const a = [{ id: 1 }, { id: 2 }];
const b = a.slice();
b[0].id = 99;
```

A) `a[0].id` is still `1`
B) `a[0].id` is `99` ✅ (shared nested object)
C) Throws because `slice` freezes objects
D) `b` is a deep clone

4. Choose the **immutable** insert at index `i`:
   A) `arr.splice(i, 0, x); arr`
   B) `[...arr.slice(0, i), x, ...arr.slice(i)]` ✅
   C) `arr.unshift(x); arr`
   D) `arr[i] = x; arr`

---

## Takeaways

* `slice`, spread, and `Array.from` create **shallow** copies.
* `slice(start, end)` is inclusive/exclusive and supports negative indices.
* Build immutable edits with **slice+spread** patterns.
* Avoid mutating the original unless you absolutely mean to.

---

## What’s next

Head to **Arrays L2 — Slice vs Splice vs toSpliced** to compare mutation vs copy-by-change and nail down common off-by-one traps.
