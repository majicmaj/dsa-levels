---
id: arrays-l1-iteration-101
title: "Arrays L1 — Iteration 101"
topic: arrays
level: 1
prereqs: ["arrays-l1-overview","arrays-l1-adding-removing-basics"]
outcomes:
  - Choose an iteration construct (for, for…of, forEach) based on clarity and control
  - Explain how holes vs undefined affect iteration methods
  - Use keys/values/entries iterators and detect holes with the in-operator
  - Avoid common mutation-during-iteration pitfalls
  - Implement a minimal forEach polyfill that correctly skips holes
tags: ["arrays","iteration","holes","loops","forEach","for-of","entries"]
est_minutes: 30
checks:
  - type: quiz
    id: arrays-l1-iteration-quiz
  - type: unit
    entry: forEachPolyfill.ts
    tests: forEachPolyfill.test.ts
  - type: unit
    entry: countHoles.ts
    tests: countHoles.test.ts
  - type: unit
    entry: listPairs.ts
    tests: listPairs.test.ts
---

## Why this matters

Iteration is where bugs and tiny perf costs sneak in. Pick the right loop, know how **holes** behave, and you’ll write code that’s both correct and readable.

---

## Mental model

- **Classic `for`** gives you **full control** (index, `break`, `continue`, step, bounds).
- **`for…of`** iterates **values** from the array’s iterator (clean, readable).
- **`forEach`** calls a callback for each element (no early `break`/`continue`).
- **Avoid `for…in`** for arrays — it iterates *keys* (strings), skips holes, and may include custom props; order is not something to rely on.

---

## Holes & iteration behavior

A **hole** is a missing index (no property at that key). `undefined` is a real value at an existing index.

| Construct                         | Visits holes? | Notes |
|---|---:|---|
| `for (let i=0; i<arr.length; i++)` | **Indexes all** | You can detect holes with `if (i in arr)`; `arr[i]` returns `undefined` for holes. |
| `for…of (arr)`                    | No            | Uses the array iterator; skips missing elements. |
| `arr.forEach(cb)`                 | No            | Skips holes; no `break`/`continue`. |
| `arr.keys()/values()/entries()`   | No            | Iterators over existing indices/values/pairs; holes skipped. |
| `for…in (arr)`                    | Skips holes   | Iterates enumerable keys (strings). Avoid on arrays. |

```ts
const a = Array(3);       // [ <3 empty items> ]  (holes)
const b = [undefined];    // [ undefined ]        (value at index 0)

// Classic for can see the index even if it's a hole:
for (let i = 0; i < a.length; i++) {
  if (!(i in a)) console.log("hole at", i);
}
// for…of skips holes entirely:
for (const v of a) console.log("seen", v); // logs nothing
````

---

## Iteration options (with when to use)

### 1) Classic `for`

Use when you need **index math**, **early exit**, or **tight control**.

```ts
for (let i = 0; i < arr.length; i++) {
  if (!(i in arr)) continue;     // optionally skip holes
  const v = arr[i];
  if (v > 100) break;
}
```

### 2) `for…of`

Use for **clean value iteration** (most cases).

```ts
for (const v of arr) {
  // v is each existing value (holes skipped)
}
```

With indices:

```ts
for (const [i, v] of arr.entries()) {
  // i = index, v = value
}
```

### 3) `forEach`

Use when you **must** call a function for each existing element (and don’t need early break).

```ts
arr.forEach((v, i, a) => {
  // a is the original array reference
});
```

> Need early exit behavior with a predicate? Consider `some`/`every` (introduced formally in L2), or stick to `for`/`for…of`.

---

## Mutating while iterating (be careful)

* **General rule:** avoid changing length or structure while iterating the same array.
* `forEach` uses the **length at start**; values appended after iteration begins are **not** visited by that loop.
* Deleting an element before the cursor reaches it can cause it to be **skipped** (becomes a hole).
* If you must remove items while iterating, prefer:

  * Iterate a **copy** (`for (const v of [...arr])`) and mutate the original, or
  * Iterate **backwards** with a classic `for` when splicing.

---

## Keys, values, entries

```ts
const arr = ["a", "b", "c"];
for (const i of arr.keys())    console.log(i);        // 0,1,2
for (const v of arr.values())  console.log(v);        // "a","b","c"
for (const [i,v] of arr.entries()) console.log(i,v);  // 0 "a" ; 1 "b" ; 2 "c"
```

---

## Exercises

### 1) Minimal `forEach` polyfill (skip holes)

Implement `forEachPolyfill(arr, fn, thisArg?)` that:

* Takes a snapshot of `arr.length` at start
* Invokes `fn.call(thisArg, value, index, arr)` for **existing indices only**
* Skips holes and indices beyond the initial length

**Starter — `forEachPolyfill.ts`**

```ts
export function forEachPolyfill<T>(
  arr: T[],
  fn: (this: any, value: T, index: number, array: T[]) => void,
  thisArg?: any
): void {
  // Your code here
}
```

---

### 2) Count holes vs undefined

Return `{ holes, undefineds }` for an input array.

* A **hole** contributes to `holes`
* A present `undefined` contributes to `undefineds`

**Starter — `countHoles.ts`**

```ts
export function countHoles(arr: unknown[]): { holes: number; undefineds: number } {
  // Tip: use `i in arr` to detect presence
  return { holes: 0, undefineds: 0 };
}
```

**Examples**

```ts
countHoles(Array(3));         // { holes: 3, undefineds: 0 }
countHoles([undefined,,2]);   // { holes: 1, undefineds: 1 }
```

---

### 3) List pairs as "index\:value"

Produce a string array like `["0:a","1:b","2:c"]`, skipping holes.

**Starter — `listPairs.ts`**

```ts
export function listPairs(arr: unknown[]): string[] {
  // Implement using arr.entries() and for...of
  return [];
}
```

---

## Quiz (checks)

1. Which constructs **skip holes**? *(choose all)*

* `for (let i=0; i<arr.length; i++)`
* `for…of` ✅
* `arr.forEach` ✅
* `for…in` (skips, but not recommended for arrays)

2. You need **early exit** on a condition — which is simplest?
   A) `forEach` with `return` inside callback
   B) `for…of` with `break` ✅
   C) `arr.map` with `throw`
   D) `arr.forEach` with `continue`

3. Best way to iterate **indices and values** succinctly (skipping holes)?
   A) `for…in arr`
   B) `for (let i in arr) console.log(i, arr[i])`
   C) `for (const [i,v] of arr.entries())` ✅
   D) `arr.forEach((v,i)=> console.log(i,v))` (works, but no early break)

4. Which statement is true for `forEach`?
   A) It can be broken with `break`.
   B) It visits elements appended during iteration.
   C) It uses the length at the start and **won’t** visit elements appended later. ✅
   D) It visits holes.

---

## Takeaways

* Pick the iteration style that matches your needs: **control** (`for`), **clarity** (`for…of`), **callback** (`forEach`).
* **Holes** are skipped by iterators and callbacks; detect them with `i in arr` when using classic `for`.
* Don’t mutate array structure while iterating; if needed, iterate a **copy** or go **backwards**.

---

## What’s next

Head to **Arrays L1 — Copying & Slicing Basics** to master safe cloning and subarray extraction without unpleasant side effects.
