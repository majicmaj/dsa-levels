---
id: arrays-l4-object-map-interop
title: "Object/Map Interop (entries ↔ arrays ↔ Map)"
topic: arrays
level: 4
lesson: 4.4
prereqs:
  - arrays-l2-utilities-and-misc
  - arrays-l2-sort-and-compare
  - objects-l2-entries-keys-values
  - map-l1-basics
outcomes:
  - Convert cleanly between **Object ⇄ entries array ⇄ Map**
  - Sort “record-like” data by **values** (e.g., score) and rebuild structures immutably
  - Implement **invert** with explicit collision policies (first/last/group)
  - Understand **property order** caveats for Objects and when a **Map** is the better fit
  - Round-trip data safely without losing associations or order guarantees
tags: ["arrays","objects","map","entries","fromEntries","sort","invert","interop"]
est_minutes: 40
checks:
  - type: quiz
    id: arrays-l4-obj-map-interop-quiz
  - type: unit
    entry: sortObjectByValue.ts
    tests: sortObjectByValue.test.ts
  - type: unit
    entry: objectFromPairsStable.ts
    tests: objectFromPairsStable.test.ts
  - type: unit
    entry: mapObjectRoundTrip.ts
    tests: mapObjectRoundTrip.test.ts
  - type: unit
    entry: invertMap.ts
    tests: invertMap.test.ts
  - type: unit
    entry: topNFromObject.ts
    tests: topNFromObject.test.ts
---

## Why this matters

So much real data is “record-like” (`{ userId: score }`, `{ sku: qty }`). To analyze or present it, you’ll often:
1) turn it into an **array of pairs** for sorting/slicing,
2) maybe move to a **Map** for richer keys or explicit order,
3) and **round-trip** back.

Getting these conversions right keeps your code tidy and predictable.

---

## Interop cheatsheet

```ts
// Object → entries array
const entries = Object.entries(obj);         // [ [key, value], ... ]

// entries array → Object
const obj2 = Object.fromEntries(entries);

// Object → Map  (string keys only)
const map = new Map(Object.entries(obj));

// Map → Object  (Map keys must be strings/symbols)
const obj3 = Object.fromEntries(map);

// Array of pairs → Map
const map2 = new Map(entries);

// Map → array of pairs
const entries2 = [...map];                   // or Array.from(map)
````

> **TypeScript tip:** prefer `Record<string, T>` when your keys are strings. Use `Map<K,V>` when keys aren’t strings or you care about insertion order & `.size`.

---

## Sorting an object by **value**

Objects aren’t inherently “sorted”. To present “top scores”, sort the **entries array**, then decide whether to keep it as a list, a Map, or rebuild a fresh object.

```ts
const byScoreDesc = (o: Record<string, number>) =>
  Object.fromEntries(
    Object.entries(o).toSorted((a, b) => b[1] - a[1]) // value desc
  );
```

* For **stable** ordering or non-string keys, prefer returning a **Map** or the **entries array**.
* If your consumers rely on iteration order, an **array** is the clearest, a **Map** is acceptable, an **Object** is okay for simple cases (see caveats below).

---

## Inverting key/value (with collisions)

Two or more keys may share the same value. You must **pick a policy**:

* **first-win:** keep the earliest key
* **last-win:** later key overwrites earlier
* **group:** collect all original keys under the inverted key

```ts
// group policy (safe)
function invertGroup(o: Record<string, string>): Record<string, string[]> {
  const out: Record<string, string[]> = {};
  for (const [k, v] of Object.entries(o)) (out[v] ??= []).push(k);
  return out;
}
```

For Maps, the pattern is the same with `m.get`/`m.set`.

---

## Property order caveats (Objects)

Iteration over **string keys** in Objects is mostly insertion order, **except** that “integer-like” keys (`"0"`, `"1"`, …) are enumerated first in ascending numeric order. If true order matters, pick:

* **Array** (explicit order you control), or
* **Map** (insertion order, explicit `.size`, non-string keys allowed).

---

## Walkthrough: scoreboard → top N

Given `{ user: score }`, show the **top 3** as `[ [user, score], ... ]` and also return a **Map** for further work:

```ts
type Scores = Record<string, number>;

export function topNFromObject(scores: Scores, n: number) {
  const sorted = Object.entries(scores).toSorted((a, b) => b[1] - a[1]);
  const top = sorted.slice(0, Math.max(0, n));
  const asMap = new Map(top);
  return { top, asMap };
}
```

---

## Common pitfalls

* **Losing non-string keys:** `Object.fromEntries(map)` throws if keys aren’t strings/symbols. Keep it a Map or convert keys explicitly (`String(k)`).
* **Assuming order on Objects:** okay for simple UI lists, but arrays/Maps are clearer and safer.
* **Accidental mutation:** always create **new** entries arrays; use `toSorted` (immutable) or `slice().sort(...)`.

---

## Exercises

### 1) `sortObjectByValue(obj, order='desc')` — return entries

Return a **new array of `[key, value]`** pairs sorted by value. Do **not** mutate the input.

**Starter — `sortObjectByValue.ts`**

```ts
export type Order = "asc" | "desc";

export function sortObjectByValue(
  obj: Record<string, number>,
  order: Order = "desc"
): Array<[string, number]> {
  // Build Object.entries(obj), toSorted by value, flip comparator for asc
  return [];
}
```

---

### 2) `objectFromPairsStable(pairs)` — safe rebuild

Given an array of `[key, value]`, rebuild a **new object** immutably.

**Starter — `objectFromPairsStable.ts`**

```ts
export function objectFromPairsStable<K extends string, V>(
  pairs: Array<[K, V]>
): Record<K, V> {
  // Use Object.fromEntries; do not mutate original inputs
  return {} as Record<K, V>;
}
```

---

### 3) `mapObjectRoundTrip(obj)` — object ⇄ entries ⇄ map ⇄ object

Round-trip and return `{ entries, map, obj2 }` where `obj2` is equal (by keys & values) to `obj`.

**Starter — `mapObjectRoundTrip.ts`**

```ts
export function mapObjectRoundTrip(
  obj: Record<string, unknown>
): {
  entries: Array<[string, unknown]>;
  map: Map<string, unknown>;
  obj2: Record<string, unknown>;
} {
  // Build entries → Map → Object.fromEntries and return all
  return { entries: [], map: new Map(), obj2: {} };
}
```

---

### 4) `invertMap(m, policy)` — collisions handled

Implement `invertMap<K, V>(m: Map<K, V>, policy: "first" | "last" | "group")`

* For `"first"`/`"last"`, return `Map<V, K>`
* For `"group"`, return `Map<V, K[]>`

**Starter — `invertMap.ts`**

```ts
export function invertMap<K, V>(
  m: Map<K, V>,
  policy: "first" | "last" | "group" = "group"
): Map<V, K | K[]> {
  // Iterate pairs; enforce policy; for group collect arrays
  return new Map<V, K | K[]>();
}
```

**Notes**

* Use SameValueZero semantics (native Map) for value equality.
* Preserve insertion order for first/last by iterating **in input order**.

---

### 5) `topNFromObject(scores, n)` — from walkthrough

Return `{ top, asMap }` where `top` is an array of top `n` `[user, score]`.

**Starter — `topNFromObject.ts`**

```ts
export function topNFromObject(
  scores: Record<string, number>,
  n: number
): { top: Array<[string, number]>; asMap: Map<string, number> } {
  // Sort entries by value desc, slice n, create Map
  return { top: [], asMap: new Map() };
}
```

---

## Quiz (checks)

1. Which conversion **fails** if a Map has non-string keys?
   A) `new Map(Object.entries(obj))`
   B) `Object.fromEntries(map)` ✅
   C) `[...map]`
   D) `Array.from(map)`

2. Best container when you need **insertion order** and **non-string keys**:
   A) Object
   B) **Map** ✅
   C) Array only
   D) WeakMap

3. Sorting an object “by value” typically means:
   A) Sort the object in place
   B) **Sort `Object.entries(obj)` by the value element** ✅
   C) Sort `Object.keys(obj)`
   D) Sort `Object.values(obj)` and zip

4. Inversion with collisions is safest when you:
   A) Throw on duplicates
   B) Keep the first only
   C) Keep the last only
   D) **Group duplicates into arrays** ✅

5. Objects enumerate **integer-like** keys:
   A) In random order
   B) **Ascending numeric first**, then other strings in insertion order ✅
   C) Descending numeric first
   D) In hash order

---

## Takeaways

* Convert via **entries**; choose **Map** when keys aren’t strings or order matters, otherwise Objects are fine.
* To “sort an object”, **sort its entries** and keep an array/Map or rebuild a fresh object.
* **Inversion requires policy**—be explicit (first/last/group).
* Beware Object property order for integer-like keys; when in doubt, prefer arrays/Map for ordered data.

---

## What’s next

Level 5 time! Jump to **Arrays L5 — TypeScript Advanced** to make your helpers strongly typed (readonly arrays, tuples, generics, variadic tuples), and to add compile-time checks to your utilities.
