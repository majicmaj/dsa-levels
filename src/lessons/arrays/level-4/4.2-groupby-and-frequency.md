---
id: arrays-l4-groupby-and-frequency
title: "GroupBy & Frequency (Objects & Map)"
topic: arrays
level: 4
lesson: 4.2
prereqs:
  - arrays-l2-map-filter-reduce-flat-flatMap
  - arrays-l2-searching-and-testing
  - objects-l2-entries-keys-values
  - map-l1-basics
outcomes:
  - Group items into buckets by a key using **plain objects** and using **Map**
  - Build frequency tables (histograms) and derive Top-K results efficiently
  - "Choose the right container: Object vs Map (key types, performance, safety)"
  - Handle normalization (case, trim) and collision cases sanely
  - "Convert between structures: entries ↔ arrays ↔ objects/Map with `Object.fromEntries` and `new Map([...])`"
tags: ["arrays","groupBy","countBy","map","object","histogram","top-k","entries"]
est_minutes: 40
checks:
  - type: quiz
    id: arrays-l4-groupby-quiz
  - type: unit
    entry: groupByObject.ts
    tests: groupByObject.test.ts
  - type: unit
    entry: groupByMap.ts
    tests: groupByMap.test.ts
  - type: unit
    entry: countBy.ts
    tests: countBy.test.ts
  - type: unit
    entry: topKFrequent.ts
    tests: topKFrequent.test.ts
  - type: unit
    entry: normalizeAndGroup.ts
    tests: normalizeAndGroup.test.ts
---

## Why this matters

Turning a flat list into **buckets** or **counts** powers real features: tag pages, analytics “top N,” facets/filters, and reports. Once you internalize groupBy/countBy patterns, lots of problems collapse into a few clean reductions.

---

## Mental model

- **GroupBy:** build a dictionary `key → T[]` of items that share a key.
- **CountBy (frequency):** build `key → number` counts.
- **Containers:**
  - **Object** (`Record<string, …>`): keys are **strings/symbols**; other primitives are stringified.
  - **Map<K, V>**: keys can be **any value** (strings, numbers, booleans, objects), preserves insertion order explicitly.
- **Normalization:** define equality up front (e.g., `trim().toLowerCase()`).

**Complexity:** One pass → **O(n)** time; space proportional to unique keys **O(u)**.

---

## Object vs Map — how to choose

| Use case | Prefer |
|---|---|
| Keys are known **strings** (e.g., `"us"`, `"eu"`) and you want JSON | **Object** |
| Keys may be non-strings (numbers, booleans, objects) or you care about strict key identity | **Map** |
| You want ergonomic iteration order + built-in size | **Map** |
| You’ll serialize to JSON easily | **Object** |

Conversions:
```ts
const obj = Object.fromEntries(myMap);       // Map → Object (string keys only!)
const map = new Map(Object.entries(obj));    // Object → Map
````

---

## GroupBy (Object)

```ts
export function groupByObject<T, K extends PropertyKey>(
  xs: T[],
  keyFn: (x: T) => K
): Record<K, T[]> {
  const out = {} as Record<K, T[]>;
  for (const x of xs) {
    const k = keyFn(x);
    (out[k] ??= []).push(x);
  }
  return out;
}
```

* **Pros:** simple, JSON-ready.
* **Gotchas:** keys are stringified; `__proto__` is no longer special on modern engines for plain objects, but if you want to be extra-safe use `Object.create(null)` to avoid prototype properties.

```ts
const byLen = groupByObject(["a","bb","c"], s => s.length as 1|2);
// { 1: ["a","c"], 2: ["bb"] }
```

---

## GroupBy (Map)

```ts
export function groupByMap<T, K>(xs: T[], keyFn: (x: T) => K): Map<K, T[]> {
  const m = new Map<K, T[]>();
  for (const x of xs) {
    const k = keyFn(x);
    const bucket = m.get(k);
    if (bucket) bucket.push(x);
    else m.set(k, [x]);
  }
  return m;
}
```

* **Pros:** supports non-string keys; explicit order; `m.size`.
* **Gotchas:** `Map` keys use **same-value zero** equality like `Set`; for object keys, identity matters.

---

## CountBy (frequency)

```ts
export function countBy<T, K extends PropertyKey>(
  xs: T[],
  keyFn: (x: T) => K
): Record<K, number> {
  const out = {} as Record<K, number>;
  for (const x of xs) {
    const k = keyFn(x);
    out[k] = (out[k] ?? 0) + 1;
  }
  return out;
}
```

**Map variant** mirrors the pattern with `m.set(k, (m.get(k) ?? 0) + 1)`.

---

## Top-K from frequencies

1. Build frequency table in O(n).
2. Turn into entries and sort by count (O(u log u)), then take first K.
   For very large `u` with small K, use a **min-heap** (future lesson).

```ts
type Entry = [string, number];

export function topKFrequent(xs: string[], k: number): Entry[] {
  const freq = countBy(xs, s => s);
  return Object.entries(freq)
    .sort((a, b) => b[1] - a[1])
    .slice(0, k);
}
```

---

## Normalization matters

```ts
const normalize = (s: string) => s.trim().toLowerCase();
const groups = groupByObject(emails, normalize);
// Decide if you want to store **original** values in buckets or normalized: be explicit.
```

---

## Common pitfalls

* **Stringifying unintendedly:** using Object when keys aren’t really strings → collisions like `1` and `"1"` are indistinguishable.
* **Not normalizing:** “`Alice`” vs “`alice  `” end up in different buckets.
* **Losing order:** Object property iteration order is insertion-ish for string keys but with some nuanced rules; if strict ordering matters, use `Map` and then `Array.from(map)`.

---

## Walkthrough: tag index & Top-K tags

**Goal:** Given posts `{id, tags: string[]}`, produce

1. `tag → posts[]` (groupBy)
2. top 5 tags by frequency.

```ts
type Post = { id: number; tags: string[] };

function indexTags(posts: Post[]) {
  const tagToPosts = new Map<string, number[]>();   // tag → postIds
  for (const p of posts) {
    for (const raw of p.tags) {
      const tag = raw.trim().toLowerCase();
      const arr = tagToPosts.get(tag) ?? [];
      arr.push(p.id);
      tagToPosts.set(tag, arr);
    }
  }

  const top = Array.from(tagToPosts, ([tag, ids]) => [tag, ids.length] as const)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5);

  return { tagToPosts, top };
}
```

---

## Exercises

### 1) `groupByObject(xs, keyFn)` — object buckets

**Starter — `groupByObject.ts`**

```ts
export function groupByObject<T, K extends PropertyKey>(
  xs: T[],
  keyFn: (x: T) => K
): Record<K, T[]> {
  // Use {} or Object.create(null) for extra safety
  return {} as Record<K, T[]>;
}
```

**Tests:** multiple buckets, empty input, numeric keys, preserve order within buckets.

---

### 2) `groupByMap(xs, keyFn)` — Map buckets

**Starter — `groupByMap.ts`**

```ts
export function groupByMap<T, K>(xs: T[], keyFn: (x: T) => K): Map<K, T[]> {
  // Build Map<K, T[]> in one pass
  return new Map<K, T[]>();
}
```

**Tests:** boolean keys, object identity keys, `.size` correctness.

---

### 3) `countBy(xs, keyFn)` — frequency table

**Starter — `countBy.ts`**

```ts
export function countBy<T, K extends PropertyKey>(
  xs: T[],
  keyFn: (x: T) => K
): Record<K, number> {
  return {} as Record<K, number>;
}
```

**Tests:** normalization, empty input, large repeats.

---

### 4) `topKFrequent(xs, k)` — Top-K via sort

**Starter — `topKFrequent.ts`**

```ts
export function topKFrequent(xs: string[], k: number): Array<[string, number]> {
  // Build countBy; sort entries desc by count; slice k
  return [];
}
```

**Follow-up:** if `k <= 0` ⇒ `[]`. If `k >= unique`, return all.

---

### 5) `normalizeAndGroup(xs, norm)` — keep originals, group by normalized key

**Starter — `normalizeAndGroup.ts`**

```ts
export function normalizeAndGroup(
  xs: string[],
  norm: (s: string) => string = s => s.trim().toLowerCase()
): Record<string, string[]> {
  // Buckets keyed by normalized; values are trimmed originals in insertion order
  return {};
}
```

**Tests:** whitespace/case variants land together; original forms preserved.

---

## Quiz (checks)

1. Which container allows **non-string** keys without coercion?
   A) Object
   B) **Map** ✅
   C) Array
   D) Set only

2. Complexity to build a groupBy in one pass is:
   A) **O(n)** time, **O(u)** space ✅
   B) O(n log n) time, O(1) space
   C) O(u log n) time, O(n) space
   D) O(1)

3. Which conversion is **correct**?
   A) `Object.fromEntries(obj)`
   B) `new Map(obj)`
   C) `new Map(Object.entries(obj))` ✅
   D) `Map.from(obj)`

4. To compute **Top-K** from a frequency table with small K on huge `u`, the most scalable approach is:
   A) Sort all entries
   B) **Maintain a size-K min-heap** (learn later) ✅
   C) Filter then reduce
   D) Map over entries twice

5. In an Object-based groupBy, keys are compared by:
   A) Reference
   B) **String equality after coercion** ✅
   C) SameValueZero
   D) Deep equality

---

## Takeaways

* Grouping and counting are **one-pass** patterns. Choose **Object** for string keys and JSON, **Map** for generality and order.
* Normalize keys (case/trim) consciously to express your equality model.
* Top-K = build counts → pick biggest; sort for simplicity, heap for scalability.
* Converting between arrays, objects, and maps is a superpower — use `entries`/`fromEntries`.

---

## What’s next

Head to **Arrays L4 — Anagrams Pipeline** to combine **Strings** and **Arrays**: `split → sort → join` vs frequency-map strategies, plus pitfalls and complexity.

