---
id: arrays-l3-dynamic-array-internals
title: "Dynamic Array Internals"
topic: arrays
level: 3
lesson: 3.1
prereqs:
  - arrays-l1-overview
  - arrays-l1-iteration-101
  - arrays-l2-utilities-and-misc
outcomes:
  - Explain how dynamic arrays provide O(1) *amortized* appends
  - Implement a tiny `DynamicArray<T>` with push/pop/get/set/insert/remove
  - Reason about growth factors, copying cost, and shrink strategies
  - Choose when in-place mutation vs copy-by-change is preferable
  - Analyze time/space for mid-array insert/delete (O(n)) vs end ops (O(1) amortized)
tags: ["arrays","internals","implementation","amortized","capacity","growth","performance"]
est_minutes: 45
checks:
  - type: quiz
    id: arrays-l3-dynarray-quiz
  - type: unit
    entry: DynamicArray.ts
    tests: DynamicArray.test.ts
  - type: unit
    entry: dynArrayInsertRemove.ts
    tests: dynArrayInsertRemove.test.ts
---

## Why this matters

JavaScript arrays *feel* magical—but under the hood, common runtimes back them with something like a **dynamic array**: contiguous storage with **spare capacity** that grows when needed. Understanding this explains why appends are usually cheap, why middle inserts are costly, and how choices like growth factor affect performance.

---

## Mental model

- Keep elements in contiguous slots `[0..size-1]`.
- Maintain two numbers:
  - `size` — how many elements are *actually stored*.
  - `capacity` — how many elements *fit without reallocating*.
- When `size == capacity` and you `push`, **allocate a bigger buffer**, **copy** existing elements, then append.
- Choose a **growth factor** (commonly ×2). This makes average append **O(1) amortized** though an occasional resize costs **O(n)**.
- Removing from the middle **shifts** trailing elements left → **O(n)**.

---

## Core operations & complexity

| Operation                | Time (amortized) | Notes |
|---|---:|---|
| `get(i)` / `set(i,v)`   | O(1)             | Bounds checks only |
| `push(v)`               | O(1)*            | Occasional O(n) on resize → amortized O(1) |
| `pop()`                 | O(1)             | Optional shrink on low utilization |
| `insert(i,v)`           | O(n)             | Shift right elements `[i..size-1]` |
| `removeAt(i)`           | O(n)             | Shift left elements `[i+1..size-1]` |
| `toArray()`             | O(n)             | Return a trimmed copy |

> Shrinking: a common policy is **halve** when `size ≤ capacity/4` to avoid resize thrash.

---

## Implementation sketch (TypeScript)

**Starter — `DynamicArray.ts`**
```ts
export class DynamicArray<T> {
  private buf: T[];        // backing storage
  private _size = 0;       // number of used elements
  private _capacity: number;

  constructor(initialCapacity = 4) {
    if (initialCapacity < 1) initialCapacity = 1;
    this._capacity = this.nextPow2(initialCapacity);
    this.buf = new Array(this._capacity); // holes are fine
  }

  size(): number { return this._size; }
  capacity(): number { return this._capacity; }
  isEmpty(): boolean { return this._size === 0; }

  at(index: number): T {
    this.boundsCheck(index);
    // buf may have holes beyond _size; within size we always wrote values
    return this.buf[index] as T;
  }

  set(index: number, value: T): void {
    this.boundsCheck(index);
    this.buf[index] = value;
  }

  push(value: T): void {
    if (this._size === this._capacity) this.grow(this._capacity * 2);
    this.buf[this._size++] = value;
  }

  pop(): T | undefined {
    if (this._size === 0) return undefined;
    const v = this.buf[--this._size];
    // optional: clear slot to help GC
    (this.buf as any)[this._size] = undefined;
    this.shrinkIfNeeded();
    return v as T;
  }

  insert(index: number, value: T): void {
    if (index < 0 || index > this._size) throw new RangeError("index out of range");
    if (this._size === this._capacity) this.grow(this._capacity * 2);
    // shift right [index.._size-1]
    for (let i = this._size; i > index; i--) {
      this.buf[i] = this.buf[i - 1] as T;
    }
    this.buf[index] = value;
    this._size++;
  }

  removeAt(index: number): T {
    this.boundsCheck(index);
    const v = this.buf[index] as T;
    // shift left [index+1.._size-1]
    for (let i = index; i < this._size - 1; i++) {
      this.buf[i] = this.buf[i + 1] as T;
    }
    (this.buf as any)[--this._size] = undefined; // clear tail
    this.shrinkIfNeeded();
    return v;
  }

  toArray(): T[] {
    // return a compact copy of the logical elements
    const out = new Array<T>(this._size);
    for (let i = 0; i < this._size; i++) out[i] = this.buf[i] as T;
    return out;
  }

  // ---- helpers ----
  private boundsCheck(i: number): void {
    if (i < 0 || i >= this._size) throw new RangeError("index out of range");
  }

  private grow(newCap: number): void {
    const cap = Math.max(this._capacity * 2, newCap);
    const next = new Array<T>(cap);
    for (let i = 0; i < this._size; i++) next[i] = this.buf[i] as T;
    this.buf = next;
    this._capacity = cap;
  }

  private shrinkIfNeeded(): void {
    if (this._capacity <= 4) return; // floor
    if (this._size <= (this._capacity >> 2)) {
      const cap = Math.max(4, this._capacity >> 1);
      const next = new Array<T>(cap);
      for (let i = 0; i < this._size; i++) next[i] = this.buf[i] as T;
      this.buf = next;
      this._capacity = cap;
    }
  }

  private nextPow2(x: number): number {
    let n = 1;
    while (n < x) n <<= 1;
    return n;
  }
}
````

> We deliberately write manual copies and shifts to **feel** the cost of mid-array edits.

---

## Pitfalls & design choices

* **Growth factor:** ×2 is a good general choice. Too small (e.g., +1) → frequent reallocations. Too large (×4+) → memory bloat.
* **Shrink policy:** shrink at **25% utilization** balances memory vs thrash. You may disable shrinking for hot append-heavy workloads.
* **GC friendliness:** clearing vacated slots helps garbage collection in long-lived arrays.
* **Bounds semantics:** decide whether `insert(size,value)` is allowed (append). We allow it.

---

## Walkthrough: cost of a single resize (intuition)

If you append `n` items starting from capacity 1 with growth ×2, you’ll copy:
`1 + 2 + 4 + … + n/2 ≈ 2n` elements total over the whole build.
Spread over `n` pushes, **average \~2 copies per push** → amortized **O(1)**.

---

## Exercises

### 1) Complete the `DynamicArray<T>` (push/pop/get/set/insert/remove)

Add any missing edge checks & make all methods pass tests.

**Tests expect**

* Correct `size()` / `capacity()` tracking
* `toArray()` matches sequence of pushes/inserts/removes
* Amortized behavior (no assertion on exact counts, but capacity should grow roughly ×2)

---

### 2) `dynArrayInsertRemove.ts` — higher-level ops

Implement two helpers that operate *on the class*:

```ts
import { DynamicArray } from "./DynamicArray";

export function spliceInsert<T>(arr: DynamicArray<T>, index: number, items: T[]): void {
  // insert items in order at index
}

export function removeRange<T>(arr: DynamicArray<T>, start: number, count: number): void {
  // remove count items starting at start
}
```

**Requirements**

* `spliceInsert` inserts all items in original order.
* `removeRange` shifts left once per element (simple O(n·count) approach is fine for L3).

---

## Quiz (checks)

1. Why is `push` **amortized** O(1) instead of worst-case O(1)?
   A) Because V8 uses linked lists
   B) Because occasional resizes cost O(n), averaged over many pushes ✅
   C) Because `push` never resizes
   D) Because `push` is implemented in C++

2. With growth factor ×2 starting from capacity 1, after pushing 9 elements the capacity will be at least:
   A) 8
   B) 9
   C) 16 ✅
   D) 32

3. Which operation is **O(n)** on a dynamic array?
   A) `get(i)`
   B) `set(i,v)`
   C) `insert(0, v)` ✅
   D) `push(v)` amortized

4. A reasonable shrink policy triggers when:
   A) `size == capacity`
   B) `size ≤ capacity / 4` ✅
   C) `size ≤ capacity / 2` always
   D) Never shrink

5. What does `toArray()` return?
   A) The internal buffer (same reference)
   B) A trimmed copy of logical elements ✅
   C) An iterator
   D) Nothing; it mutates in place

---

## Takeaways

* Dynamic arrays trade **occasional expensive resizes** for **cheap average appends**.
* Middle insert/remove costs **O(n)** due to shifting.
* Thoughtful **growth** and **shrink** policies balance performance and memory.
* Implementing one by hand makes JS array behaviors (mutate vs copy, end vs middle ops) intuitive.

---

## What’s next

Move to **Arrays L3 — In-Place Ops & Two Pointers** to practice safe in-place transforms (reverse, rotate, remove-in-place) and the two-pointer pattern.
