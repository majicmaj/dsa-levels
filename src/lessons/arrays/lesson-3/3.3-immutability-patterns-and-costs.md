---
id: arrays-l3-immutability-patterns-and-costs
title: "Immutability Patterns & Costs"
topic: arrays
level: 3
lesson: 3.3
prereqs:
  - arrays-l1-copying-and-slicing-basics
  - arrays-l2-utilities-and-misc
  - arrays-l2-map-filter-reduce-flat-flatMap
outcomes:
  - Apply immutable “copy-by-change” patterns without accidental mutation
  - Refactor chained array operations into a single pass when it matters
  - Recognize and avoid quadratic copy patterns in loops
  - Perform nested updates (array of objects with inner arrays) using structural sharing
  - Batch edits efficiently (O(n + k)) instead of repeated O(n) copies
tags: ["arrays","immutability","performance","structural-sharing","copy-by-change"]
est_minutes: 45
checks:
  - type: quiz
    id: arrays-l3-immutability-quiz
  - type: unit
    entry: fuseMapFilterMap.ts
    tests: fuseMapFilterMap.test.ts
  - type: unit
    entry: updateUserImmutable.ts
    tests: updateUserImmutable.test.ts
  - type: unit
    entry: patchAtIndices.ts
    tests: patchAtIndices.test.ts
  - type: unit
    entry: withoutNth.ts
    tests: withoutNth.test.ts
---

## Why this matters

Immutability makes state **predictable** (think React reducers), plays nice with time-travel/debugging, and reduces aliasing bugs. But every copy costs **O(n)**. The craft is knowing **when** to copy, **how much**, and **how often**—and when to fuse passes to avoid hidden quadratic work.

---

## Mental model

- **Copy-by-change:** build a new array from slices/spreads (or modern change-by-copy APIs) while **reusing untouched parts**.
- **Structural sharing:** keep references to unmodified portions; only copy the path you’re changing.
- **Cost lens:** a single spread `[...]` over length `n` is **O(n)**. Repeating it in a loop can silently become **O(n²)**.
- **Clarity vs speed:** prefer clear chaining; fuse passes only in hot paths or large data.

---

## Core patterns

### 1) Replace/insert/remove immutably (outer array)
- **Replace at `i`:**
  ```ts
  const out = [...xs.slice(0, i), value, ...xs.slice(i + 1)];
  ```

* **Insert at `i`:**

  ```ts
  const out = [...xs.slice(0, i), value, ...xs.slice(i)];
  ```
* **Remove at `i`:**

  ```ts
  const out = [...xs.slice(0, i), ...xs.slice(i + 1)];
  ```

> We’ll see modern `with`/`toSpliced` in L5; patterns above are the portable baseline.

---

### 2) Nested updates with structural sharing

When updating `users[idx].profile.tags`, don’t deep-clone everything:

```ts
const users2 = users.map(u =>
  u.id === id
    ? { ...u, profile: { ...u.profile, tags: u.profile.tags.map(t => t === oldTag ? newTag : t) } }
    : u
);
```

Only the changed user object and its `profile` and `tags` arrays get new references.

---

### 3) Avoid N×O(n) copies: batch edits

Repeated spreads in a loop:

```ts
// ❌ O(n*k) copies if patches has k edits
let out = xs;
for (const [i, v] of patches) {
  out = [...out.slice(0, i), v, ...out.slice(i + 1)];
}
```

Prefer **one copy**, then assign:

```ts
// ✅ O(n + k)
const out = xs.slice();
for (const [i, v] of patches) if (i >= 0 && i < out.length) out[i] = v;
```

---

### 4) Chaining vs fused passes

Readable chain:

```ts
const out = xs.map(f).filter(p).map(g); // 2–3 passes, extra arrays
```

Fused single pass:

```ts
const out: C[] = [];
for (let i = 0; i < xs.length; i++) {
  const b = f(xs[i]);
  if (p(b)) out.push(g(b));
}
```

Use fused form **only** when profiling indicates the chain is a bottleneck.

---

## Common pitfalls

* **Deep clone by habit:** unnecessary and slow; copy only the path you change.
* **Spread-in-a-loop:** each `[...]` walks the whole array → accidental **O(n²)**.
* **Accidental mutation:** forgetting to copy an inner array/object before editing.
* **Over-fusing:** premature optimization hurts readability; measure first.

---

## Walkthrough: scoreboard update (batched & nested)

**Task:** Given `players: {id:number, name:string, tags:string[], score:number}[]`, apply:

* `+10` to players with tag `"vip"`,
* rename tag `"rookie"` → `"rising"` (for all players),
* and set `score = 0` for banned IDs.

**Sketch (structural sharing + batch):**

```ts
function updatePlayers(players: Player[], banned: Set<number>): Player[] {
  return players.map(p => {
    if (banned.has(p.id)) return { ...p, score: 0 };           // copy player only
    const tags = p.tags.includes("rookie")
      ? p.tags.map(t => (t === "rookie" ? "rising" : t))       // copy tags only if needed
      : p.tags;
    const score = p.tags.includes("vip") ? p.score + 10 : p.score;
    if (tags === p.tags && score === p.score) return p;        // reuse reference if unchanged
    return { ...p, score, tags };
  });
}
```

Note the **reference reuse** when nothing changes (cheap equality checks improve downstream memoization).

---

## Exercises

### 1) `fuseMapFilterMap` — one-pass equivalence

Implement a single-pass equivalent of `xs.map(map1).filter(pred).map(map2)`.

**Starter — `fuseMapFilterMap.ts`**

```ts
export function fuseMapFilterMap<A, B, C>(
  xs: A[],
  map1: (a: A, i: number) => B,
  pred: (b: B, i: number) => boolean,
  map2: (b: B, i: number) => C
): C[] {
  // Build result in one loop, preserving order and semantics
  return [];
}
```

**Requirements**

* Exactly the same observable results as the 3-step chain.
* Do **not** allocate intermediate arrays.
* Time: O(n), Space: O(n).

---

### 2) `updateUserImmutable` — nested structural sharing

Given:

```ts
export type User = { id: number; profile: { name: string; tags: string[] } };
```

Implement:

```ts
export function updateUserImmutable(
  users: User[],
  id: number,
  fn: (u: User) => User
): User[] {
  // Return a new array; copy only the user that matches id.
}
```

**Follow-up in tests**

* Add a helper to **replace one tag** in the matched user:
  `replaceTag(users, id, oldTag, newTag)`.
* Ensure unchanged users keep original references (===).

---

### 3) `patchAtIndices` — batch edits in O(n + k)

Apply a list of `[index, value]` patches immutably.

**Starter — `patchAtIndices.ts`**

```ts
export function patchAtIndices<T>(xs: T[], patches: Array<[number, T]>): T[] {
  // Make one shallow copy, then assign valid indices
  return xs;
}
```

**Edge cases**

* Ignore out-of-bounds indices.
* If `patches` is empty, you may return `xs` directly (same reference).

---

### 4) `withoutNth` — remove item at index immutably

Prefer modern `toSpliced` if available; otherwise slice+spread.

**Starter — `withoutNth.ts`**

```ts
export function withoutNth<T>(xs: T[], i: number): T[] {
  // If toSpliced exists, use it; else slices
  return xs;
}
```

---

## Quiz (checks)

1. Copy-by-change with `[...]` has time complexity:
   A) O(1)
   B) **O(n)** ✅
   C) O(log n)
   D) O(n log n)

2. Spreading inside a loop that runs `k` times typically leads to:
   A) O(k)
   B) O(n)
   C) **O(n·k)** and can be **O(n²)** if k≈n ✅
   D) O(1)

3. Structural sharing means:
   A) Deep cloning everything to be safe
   B) Reusing unchanged references and copying only the modified path ✅
   C) Mutating in place to save memory
   D) Using WeakMap for all state

4. Which is the most efficient immutable way to apply many single-index replacements?
   A) Rebuild with `[...]` for each patch
   B) Make one `slice()` copy and assign all patches ✅
   C) Use `map` with an `includes(index)` check per element
   D) Sort patches and `splice` repeatedly

5. Best rule of thumb for chaining vs fusing passes:
   A) Always fuse — it’s faster
   B) Always chain — it’s cleaner
   C) Chain by default; **fuse only when profiling says you need to** ✅
   D) Neither matters

---

## Takeaways

* **Immutability ≠ deep clone.** Copy only what changes; reuse the rest.
* Beware hidden **O(n²)** from repeated spreads or splices in loops.
* Batch edits in **O(n + k)** with one outer copy.
* Fuse chains only in performance-sensitive paths; prefer readability first.

---

## What’s next

Advance to **Arrays L3 — Stable Sorting & Custom Keys** to build stable sort helpers, DSU (decorate–sort–undecorate), and robust multi-key comparators.
