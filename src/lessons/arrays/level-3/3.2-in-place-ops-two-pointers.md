---
id: arrays-l3-in-place-ops-two-pointers
title: "In-Place Ops & Two-Pointers"
topic: arrays
level: 3
lesson: 3.2
prereqs:
  - arrays-l1-iteration-101
  - arrays-l2-utilities-and-misc
  - arrays-l3-dynamic-array-internals
outcomes:
  - Perform common **in-place** transforms safely (reverse, rotate, partition)
  - Apply **two-pointer** patterns (fast/slow, head/tail) to avoid extra space
  - Reason about mutation hazards and when a copy is clearer
  - Implement remove-element/condense-array patterns that return a new logical length
  - "Compare in-place rotations: three-reversal method vs `copyWithin` trade-offs"
tags: ["arrays","two-pointers","in-place","reverse","rotate","partition","performance"]
est_minutes: 45
checks:
  - type: quiz
    id: arrays-l3-inplace-quiz
  - type: unit
    entry: reverseInPlace.ts
    tests: reverseInPlace.test.ts
  - type: unit
    entry: removeTargetInPlace.ts
    tests: removeTargetInPlace.test.ts
  - type: unit
    entry: dedupeSortedInPlace.ts
    tests: dedupeSortedInPlace.test.ts
  - type: unit
    entry: rotateByKInPlace.ts
    tests: rotateByKInPlace.test.ts
  - type: unit
    entry: partitionByPredicate.ts
    tests: partitionByPredicate.test.ts
---

## Why this matters

In hot paths and memory-sensitive code, avoiding extra allocations **matters**. The two-pointer family gives you O(n) time with O(1) extra space for many everyday tasks: reversing, removing, deduping, rotating, and partitioning.

---

## Mental model

- **Head/Tail pointers** (`l`, `r`): operate from both ends when you need symmetry (reverse, palindrome checks, partition around a pivot).
- **Fast/Slow pointers** (`write`, `read`): keep a **write index** that trails a **read index** to “condense” an array in place (remove items, dedupe a sorted list).
- **Three-reversal rotation**: rotate right by `k` by reversing three segments, all O(n) in place.

> In-place ≠ free: you mutate input. Prefer immutable approaches for clarity unless you specifically need in-place.

---

## Techniques

### 1) Reverse in place (head/tail)
```ts
export function reverseInPlace<T>(a: T[]): void {
  for (let l = 0, r = a.length - 1; l < r; l++, r--) {
    [a[l], a[r]] = [a[r], a[l]]; // swap
  }
}
````

* **Time:** O(n), **Space:** O(1)

### 2) Remove target values (fast/slow)

Return the **new logical length** after removing all `target`s; elements `[0..len-1]` form the kept slice.

```ts
export function removeTargetInPlace<T>(a: T[], target: T): number {
  let write = 0;
  for (let read = 0; read < a.length; read++) {
    if (a[read] !== target) a[write++] = a[read];
  }
  // (optional) clear trailing garbage
  for (let i = write; i < a.length; i++) (a as any)[i] = undefined;
  return write;
}
```

* **Time:** O(n), **Space:** O(1)

### 3) Dedupe a **sorted** array (fast/slow)

Keep one of each value; return new length.

```ts
export function dedupeSortedInPlace<T>(a: T[]): number {
  if (a.length === 0) return 0;
  let write = 1;
  for (let read = 1; read < a.length; read++) {
    if (a[read] !== a[write - 1]) a[write++] = a[read];
  }
  return write;
}
```

### 4) Rotate right by `k` — three reversals (head/tail)

To rotate right by `k`:

1. reverse whole array, 2) reverse first `k`, 3) reverse rest.

```ts
function reverseRange<T>(a: T[], i: number, j: number): void {
  while (i < j) ([a[i], a[j]] = [a[j], a[i]]), i++, j--;
}

export function rotateByKInPlace<T>(a: T[], k: number): void {
  const n = a.length;
  if (n === 0) return;
  k = ((k % n) + n) % n; // normalize
  if (k === 0) return;
  reverseRange(a, 0, n - 1);
  reverseRange(a, 0, k - 1);
  reverseRange(a, k, n - 1);
}
```

### 5) Partition by predicate (head/tail or fast/slow)

Stable partition in place is tricky; the simple version is **unstable** but O(n):

```ts
// Move elements matching pred to the front; return split index
export function partitionByPredicate<T>(a: T[], pred: (x: T) => boolean): number {
  let write = 0;
  for (let read = 0; read < a.length; read++) {
    if (pred(a[read]!)) {
      [a[write], a[read]] = [a[read], a[write]]; // swap (unstable)
      write++;
    }
  }
  return write; // a[0..write-1] passed, a[write..] failed
}
```

* **Unstable:** relative order within each side may change. Stable partition usually needs extra space or more complex algorithms.

---

## Common pitfalls

* **Index drift**: if you splice while iterating forward, you skip elements; prefer two-pointers or iterate **backwards** when mutating length.
* **Equality**: for dedupe/remove, decide between `===` vs a comparator; the L3 versions here assume strict equality and, for dedupe, a **sorted** array.
* **Rotate corner cases**: `k=0`, `k` negative, `k ≥ n` — always normalize `k`.
* **Stability**: swap-based partition is **not stable**; if order matters, use an auxiliary buffer or do a stable two-pass copy.

---

## Walkthrough: “condense log lines” (fast/slow)

Goal: remove empty strings and trim consecutive duplicates in place; return new logical length.

Sketch:

```ts
function condenseLogs(lines: string[]): number {
  let write = 0, prev: string | undefined;
  for (let read = 0; read < lines.length; read++) {
    const cur = lines[read];
    if (cur === "" || cur === prev) continue;
    lines[write++] = cur;
    prev = cur;
  }
  return write;
}
```

---

## Exercises

### 1) `reverseInPlace(a)` — complete & test

**Starter — `reverseInPlace.ts`**

```ts
export function reverseInPlace<T>(a: T[]): void {
  // Implement head/tail swap loop; no return
}
```

**Tests**: even/odd length, single-element, empty, reference equality (same array object mutated).

---

### 2) `removeTargetInPlace(a, target)` — return new length

**Starter — `removeTargetInPlace.ts`**

```ts
export function removeTargetInPlace<T>(a: T[], target: T): number {
  // Use fast/slow; clear trailing slots (optional)
  return 0;
}
```

**Edge cases**: target missing, all target, consecutive runs.

---

### 3) `dedupeSortedInPlace(a)` — sorted input required

**Starter — `dedupeSortedInPlace.ts`**

```ts
export function dedupeSortedInPlace<T>(a: T[]): number {
  // Keep first occurrence of each value; return new logical length
  return 0;
}
```

**Note**: behavior is undefined for unsorted input (document this).

---

### 4) `rotateByKInPlace(a, k)` — three-reversal method

**Starter — `rotateByKInPlace.ts`**

```ts
export function rotateByKInPlace<T>(a: T[], k: number): void {
  // Normalize k; perform three reversals
}
```

**Compare**: against your earlier `copyWithin` variant from L2 Utilities.

---

### 5) `partitionByPredicate(a, pred)` — return split index

**Starter — `partitionByPredicate.ts`**

```ts
export function partitionByPredicate<T>(
  a: T[],
  pred: (x: T) => boolean
): number {
  // Unstable partition with swaps; return index where false region starts
  return 0;
}
```

**Examples**

* odds first, evens second
* truthy first, falsy second

---

## Quiz (checks)

1. Two-pointer **fast/slow** is best suited for:
   A) Reverse in place
   B) Remove elements while keeping order ✅
   C) Binary search
   D) Heapify

2. The three-reversal rotation does how many element swaps in total (big-O)?
   A) O(log n)
   B) O(n) ✅
   C) O(n log n)
   D) O(1)

3. The simple partition shown is:
   A) Stable and O(1) space
   B) Stable but O(n) space
   C) **Unstable** and O(1) space ✅
   D) Unstable and O(n) space

4. In `dedupeSortedInPlace`, correctness relies on:
   A) Using `===` vs `==`
   B) The array being **sorted** ✅
   C) Clearing tail slots
   D) Using `Set`

5. When splicing repeatedly while scanning left→right, you risk:
   A) Extra copies
   B) **Skipping elements due to index drift** ✅
   C) Breaking referential equality
   D) Overflowing the call stack

---

## Takeaways

* Two-pointers give O(n) / O(1) solutions for many array edits; know **head/tail** vs **fast/slow**.
* In-place rotation via **three reversals** is clean and allocation-free.
* Beware stability requirements; simple in-place partition is **unstable**.
* Mutation is powerful but dangerous—use it when it’s the right trade-off.

---

## What’s next

Continue to **Arrays L3 — Immutability Patterns & Costs** to contrast these in-place techniques with copy-by-change approaches and learn when immutability is clearer or even faster.