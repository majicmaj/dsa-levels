---
id: arrays-l3-stable-sorting-and-keys
title: "Stable Sorting & Custom Keys"
topic: arrays
level: 3
lesson: 3.4
prereqs:
  - arrays-l2-sort-and-compare
  - arrays-l1-copying-and-slicing-basics
outcomes:
  - Explain *stability* and enforce it with the **DSU** pattern (decorate → sort → undecorate)
  - Write robust key-based comparators (numbers, strings, dates, booleans) with null/undefined handling
  - Compose multi-key ordering (primary, secondary, …) with `orderBy`
  - Choose `sort` vs `toSorted` and reason about performance & clarity
  - Use `Intl.Collator` for human-friendly string ordering (case-insensitive, numeric)
tags: ["arrays","sort","stability","comparator","DSU","orderBy","collator"]
est_minutes: 45
checks:
  - type: quiz
    id: arrays-l3-stable-sort-quiz
  - type: unit
    entry: stableSortBy.ts
    tests: stableSortBy.test.ts
  - type: unit
    entry: compareKeys.ts
    tests: compareKeys.test.ts
  - type: unit
    entry: orderBy.ts
    tests: orderBy.test.ts
crosslinks:
  - { to: arrays-l2-sort-and-compare, why: "Prerequisite comparator fundamentals and mutation vs immutability" }
  - { to: strings-l1-basic-search-compare, why: "Locale-aware string compare and sorting nuances" }
  - { to: objects-l4-entries-pairs-and-fromentries, why: "Sort object entries stably before rebuilding objects" }
---

## Why this matters

When lists get real (tables, leaderboards, search results), you need **predictable** sorting:
- Equal keys keep their original order (**stable**).
- Multi-key (e.g., *region asc, score desc, name asc*).
- Mixed data (numbers, strings, `null`/`undefined`) without crashes or weird edges.

This lesson makes stability explicit and gives you reusable, typed helpers.

---

## Stability recap & DSU

Modern JS engines implement **stable** sort, but we’ll learn to enforce it when needed and to build reusable utilities.

**DSU: Decorate → Sort → Undecorate**

1) **Decorate:** pair each element with `{ key, index, value }`  
2) **Sort:** by `key` (custom comparator), then by `index` as a *tie-breaker*  
3) **Undecorate:** map back to `value`

Why? If your environment or constraints make stability uncertain, DSU guarantees it.

---

## Key comparator building blocks

We’ll build three small utilities:

1) **`compareKeys`** — compare two primitive-ish keys (number|string|boolean|Date|`null`/`undefined`) with optional `Intl.Collator` and `nullsFirst/Last`.
2) **`stableSortBy`** — DSU sort by a single key, ascending/descending.
3) **`orderBy`** — compose multiple key specs (primary, secondary, …) *stably*.

---

## Nulls & type nuances

- Decide where `null`/`undefined` go: often **last** for ascending, **first** for descending — or make it explicit via an option.
- Dates: compare with `getTime()`.
- Booleans: convert to `0/1` (e.g., `false < true` when ascending).
- Strings: for human-friendly order, use `Intl.Collator` (case-insensitive, numeric segments).

```ts
const coll = new Intl.Collator(undefined, { sensitivity: "base", numeric: true });
coll.compare("File2", "file10"); // -1 (2 < 10; case-insensitive)
````

---

## Implementations (starters)

### 1) `compareKeys` — robust key comparison

**Starter — `compareKeys.ts`**

```ts
export type Nulls = "first" | "last";

export function compareKeys(
  a: unknown,
  b: unknown,
  opts?: { collator?: Intl.Collator; nulls?: Nulls }
): number {
  const nulls = opts?.nulls ?? "last";
  const an = a == null; // null or undefined
  const bn = b == null;

  if (an || bn) {
    if (an && bn) return 0;
    return (an ? -1 : 1) * (nulls === "first" ? 1 : -1);
  }

  // Dates → compare timestamps
  if (a instanceof Date && b instanceof Date) {
    return a.getTime() - b.getTime();
  }

  // Numbers
  if (typeof a === "number" && typeof b === "number") {
    // Handle NaN consistently: place NaN after numbers in ascending
    const aNaN = Number.isNaN(a), bNaN = Number.isNaN(b);
    if (aNaN || bNaN) return aNaN === bNaN ? 0 : (aNaN ? 1 : -1);
    return a - b;
  }

  // Booleans
  if (typeof a === "boolean" && typeof b === "boolean") {
    return (a === b) ? 0 : (a ? 1 : -1);
  }

  // Strings (or fallback via string coercion)
  if (typeof a === "string" && typeof b === "string") {
    if (opts?.collator) return opts.collator.compare(a, b);
    return a < b ? -1 : (a > b ? 1 : 0);
  }

  // Fallback: compare their string forms
  const sa = String(a), sb = String(b);
  return sa < sb ? -1 : (sa > sb ? 1 : 0);
}
```

---

### 2) `stableSortBy` — single-key DSU sort (asc/desc)

**Starter — `stableSortBy.ts`**

```ts
import { compareKeys, Nulls } from "./compareKeys";

export function stableSortBy<T>(
  arr: T[],
  key: (x: T) => unknown,
  opts?: {
    order?: "asc" | "desc";
    collator?: Intl.Collator;
    nulls?: Nulls;
  }
): T[] {
  const order = opts?.order ?? "asc";
  const collator = opts?.collator;
  const nulls = opts?.nulls;

  const decorated = arr.map((v, i) => ({ v, i, k: key(v) }));
  const cmp = (A: typeof decorated[number], B: typeof decorated[number]) => {
    let c = compareKeys(A.k, B.k, { collator, nulls });
    if (order === "desc") c = -c;
    return c || (A.i - B.i); // stability via original index
  };

  // prefer toSorted (immutable) if available
  const sorted = (decorated as any).toSorted ? decorated.toSorted(cmp) : decorated.slice().sort(cmp);
  return sorted.map(x => x.v);
}
```

---

### 3) `orderBy` — multi-key composition (stable)

**Starter — `orderBy.ts`**

```ts
import { compareKeys, Nulls } from "./compareKeys";

export type KeySpec<T> = {
  key: (x: T) => unknown;
  order?: "asc" | "desc";
  collator?: Intl.Collator;
  nulls?: Nulls;
};

export function orderBy<T>(arr: T[], specs: KeySpec<T>[]): T[] {
  if (specs.length === 0) return arr.slice();

  const decorated = arr.map((v, i) => ({ v, i, ks: specs.map(s => s.key(v)) }));

  const cmp = (A: typeof decorated[number], B: typeof decorated[number]) => {
    for (let s = 0; s < specs.length; s++) {
      const spec = specs[s];
      const order = spec.order ?? "asc";
      let c = compareKeys(A.ks[s], B.ks[s], { collator: spec.collator, nulls: spec.nulls });
      if (order === "desc") c = -c;
      if (c !== 0) return c;
    }
    return A.i - B.i; // stability
  };

  const sorted = (decorated as any).toSorted ? decorated.toSorted(cmp) : decorated.slice().sort(cmp);
  return sorted.map(x => x.v);
}
```

**Example**

```ts
type Row = { region: string; score: number; name: string | null };
const coll = new Intl.Collator(undefined, { sensitivity: "base", numeric: true });

orderBy(rows, [
  { key: r => r.region, collator: coll },     // asc, human-friendly
  { key: r => r.score, order: "desc" },       // desc numbers
  { key: r => r.name, collator: coll, nulls: "last" } // tie-breaker
]);
```

---

## Common pitfalls

* **Boolean comparators** (`a > b`) — illegal; must return negative/zero/positive **number**.
* **Mixed types** in a single column — normalize first or rely on `compareKeys` fallback.
* `localeCompare` *inside heavy sorts* can be slow; re-use a single `Intl.Collator`.
* Forgetting **stability** when generating tie-breakers (add index or a secondary key).

---

## Walkthrough: stable “natural” sort with null-safe name

**Goal:** Sort users by `name` (case/diacritics-insensitive, numeric segments), nulls last; tie-break by `id` ascending.

```ts
const coll = new Intl.Collator(undefined, { sensitivity: "base", numeric: true });

const usersSorted = orderBy(users, [
  { key: u => u.name, collator: coll, nulls: "last" },
  { key: u => u.id, order: "asc" }
]);
```

---

## Exercises

### 1) Implement `stableSortBy` (DSU)

Complete and test `stableSortBy` (above starter). **Tests cover**

* Stability: equal keys keep original order
* Asc/desc behavior
* Nulls-first/last and number/string/date keys
* Collator usage

---

### 2) Implement `compareKeys`

Finish edge-cases in `compareKeys`:

* `NaN` vs numbers (place `NaN` last in ascending, first in descending via caller)
* `boolean` ordering
* Fallback string coercion

---

### 3) Implement `orderBy`

Support any number of key specs, each with `order`, `collator`, and `nulls`. Must be **stable**.

---

## Quiz (checks)

1. Stability means:
   A) Sort is always O(n log n)
   B) Equal keys keep **original relative order** ✅
   C) Comparators always return 0
   D) `sort` never mutates

2. DSU stands for:
   A) **Decorate–Sort–Undecorate** ✅
   B) Distribute–Select–Unify
   C) Divide–Sort–Unite
   D) Decorate–Serialize–Unpack

3. For human-friendly strings (“file2” < “file10”), use:
   A) `(a,b)=>a-b`
   B) `a.localeCompare(b)`
   C) `new Intl.Collator(undefined, { numeric: true }).compare(a, b)` ✅
   D) Default `sort()`

4. To enforce stability when keys are equal, the tie-breaker should be:
   A) Random number
   B) Original **index** ✅
   C) Reverse index
   D) Hash of the object

5. With `nulls: "last"` and ascending order, comparing `null` vs `"A"` yields:
   A) `-1`
   B) `0`
   C) `1` ✅
   D) Throws

---

## Takeaways

* Stability is not optional in real UIs—**guarantee** it with DSU.
* Centralize tricky comparison logic in `compareKeys`; re-use `Intl.Collator`.
* Build **single-key** and **multi-key** helpers once; reuse everywhere.
* Prefer `toSorted` for immutability and clarity; measure if mutating `sort` matters.

---

## What’s next

Step into **Arrays L4 — Dedupe with Set** to integrate Arrays with Sets/Maps for fast uniqueness and frequency patterns.