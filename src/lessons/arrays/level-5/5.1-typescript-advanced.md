---
id: arrays-l5-typescript-advanced
title: "TypeScript Advanced (readonly, tuples, generics)"
topic: arrays
level: 5
lesson: 5.1
prereqs:
  - arrays-l2-sort-and-compare
  - arrays-l3-immutability-patterns-and-costs
  - arrays-l2-utilities-and-misc
outcomes:
  - Use `readonly T[]` and `ReadonlyArray<T>` to accept immutable inputs; understand *shallow* vs deep readonly
  - Model fixed-shape data with **tuples**, **variadic tuples**, and `as const`
  - Write ergonomic, strongly-typed array utilities (`zip`, `chunk`, `pluck`) with generics and key constraints
  - Type functions that accept **readonly arrays** but return **mutable copies** (e.g., `toSorted`-style)
  - Employ helpers like `satisfies`, `at`, conditional & infer tricks for “last element” and tuple concat
tags: ["arrays","typescript","readonly","tuples","generics","variadic-tuples","inference"]
est_minutes: 50
checks:
  - type: quiz
    id: arrays-l5-ts-advanced-quiz
  - type: unit
    entry: zip.ts
    tests: zip.test.ts
  - type: unit
    entry: chunk.ts
    tests: chunk.test.ts
  - type: unit
    entry: pluck.ts
    tests: pluck.test.ts
  - type: unit
    entry: last.ts
    tests: last.test.ts
  - type: unit
    entry: tupleConcat.ts
    tests: tupleConcat.test.ts
  - type: typecheck
    entry: readonly-accepts.ts
    tests: readonly-accepts.test.ts
---

## Why this matters

TypeScript can make array code **safer and clearer**: accept readonly inputs without copying, model fixed shapes with **tuples**, and write utilities that keep types precise (think `pluck` returning `T[K][]` instead of `any[]`). Mastering these patterns pays off across your codebase.

---

## Mental model

- **`readonly T[]` / `ReadonlyArray<T>`**: callers promise they won’t mutate; the *type* prevents writes. This is **shallow**: inner objects are still mutable unless you type them readonly too.
- **Tuples**: arrays with fixed length & element types, e.g. `[string, number]`. Use `as const` to *freeze* a literal into a readonly tuple.
- **Variadic tuples**: compose tuples at the type level, e.g. `type Push<A extends unknown[], T> = [...A, T]`.
- **Accept readonly, return fresh**: many pure helpers should accept `readonly T[]` but return a mutable `T[]` (like `toSorted` does).
- **Keyed generics**: constrain with `K extends keyof T` so `pluck` can only request valid keys.

---

## Readonly arrays (shallow)

```ts
function sum(xs: readonly number[]): number {
  // xs.push(1) // ❌ compile error
  let s = 0; for (const x of xs) s += x; return s;
}
````

* `readonly number[]` and `ReadonlyArray<number>` are equivalent.
* **Shallow** only: `readonly {id:number}[]` prevents adding/removing/replacing items, but not `arr[0].id = 42`. For deep, use a mapped type like:

  ```ts
  type DeepReadonly<T> = T extends Function ? T
    : T extends Array<infer U> ? ReadonlyArray<DeepReadonly<U>>
    : T extends object ? { readonly [K in keyof T]: DeepReadonly<T[K]> }
    : T;
  ```

---

## Accept readonly, return a copy (toSorted-style)

```ts
function numericSorted(xs: readonly number[]): number[] {
  // safe to accept readonly; we make a copy
  return xs.slice().sort((a, b) => a - b);
}
```

This signature composes beautifully with callers who keep their state immutable.

---

## Tuples & `as const`

```ts
const point = [10, 20] as const;       // readonly [10, 20]
type Point = typeof point;             // readonly [10, 20]
type X = typeof point[0];              // 10 (literal type)

const row = ["id", 3] as const;        // readonly ["id", 3]
```

Tuple-precise APIs let you keep labels alongside data without losing type info.

---

## Variadic tuples (compose lists at type level)

```ts
type Concat<A extends readonly unknown[], B extends readonly unknown[]> = [...A, ...B];

function tupleConcat<A extends readonly unknown[], B extends readonly unknown[]>(
  a: A, b: B
): Concat<A, B> {
  return [...a, ...b] as Concat<A, B>;
}
```

---

## Helpful typing tricks

* **`satisfies`** keeps literal precision while checking a target shape:

  ```ts
  const columns = [
    { key: "id", label: "ID" },
    { key: "name", label: "Name" }
  ] as const satisfies ReadonlyArray<{ key: "id" | "name"; label: string }>;
  ```
* **“last element”** with conditional types:

  ```ts
  type Last<A extends readonly unknown[]> =
    A extends readonly [...infer _, infer L] ? L : undefined;
  ```
* **`at`** is typed as `T | undefined`; your wrapper can refine using tuples (exercise below).

---

## Common pitfalls

* Treating `readonly` as deep: it’s **not**. It only guards the array **structure**.
* Accidentally widening literals: `const xs = [1,2,3]` is `number[]`, but `as const` yields `readonly [1,2,3]`.
* Over-constraining generics: `pluck<T, K extends string>` loses safety. Use `K extends keyof T`.
* Forgetting that accepting `T[]` **rejects** `readonly T[]`; prefer `readonly T[]` in inputs.

---

## Walkthrough: designing ergonomic signatures

**Goal:** `zip(a, b)` should accept readonly inputs and return a mutable array of pairs with preserved element types.

Signature:

```ts
export function zip<A, B>(
  a: readonly A[],
  b: readonly B[]
): Array<[A, B]> { /* ... */ }
```

* Inputs are **readonly** to maximize compatibility.
* Output is **mutable** (common expectation), but feel free to return `ReadonlyArray<[A,B]>` if your API is pure-immutable.

---

## Exercises

### 1) `zip(a, b)` — pairwise zip up to the shorter length

**Starter — `zip.ts`**

```ts
export function zip<A, B>(a: readonly A[], b: readonly B[]): Array<[A, B]> {
  const n = Math.min(a.length, b.length);
  const out: Array<[A, B]> = [];
  for (let i = 0; i < n; i++) out.push([a[i], b[i]]);
  return out;
}
```

---

### 2) `chunk(xs, size)` — split into blocks (immutable)

**Starter — `chunk.ts`**

```ts
export function chunk<T>(xs: readonly T[], size: number): T[][] {
  if (size <= 0) return [];
  const out: T[][] = [];
  for (let i = 0; i < xs.length; i += size) {
    out.push(xs.slice(i, i + size) as T[]);
  }
  return out;
}
```

---

### 3) `pluck(items, key)` — typed key extraction

**Starter — `pluck.ts`**

```ts
export function pluck<T, K extends keyof T>(items: readonly T[], key: K): Array<T[K]> {
  const out: Array<T[K]> = [];
  for (const item of items) out.push(item[key]);
  return out;
}
```

---

### 4) `last(arr)` — tuple-aware last element

**Starter — `last.ts`**

```ts
export type Last<A extends readonly unknown[]> =
  A extends readonly [...infer _, infer L] ? L : undefined;

export function last<A extends readonly unknown[]>(arr: A): Last<A> {
  return (arr.length ? (arr as readonly unknown[])[arr.length - 1] : undefined) as Last<A>;
}
```

---

### 5) `tupleConcat(a, b)` — variadic tuple concat

**Starter — `tupleConcat.ts`**

```ts
export type Concat<A extends readonly unknown[], B extends readonly unknown[]> = [...A, ...B];

export function tupleConcat<A extends readonly unknown[], B extends readonly unknown[]>(
  a: A, b: B
): Concat<A, B> {
  return [...a, ...b] as Concat<A, B>;
}
```

---

### (Type-only) Accept readonly inputs

Ensure these compile:
**`readonly-accepts.ts`**

```ts
import { zip, chunk, pluck } from "./";

const roNums: readonly number[] = [1,2,3] as const;
const roStrs: ReadonlyArray<string> = ["a","b","c"];

zip(roNums, roStrs);
chunk(roNums, 2);

type User = { id: number; name: string };
const users = [{ id: 1, name: "A" }, { id: 2, name: "B" }] as const;
pluck(users, "name"); // type is readonly ["A","B"]? No—returns Array<"A"|"B"> (acceptable widening)
```

---

## Quiz (checks)

1. Which parameter type accepts both mutable and readonly arrays?
   A) `T[]`
   B) `ReadonlyArray<T>` / `readonly T[]` ✅
   C) `ArrayLike<T>`
   D) `Iterable<T>`

2. `as const` on `[1,2,3]` yields the type:
   A) `number[]`
   B) `readonly number[]`
   C) `readonly [1,2,3]` ✅
   D) `[1,2,3]`

3. In `pluck<T, K extends keyof T>(items: T[], key: K)`, the return type is:
   A) `any[]`
   B) `T[]`
   C) `Array<T[K]>` ✅
   D) `unknown[]`

4. `readonly T[]` enforces:
   A) Deep immutability of nested objects
   B) **Shallow** immutability of the array structure only ✅
   C) Nothing at runtime
   D) That `T` is `readonly`

5. A good signature for a pure helper that sorts without mutating input is:
   A) `(xs: T[]): T[]`
   B) `(xs: readonly T[]): T[]` ✅
   C) `(xs: ReadonlyArray<T>): ReadonlyArray<T>` only
   D) `(xs: T[] & ReadonlyArray<T>): T[]`

---

## Takeaways

* Prefer **`readonly T[]`** for inputs; return fresh arrays for pure helpers.
* Use **tuples** (and `as const`) to keep literal precision; reach for **variadic tuples** when composing.
* Constrain generics with **`keyof`** and preserve precise element types in results.
* Remember: `readonly` is **shallow**—pair it with deeper types if needed.

---

## What’s next

Jump to **Arrays L5 — Performance Benchmarks** to compare chained vs fused passes, `for` vs `map/reduce`, and copy-by-change vs in-place, and to build a tiny benchmark harness.