---
id: objects-l3-descriptors-and-defineproperty
title: "Property Descriptors & defineProperty"
topic: objects
level: 3
lesson: 3.1
prereqs:
  - objects-l2-assign-spread-rest-shallow-copy
  - objects-l2-deep-copy-structured-clone
outcomes:
  - Inspect property **descriptors** with `Object.getOwnPropertyDescriptor(s)`
  - Create and edit properties with `Object.defineProperty(ies)` (data vs accessor)
  - Control **writable / enumerable / configurable** flags correctly
  - "Understand **what changes are allowed** once `configurable: false`"
  - Preserve getters/setters & enumerability when **cloning with descriptors**
  - Use `Object.create(null)` + `defineProperties` to build **prototype-free tables**
tags: ["objects","descriptors","defineProperty","getters","setters","configurable","enumerable","writable"]
est_minutes: 40
checks:
  - type: quiz
    id: objects-l3-descriptors-quiz
  - type: unit
    entry: makeReadonly.ts
    tests: makeReadonly.test.ts
  - type: unit
    entry: hideMeta.ts
    tests: hideMeta.test.ts
  - type: unit
    entry: cloneWithDescriptors.ts
    tests: cloneWithDescriptors.test.ts
  - type: unit
    entry: safeDefineDict.ts
    tests: safeDefineDict.test.ts
  - type: unit
    entry: flipWritable.ts
    tests: flipWritable.test.ts
---

## Why this matters

Most code treats object properties as simple key→value pairs. Under the hood, each property has a **descriptor** that controls:
- whether you can **write** to it (`writable`)
- whether it shows up in **enumeration** (`enumerable`)
- whether you can **reconfigure/delete** it (`configurable`)
- or even whether it’s backed by **get/set accessors** instead of a stored value

Knowing this lets you make **readonly IDs**, hide **internal metadata**, and **preserve** getters/setters when copying.

---

## Data vs accessor properties

- **Data property**: `{ value, writable, enumerable, configurable }`
- **Accessor property**: `{ get, set, enumerable, configurable }` (no `value` or `writable`)

Inspect with:

```ts
Object.getOwnPropertyDescriptor(obj, "k");           // single
Object.getOwnPropertyDescriptors(obj);               // all own props
````

Define with:

```ts
Object.defineProperty(obj, "k", {
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false
});

Object.defineProperties(obj, {
  total: {
    get() { return this.items.reduce((s: number, x: number) => s + x, 0); },
    enumerable: true,
    configurable: true
  }
});
```

> **Default trap:** Omitted flags in `defineProperty` default to `false` (and `value: undefined`). If you want normal “mutable field” semantics, you must set `writable: true, enumerable: true, configurable: true`.

Properties created by **assignment** (`obj.x = 1`) or **object literal** are, by default, **writable: true, enumerable: true, configurable: true**.

---

## Configurability rules (what you can/can’t change)

If a property is **`configurable: false`**:

* You **cannot** change `enumerable`, `configurable`, or switch **kind** (data ↔ accessor).
* For **data properties**:

  * You **may** change `writable: true → false`.
  * You **may not** change `writable: false → true`.
  * You may change `value` **only if** `writable: true` (or to the same value in some engines).
* For **accessor properties**: `get`/`set` cannot be changed.

Deleting such a property will **fail** (`delete obj.k` returns `false` in non-strict; throws in strict).

---

## Hiding vs showing up in iteration

* `enumerable: false` → hidden from `Object.keys/values/entries` and `for…in`.
* Still visible via `Object.getOwnPropertyNames`/`Reflect.ownKeys`.

Great for attaching internal metadata that shouldn’t leak into spreads/JSON.

```ts
Object.defineProperty(obj, "meta", { value: {...}, enumerable: false });
```

---

## Preserving accessors & flags when cloning

Spread/`assign` **invoke getters** and copy **values** as **data properties** (losing accessors & non-enumerables).

To preserve descriptors:

```ts
function cloneWithDescriptors<T extends object>(src: T): T {
  const proto = Object.getPrototypeOf(src);
  return Object.create(proto, Object.getOwnPropertyDescriptors(src));
}
```

---

## Prototype-free tables

Create a bare dictionary with **no prototype** so `__proto__` etc. are just normal keys:

```ts
const dict = Object.create(null);
Object.defineProperties(dict, {
  count: { value: 0, writable: true, enumerable: true, configurable: true }
});
```

This avoids prototype pollution and makes membership checks simpler.

---

## Common pitfalls

* Using `defineProperty` but forgetting flags → property becomes **non-writable, non-enumerable, non-configurable** by default.
* Expecting to “unlock” a **non-configurable** property—you can’t.
* Copying an object with accessors via spread and wondering why the **getter disappeared**.
* Marking **IDs** readonly with `writable: false` but leaving `configurable: true`, allowing later redefinition; lock it down with `configurable: false`.

---

## Walkthroughs

### 1) Readonly, non-configurable ID

```ts
function attachId<T extends object>(o: T, id: string) {
  return Object.defineProperty(o, "id", {
    value: id,
    writable: false,
    enumerable: true,
    configurable: false
  });
}
```

### 2) Non-enumerable metadata (symbol or string)

```ts
const META = Symbol("meta");
function hideMeta<T extends object>(o: T, meta: unknown) {
  return Object.defineProperty(o, META, { value: meta, enumerable: false });
}
```

---

## Exercises

### 1) `makeReadonly(obj, key)` — lock a data property

Set `key` on `obj` to be **writable: false** and **configurable: false** while keeping it **enumerable**.

**Starter — `makeReadonly.ts`**

```ts
export function makeReadonly<T extends object, K extends PropertyKey>(obj: T, key: K): T {
  const d = Object.getOwnPropertyDescriptor(obj, key);
  const value = d?.value;
  Object.defineProperty(obj, key, {
    value,
    writable: false,
    enumerable: true,
    configurable: false
  });
  return obj;
}
```

---

### 2) `hideMeta(obj, key, value)` — non-enumerable attach

Attach `value` at `key` (string or symbol) as **non-enumerable** so it won’t appear in `Object.keys`.

**Starter — `hideMeta.ts`**

```ts
export function hideMeta<T extends object>(obj: T, key: PropertyKey, value: unknown): T {
  Object.defineProperty(obj, key, { value, enumerable: false, configurable: true, writable: true });
  return obj;
}
```

---

### 3) `cloneWithDescriptors(src)` — preserve flags and accessors

Return a clone with the **same prototype** and **all own descriptors** preserved.

**Starter — `cloneWithDescriptors.ts`**

```ts
export function cloneWithDescriptors<T extends object>(src: T): T {
  return Object.create(Object.getPrototypeOf(src), Object.getOwnPropertyDescriptors(src));
}
```

---

### 4) `safeDefineDict(entries)` — prototype-free table

Create a `Record<string, unknown>`-like object with **no prototype** and **enumerable** data properties from `entries`.

**Starter — `safeDefineDict.ts`**

```ts
export function safeDefineDict(entries: Array<[string, unknown]>) {
  const dict = Object.create(null);
  for (const [k, v] of entries) {
    Object.defineProperty(dict, k, {
      value: v, writable: true, enumerable: true, configurable: true
    });
  }
  return dict as Record<string, unknown>;
}
```

---

### 5) `flipWritable(obj, key)` — allowed transitions

If `obj[key]` is a **configurable data property**, toggle `writable` (true↔false).
If it’s **non-configurable**, allow **true → false** but **not** false → true (throw a clear error).

**Starter — `flipWritable.ts`**

```ts
export function flipWritable(obj: object, key: PropertyKey) {
  const d = Object.getOwnPropertyDescriptor(obj, key);
  if (!d || "get" in d) throw new Error("Requires data property");
  const { configurable, writable = false } = d;
  if (!configurable && !writable) throw new Error("Cannot make writable when configurable:false");
  Object.defineProperty(obj, key, { ...d, writable: !writable });
  return !writable;
}
```

---

## Quiz (checks)

1. In `Object.defineProperty`, omitted flags default to:
   A) `true`
   B) **`false`** ✅
   C) `undefined`
   D) Engine-dependent

2. A **non-configurable** data property allows which change?
   A) Toggle enumerable
   B) Convert to accessor
   C) **Change `writable: true → false`** ✅
   D) Delete the property

3. Which copy **preserves** getters/setters and enumerability?
   A) `{ ...src }`
   B) `Object.assign({}, src)`
   C) **`Object.create(proto, Object.getOwnPropertyDescriptors(src))`** ✅
   D) `JSON.parse(JSON.stringify(src))`

4. `enumerable: false` means:
   A) Property can’t be read
   B) **It won’t appear in `Object.keys/entries` or `for…in`** ✅
   C) It’s read-only
   D) It can’t be deleted

5. Creating a property via **assignment** (`obj.x = 1`) sets which flags by default?
   A) `writable:false, enumerable:false, configurable:false`
   B) **`writable:true, enumerable:true, configurable:true`** ✅
   C) All false except writable
   D) Non-enumerable but configurable

---

## Takeaways

* Think in **descriptors**: data vs accessor; control `writable`, `enumerable`, `configurable`.
* `defineProperty` defaults are **strict** (all false); specify what you need.
* Once `configurable:false`, your options are limited—plan ahead for API boundaries.
* To **preserve** accessors & flags, clone with **descriptors**, not spread.

---

## What’s next

Proceed to **Objects L3 — Getters, Setters & Side Effects** to design safe accessors, avoid surprise costs during enumeration/copying, and build lazy, cached properties thoughtfully.

