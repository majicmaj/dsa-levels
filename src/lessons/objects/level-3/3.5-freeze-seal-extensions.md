---
id: objects-l3-freeze-seal-extensions
title: "Freeze, Seal & Prevent Extensions"
topic: objects
level: 3
lesson: 3.5
prereqs:
  - objects-l3-descriptors-and-defineproperty
  - objects-l3-prototype-chain-and-own-vs-inherited
outcomes:
  - Choose correctly among **`Object.freeze`**, **`Object.seal`**, and **`Object.preventExtensions`**
  - Predict what reads/writes/deletes do on **non-extensible**, **sealed**, and **frozen** objects (strict vs non-strict)
  - Use **shallow vs deep freeze** patterns; understand what they do *not* protect
  - Implement **defensive copies** and **immutable update** helpers (structural sharing)
  - Check mutability status with `Object.isExtensible/isSealed/isFrozen`
tags: ["objects","freeze","seal","preventExtensions","immutability","defensive-copy","structural-sharing"]
est_minutes: 40
checks:
  - type: quiz
    id: objects-l3-freeze-seal-quiz
  - type: unit
    entry: freezeShallow.ts
    tests: freezeShallow.test.ts
  - type: unit
    entry: deepFreeze.ts
    tests: deepFreeze.test.ts
  - type: unit
    entry: isDeepFrozen.ts
    tests: isDeepFrozen.test.ts
  - type: unit
    entry: sealWithDefaults.ts
    tests: sealWithDefaults.test.ts
  - type: unit
    entry: updateImmutable.ts
    tests: updateImmutable.test.ts
---

## Why this matters

Immutability reduces bugs and simplifies reasoning (especially in React reducers and caching). JavaScript gives you **object-level guards**—but they’re **shallow** and interact with descriptors in nuanced ways. Mastering freeze/seal/extensibility helps you write safer, intention-revealing APIs.

---

## Quick reference

| State | Add props | Delete props | Change values | Change descriptors | Notes |
|---|---|---|---|---|---|
| **Extensible** (default) | ✅ | ✅ (if configurable) | ✅ (if writable) | ✅ (if configurable) | Normal objects |
| **Non-extensible** (`preventExtensions`) | ❌ | ✅ (if configurable) | ✅ (if writable) | ✅ (if configurable) | No new own props |
| **Sealed** (`seal`) | ❌ | ❌ | ✅ (if writable) | ❌ | All own props become **configurable:false** |
| **Frozen** (`freeze`) | ❌ | ❌ | ❌ (writable set to false) | ❌ | All own **data** props become read-only; accessors keep get/set functions but property is non-configurable |

> All three are **shallow**: they affect the object’s **own** properties, not nested objects.

### Strict mode behavior
- In **non-strict** code, illegal writes/deletes **fail silently** (`false`/no-op).
- In **strict** code, they **throw** (`TypeError`). Library code should not rely on throw—prefer defensive checks.

---

## Status checks

```ts
Object.isExtensible(obj); // boolean
Object.isSealed(obj);     // boolean
Object.isFrozen(obj);     // boolean
````

These inspect only the **current object**, not nested values.

---

## Freeze vs accessors

* `freeze` makes **data** properties non-writable + non-configurable.
* **Accessor** properties (`get/set`) become **non-configurable**; if a `set` exists, you can still *call it*. Freezing does **not** delete setters. To lock down accessors, redefine to remove `set` before freezing or design data-only surfaces.

---

## Patterns

### Shallow freeze for public surfaces

```ts
export function exposeReadOnly<T extends object>(value: T): Readonly<T> {
  return Object.freeze({ ...value }); // copy, then freeze the copy
}
```

* Freezes just the top level; nested objects remain mutable unless separately frozen.

### Deep freeze (plain objects & arrays)

```ts
export function deepFreeze<T>(x: T): T {
  if (x && typeof x === "object" && !Object.isFrozen(x)) {
    Object.freeze(x);
    for (const k of Reflect.ownKeys(x as object)) {
      const v = (x as any)[k];
      if (v && typeof v === "object") deepFreeze(v);
    }
  }
  return x;
}
```

* Treat carefully around Maps/Sets/typed arrays; decide policy explicitly.

### Sealed configs (shape-locked, values editable)

```ts
export function sealWithDefaults<T extends object>(defaults: T, user: Partial<T>): Readonly<T> {
  const merged = { ...defaults, ...user } as T;
  return Object.seal(merged);
}
```

* Callers can change values but can’t add/remove keys.

### Immutable updates (structural sharing)

```ts
export function updateImmutable<T extends object>(
  base: T,
  patch: Partial<T>
): Readonly<T> {
  const next = { ...base, ...patch } as T;
  return Object.freeze(next);
}
```

* Return **new** shallow copy; leave `base` as-is. Consider deep strategies per use case.

---

## Common pitfalls

* Assuming `freeze` is deep—**it isn’t**. Children remain mutable.
* Freezing objects with **setters** and expecting writes to throw in non-strict code—they won’t.
* Using `Object.assign` to “copy a frozen object into a fresh one” and thinking it stays frozen—**the result is not frozen** unless you freeze it again.
* Relying on sealed objects for validation—sealing prevents **shape** changes, not **value** sanity.

---

## Walkthrough: defensive API boundary

```ts
// Library boundary: accept untrusted config, normalize, then seal/freeze
type Cfg = { host: string; port: number; flags: { compact: boolean } };

export function makeConfig(user: Partial<Cfg>): Readonly<Cfg> {
  const defaults: Cfg = { host: "localhost", port: 3000, flags: { compact: false } };
  const cfg = { ...defaults, ...user, flags: { ...defaults.flags, ...user.flags } };
  return Object.freeze(cfg); // shallow freeze; nested flags would still be mutable unless frozen
}
```

If you want **deep** immutability at the boundary, run `deepFreeze(cfg)` instead.

---

## Exercises

### 1) `freezeShallow(obj)` — copy & freeze (top-level)

Return a **new** object that is a shallow clone of `obj` and **frozen**.

**Starter — `freezeShallow.ts`**

```ts
export function freezeShallow<T extends object>(obj: T): Readonly<T> {
  const copy = { ...obj } as T;
  return Object.freeze(copy);
}
```

---

### 2) `deepFreeze(x)` — plain objects & arrays only

Deep-freeze **objects and arrays** (ignore Map/Set/Date/TypedArray for MVP). Avoid re-freezing already-frozen nodes.

**Starter — `deepFreeze.ts`**

```ts
export function deepFreeze<T>(x: T): T {
  if (x && typeof x === "object" && !Object.isFrozen(x)) {
    Object.freeze(x);
    for (const k of Reflect.ownKeys(x as object)) {
      const v = (x as any)[k];
      if (v && typeof v === "object") deepFreeze(v);
    }
  }
  return x;
}
```

---

### 3) `isDeepFrozen(x)` — verify recursively

Return `true` if `x` and all nested **plain objects/arrays** are frozen.

**Starter — `isDeepFrozen.ts`**

```ts
export function isDeepFrozen(x: unknown): boolean {
  if (!(x && typeof x === "object")) return true;
  if (!Object.isFrozen(x)) return false;
  for (const k of Reflect.ownKeys(x as object)) {
    const v = (x as any)[k];
    if (!isDeepFrozen(v)) return false;
  }
  return true;
}
```

---

### 4) `sealWithDefaults(defaults, user)` — merge then seal

Merge `defaults` with `user` (user wins), **seal** the result, and return it.

**Starter — `sealWithDefaults.ts`**

```ts
export function sealWithDefaults<T extends object>(defaults: T, user: Partial<T>): Readonly<T> {
  const merged = { ...defaults, ...user } as T;
  return Object.seal(merged);
}
```

---

### 5) `updateImmutable(base, patch)` — frozen structural sharing

Return a **new frozen** object with `patch` applied; do not mutate `base`.

**Starter — `updateImmutable.ts`**

```ts
export function updateImmutable<T extends object>(base: T, patch: Partial<T>): Readonly<T> {
  const next = { ...base, ...patch } as T;
  return Object.freeze(next);
}
```

---

## Quiz (checks)

1. `Object.preventExtensions(obj)` guarantees:
   A) No deletes
   B) No writes
   C) **No new own properties** ✅
   D) Everything is read-only

2. `Object.seal(obj)` makes all own properties:
   A) Non-writable and non-configurable
   B) **Non-configurable (values may still be writable)** ✅
   C) Non-enumerable
   D) Accessors only

3. `Object.freeze(obj)` on a property with an accessor `set` will:
   A) Remove the setter
   B) Throw immediately
   C) **Make the property non-configurable; the setter still exists** ✅
   D) Convert it to a data property

4. Which statement about **freeze** is true?
   A) It’s deep and affects nested objects
   B) **It’s shallow; nested objects must be frozen separately** ✅
   C) It prevents `Object.setPrototypeOf`
   D) It prevents method calls

5. In **strict mode**, assigning to a frozen data property:
   A) Silently fails
   B) **Throws a `TypeError`** ✅
   C) Converts it to an accessor
   D) Deletes the property

---

## Takeaways

* **preventExtensions** → no new props. **seal** → lock shape (no add/remove), values may change. **freeze** → lock shape **and** values (shallow).
* These are **shallow**; use **deep freeze** carefully and intentionally.
* For API boundaries, prefer **defensive copies** + (deep) freeze; for updates, return **new frozen** objects (structural sharing).
* Accessors keep their behavior; freezing makes the property **non-configurable**, not functionless.

---

## What’s next

Level 4 kicks off with **Objects L4 — Entries ↔ FromEntries (Transformations)** to move fluently between objects and arrays, invert/group shapes, and build JSON-safe serializers.