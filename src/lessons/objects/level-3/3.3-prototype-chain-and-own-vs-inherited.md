---
id: objects-l3-prototype-chain-and-own-vs-inherited
title: "Prototype Chain & Own vs Inherited"
topic: objects
level: 3
lesson: 3.3
prereqs:
  - objects-l3-descriptors-and-defineproperty
  - objects-l3-getters-setters-and-effects
  - objects-l2-keys-values-entries-hasown
outcomes:
  - Trace property **lookup** along the prototype chain and predict results for read/write/delete
  - Distinguish **own** vs **inherited** properties; know where `"in"` and `Object.hasOwn` differ
  - Explain **shadowing** (own props hide prototype props) and how **delete** reveals prototypes
  - Create objects with a chosen prototype (`Object.create`, `class`/`extends`) and know the cost of `Object.setPrototypeOf`
  - Understand method calls and **`this` = receiver**, plus how prototype **setters** intercept writes
  - Iterate safely without pulling in prototype keys; avoid **prototype pollution**
tags: ["objects","prototype","own","inherited","shadowing","this","setPrototypeOf","Object.create","for-in"]
est_minutes: 40
checks:
  - type: quiz
    id: objects-l3-prototype-quiz
  - type: unit
    entry: getDescriptorDeep.ts
    tests: getDescriptorDeep.test.ts
  - type: unit
    entry: hasOwnOrProto.ts
    tests: hasOwnOrProto.test.ts
  - type: unit
    entry: shadowAndReveal.ts
    tests: shadowAndReveal.test.ts
  - type: unit
    entry: makeWithProto.ts
    tests: makeWithProto.test.ts
  - type: unit
    entry: forEachOwn.ts
    tests: forEachOwn.test.ts
---

## Why this matters

JS objects **delegate** to their prototypes. Reads climb the chain; writes may create **own** props or call **prototype setters**. Enumeration can accidentally include **inherited** keys. Once you can *trace the algorithm*, you’ll debug oddities like “why did my write call a setter?” or “why did my loop pick up `toString`?” in seconds.

---

## The prototype chain — mental model

Every object has an internal `[[Prototype]]` (often shown as `__proto__`) that points to another object or `null`. Property **read** does:

1) Check **own** properties.  
2) If missing, walk `[[Prototype]]` to the next object.  
3) Stop at `null` (not found).

```ts
const base = { kind: "base" };
const child = Object.create(base);
child.kind; // "base" (inherited)
````

### Shadowing

An **own** property with the same name **hides** a prototype property.

```ts
child.kind = "child"; // creates own data property (shadowing)
child.kind; // "child"
delete child.kind;
child.kind; // "base" (revealed)
```

---

## Reads vs writes vs delete

### Read (`obj.k`)

* Returns the first `k` found along the chain (own → proto → …).

### Write (`obj.k = v`)

* If `obj` has an **own data property** `k` and it’s writable → **set value**.
* Else, if there is an **accessor with `set`** somewhere on the chain → **call the setter on `obj`** (the **receiver**).
* Else → **create a new own data property** `k` on `obj` (writable, enumerable, configurable).

```ts
const base2 = {
  set x(v) { this._x = v * 2; } // accessor setter on prototype
};
const c2 = Object.create(base2);
c2.x = 3;          // calls prototype setter; creates c2._x = 6
```

### Delete (`delete obj.k`)

* Removes **own** property (if configurable).
* Prototype is **never** touched; after delete, a prototype property may become visible.

---

## Own vs inherited membership

* `"k" in obj` → **true** if found **anywhere** (own or prototype).
* `Object.hasOwn(obj, "k")` → **true** only for **own**.
* `for…in` iterates **enumerable string** keys across **own + prototype chain**.

Prefer `Object.keys/values/entries` for own enumerable string keys; filter `for…in` with `Object.hasOwn`.

---

## Creating & changing prototypes

### Create with a prototype (recommended)

```ts
const base = { greet() { return `hi ${this.name}`; } };
const o = Object.create(base, {
  name: { value: "Amina", writable: true, enumerable: true, configurable: true }
});
o.greet(); // "hi Amina"
```

### Classes are sugar over prototypes

```ts
class Box { constructor(public n: number) {} get double() { return this.n * 2; } }
Object.getPrototypeOf(new Box(1)) === Box.prototype; // true
```

### Changing prototype post-hoc (avoid in hot paths)

`Object.setPrototypeOf(obj, proto)` mutates `[[Prototype]]`. It’s **slow** and may deopt engines; prefer constructing with the right prototype up front (`Object.create`, `class`).

---

## `this` is the **receiver** at call site

```ts
const m = {
  x: 1,
  getX() { return this.x; }
};
const o1 = Object.create(m); o1.x = 10;
m.getX();   // 1   (receiver m)
o1.getX();  // 10  (receiver o1)
const f = m.getX;
f();        // undefined or global depending on mode; bind if needed
```

Arrow functions **do not** have their own `this` (they capture lexical `this`): not ideal for prototype methods.

---

## Enumeration safety

* **Own-only**: `Object.keys/values/entries`, or `for…in` + `Object.hasOwn`.
* **All own (strings+symbols)**: `Reflect.ownKeys`.
* Avoid treating plain objects as maps with user input unless you use **`Object.create(null)`** to prevent prototype surprises.

---

## Prototype pollution (why `create(null)` matters)

Writing into `Object.prototype` adds inherited keys to **every** object:

```ts
(Object.prototype as any).hacked = true;
const a = {};
"hacked" in a; // true (inherited!)
Object.hasOwn(a, "hacked"); // false
```

For dictionary-like tables, use **`Object.create(null)`** so there’s **no prototype** to pollute.

---

## Common pitfalls

* Assuming `for…in` lists only own keys — it walks the **chain**.
* Forgetting prototype **setters** can intercept writes.
* Using `Object.setPrototypeOf` in hot code; construct with the right prototype instead.
* Shadowing a method with a data property accidentally: `obj.toString = 1`.
* Expecting delete to remove inherited props — it cannot.

---

## Walkthroughs

### Find where a property lives (and its descriptor)

```ts
export function getDescriptorDeep(obj: object, key: PropertyKey) {
  let cur: any = obj;
  while (cur) {
    const d = Object.getOwnPropertyDescriptor(cur, key);
    if (d) return { owner: cur, descriptor: d };
    cur = Object.getPrototypeOf(cur);
  }
  return null;
}
```

### Safe own-only iteration with `for…in`

```ts
export function forEachOwn(obj: object, fn: (k: string, v: unknown) => void) {
  for (const k in obj) {
    if (Object.hasOwn(obj, k)) fn(k, (obj as any)[k]);
  }
}
```

---

## Exercises

### 1) `getDescriptorDeep(obj, key)` — locate a property on the chain

Return `{ owner, descriptor }` for the first occurrence of `key` going up the prototype chain, or `null` if not found.

**Starter — `getDescriptorDeep.ts`**

```ts
export function getDescriptorDeep(obj: object, key: PropertyKey):
  null | { owner: object; descriptor: PropertyDescriptor } {
  let cur: any = obj;
  while (cur) {
    const d = Object.getOwnPropertyDescriptor(cur, key);
    if (d) return { owner: cur, descriptor: d };
    cur = Object.getPrototypeOf(cur);
  }
  return null;
}
```

---

### 2) `hasOwnOrProto(obj, key)` — classify membership

Return `"own"` if own, `"proto"` if found on the chain, or `"none"`.

**Starter — `hasOwnOrProto.ts`**

```ts
export function hasOwnOrProto(obj: object, key: PropertyKey): "own" | "proto" | "none" {
  if (Object.hasOwn(obj, key)) return "own";
  return (key in obj) ? "proto" : "none";
}
```

---

### 3) `shadowAndReveal(obj, key)` — demonstrate shadowing

* If `key` exists on the prototype (not own), **shadow** it by creating an own data property with the current value.
* Then provide a function `reveal()` that deletes the own property to reveal the prototype again.

**Starter — `shadowAndReveal.ts`**

```ts
export function shadowAndReveal<T extends object>(obj: T, key: PropertyKey) {
  if (!Object.hasOwn(obj, key) && (key in obj)) {
    (obj as any)[key] = (obj as any)[key]; // create own data property with same value
  }
  function reveal() { delete (obj as any)[key]; }
  return { obj, reveal };
}
```

---

### 4) `makeWithProto(proto, props)` — construct with a prototype

Create a new object with `proto` as its prototype and define **enumerable, writable, configurable** data properties from `props`’s own keys.

**Starter — `makeWithProto.ts`**

```ts
export function makeWithProto<P extends object, T extends Record<string | symbol, unknown>>(
  proto: P,
  props: T
): P & T {
  const out = Object.create(proto);
  for (const k of Reflect.ownKeys(props)) {
    const v = (props as any)[k];
    Object.defineProperty(out, k, { value: v, enumerable: true, writable: true, configurable: true });
  }
  return out as P & T;
}
```

---

### 5) `forEachOwn(obj, fn)` — iterate own enumerable only

Implement a utility that calls `fn(key, value)` for **own enumerable string** keys only (use `for…in` + `Object.hasOwn` or `Object.keys`).

**Starter — `forEachOwn.ts`**

```ts
export function forEachOwn(obj: object, fn: (k: string, v: unknown) => void) {
  for (const k in obj) {
    if (Object.hasOwn(obj, k)) fn(k, (obj as any)[k]);
  }
}
```

---

## Quiz (checks)

1. `"k" in obj` returns `true` when:
   A) Only if own
   B) Only if on prototype
   C) **If own OR on the prototype chain** ✅
   D) Neither

2. Writing `obj.k = v` will call a **setter on the prototype** when:
   A) There’s an own data property `k`
   B) **A prototype has an accessor with `set` for `k` and no own property exists** ✅
   C) The prototype has a data property `k`
   D) Never; writes don’t consult prototypes

3. Deleting a property can “reveal” a prototype property with the same name because:
   A) Delete cascades up the chain
   B) **The own property is removed; lookup then finds the prototype’s property** ✅
   C) Delete copies from prototype
   D) Only in strict mode

4. Creating objects with a chosen prototype is best done with:
   A) `Object.setPrototypeOf` on an existing object
   B) **`Object.create(proto, descriptors)` or `class` construction** ✅
   C) Editing `__proto__` directly (always)
   D) JSON round-trips

5. To iterate **own** enumerable string keys safely you can use:
   A) `for…in` without checks
   B) **`Object.keys(obj)` or `for…in` + `Object.hasOwn(obj, k)`** ✅
   C) `Reflect.ownKeys` and assume strings only
   D) `Object.getOwnPropertyNames` and hope order matches

---

## Takeaways

* Reads go **own → prototype → …**; writes create **own** data props unless a **prototype setter** intercepts.
* **Shadowing** hides prototype props; **delete** reveals them without touching the prototype.
* Prefer constructing with the correct prototype (`Object.create`, `class`); avoid `setPrototypeOf` in hot paths.
* Use **own-only** enumeration patterns and consider **`Object.create(null)`** for dictionaries to avoid prototype surprises.

---

## What’s next

Finish L3 with **Objects L3 — Minimal Dictionary & Frozen/Sealed Objects**, where you’ll build a prototype-free dictionary (`Object.create(null)`), compare it to `Map`, and learn `freeze`, `seal`, and `preventExtensions`.
