---
id: objects-l3-minimal-dictionary-object-table
title: "Minimal Dictionary (prototype-free tables)"
topic: objects
level: 3
lesson: 3.4
prereqs:
  - objects-l2-keys-values-entries-hasown
  - objects-l2-assign-spread-rest-shallow-copy
  - objects-l3-prototype-chain-and-own-vs-inherited
outcomes:
  - Build **prototype-free** dictionaries with `Object.create(null)` to avoid prototype pollution
  - "Implement a tiny **dict API**: `get/set/has/delete/size/keys/entries` using safe primitives"
  - Know how `Object.hasOwn` keeps membership checks safe on null-prototype objects
  - "Compare **null-proto dict** vs **Map**: when to use which (string keys, JSON-ability, order, size)"
  - Serialize & merge dictionaries **immutably** without reintroducing prototypes
tags: ["objects","dictionary","Object.create(null)","prototype-pollution","hasOwn","map","serialize"]
est_minutes: 40
checks:
  - type: quiz
    id: objects-l3-minimal-dict-quiz
  - type: unit
    entry: makeDict.ts
    tests: makeDict.test.ts
  - type: unit
    entry: dictOps.ts
    tests: dictOps.test.ts
  - type: unit
    entry: mergeDict.ts
    tests: mergeDict.test.ts
  - type: unit
    entry: serializeDict.ts
    tests: serializeDict.test.ts
  - type: unit
    entry: fromPairsNullProto.ts
    tests: fromPairsNullProto.test.ts
crosslinks:
  - { to: objects-l4-entries-pairs-and-fromentries, why: "Convert dicts <-> pairs and sort/filter entries" }
---

## Why this matters

Plain `{}` objects inherit from `Object.prototype`. That’s usually fine—until user-supplied keys collide with prototype names or your iteration accidentally walks inherited props. A **prototype-free** table from `Object.create(null)` gives you a clean, safe key→value dictionary for string keys.

---

## Minimal dictionary: mental model

- Use **`Object.create(null)`** to make an object with **no prototype**.
- Store **string keys → values** (numbers get coerced to strings, like any object).
- Use **`Object.hasOwn(dict, k)`** for membership (safe even without a prototype).
- Iterate with `Object.keys/values/entries`—they still work (on own enumerable string keys).

```ts
const dict = Object.create(null) as Record<string, unknown>;
dict["alice"] = 1;
Object.hasOwn(dict, "toString"); // false (no prototype)
"toString" in dict;              // false (no proto chain)
````

---

## Dict vs Map (quick guide)

| Need                                                        | Null-proto dict              | `Map`            |
| ----------------------------------------------------------- | ---------------------------- | ---------------- |
| Keys are **strings only** and you want easy JSON            | ✅                            | —                |
| Keys may be **non-strings** (objects, numbers w/o coercion) | —                            | ✅                |
| Need **insertion order** and easy size                      | —                            | ✅ (`.size`)      |
| You care about **prototype pollution resistance**           | ✅                            | ✅ (not affected) |
| Very frequent add/remove + large tables                     | ⚠️ fine but Map often faster | ✅ often better   |

> Rule of thumb: **string-only, JSON-y** → dict. **General purpose, ordered, non-string keys** → Map.

---

## Building a tiny dict API

We’ll keep the storage as a null-proto object and expose a few helpers.

```ts
export type Dict<V = unknown> = Record<string, V> & { __proto__?: never };

export function makeDict<V = unknown>(init?: Array<[string, V]>): Dict<V> {
  const d = Object.create(null) as Dict<V>;
  if (init) for (const [k, v] of init) d[k] = v;
  return d;
}

export const dictOps = {
  has<V>(d: Dict<V>, k: string): boolean {
    return Object.hasOwn(d, k);
  },
  get<V>(d: Dict<V>, k: string): V | undefined {
    return (d as any)[k];
  },
  set<V>(d: Dict<V>, k: string, v: V): Dict<V> {
    (d as any)[k] = v; return d;
  },
  del<V>(d: Dict<V>, k: string): boolean {
    if (!Object.hasOwn(d, k)) return false;
    return delete (d as any)[k];
  },
  size<V>(d: Dict<V>): number {
    return Object.keys(d).length;
  },
  keys<V>(d: Dict<V>): string[] {
    return Object.keys(d);
  },
  entries<V>(d: Dict<V>): Array<[string, V]> {
    return Object.entries(d) as Array<[string, V]>;
  },
} as const;
```

---

## Immutable merges without prototypes

When you rebuild a new dict, make sure the **result** also has **no prototype**.

```ts
export function mergeDict<V>(
  a: Dict<V>, b: Dict<V>
): Dict<V> {
  const out = Object.create(null) as Dict<V>;
  // copy a then b (b wins)
  for (const [k, v] of Object.entries(a)) (out as any)[k] = v;
  for (const [k, v] of Object.entries(b)) (out as any)[k] = v;
  return out;
}
```

Avoid `Object.assign({}, a, b)` because `{}` reintroduces a prototype.

---

## Serialize safely

`JSON.stringify` works as usual; `undefined` values are omitted for object props (standard JSON behavior).

```ts
export function serializeDict<V>(d: Dict<V>, space?: number): string {
  return JSON.stringify(d, null, space);
}
```

Round-trip:

```ts
export function fromPairsNullProto<V>(pairs: Array<[string, V]>): Dict<V> {
  const d = Object.create(null) as Dict<V>;
  for (const [k, v] of pairs) (d as any)[k] = v;
  return d;
}
```

---

## Common pitfalls

* **Accidentally using `{}`** in clones/merges—brings back a prototype. Always `Object.create(null)` for new dicts.
* Calling `d.hasOwnProperty` on a null-proto dict—**it doesn’t exist**. Use `Object.hasOwn(d, k)`.
* Expecting natural **insertion order** guarantees like `Map`—object enumeration rules apply (integer-like keys first).
* Mixing **non-string keys**: coerced to strings. If you need object keys, use a `Map`.

---

## Walkthrough: word frequency using dict

```ts
function wordFreq(text: string): Dict<number> {
  const d = makeDict<number>();
  for (const w of text.toLowerCase().match(/\p{L}+/gu) ?? []) {
    (d[w] ??= 0), d[w]++;  // `??=` keeps 0
  }
  return d;
}
```

---

## Exercises

### 1) `makeDict(init?)` — create a null-proto dict

Return a dict seeded from optional `[key, value][]`. Ensure the result has **no prototype**.

**Starter — `makeDict.ts`**

```ts
export type Dict<V = unknown> = Record<string, V> & { __proto__?: never };

export function makeDict<V = unknown>(init?: Array<[string, V]>): Dict<V> {
  const d = Object.create(null) as Dict<V>;
  if (init) for (const [k, v] of init) (d as any)[k] = v;
  return d;
}
```

---

### 2) `dictOps` — basic operations

Implement `has/get/set/del/size/keys/entries` as shown above, using only safe primitives (no prototype methods).

**Starter — `dictOps.ts`**

```ts
import type { Dict } from "./makeDict";

export const dictOps = {
  has<V>(d: Dict<V>, k: string): boolean { return Object.hasOwn(d, k); },
  get<V>(d: Dict<V>, k: string): V | undefined { return (d as any)[k]; },
  set<V>(d: Dict<V>, k: string, v: V): Dict<V> { (d as any)[k] = v; return d; },
  del<V>(d: Dict<V>, k: string): boolean {
    if (!Object.hasOwn(d, k)) return false;
    return delete (d as any)[k];
  },
  size<V>(d: Dict<V>): number { return Object.keys(d).length; },
  keys<V>(d: Dict<V>): string[] { return Object.keys(d); },
  entries<V>(d: Dict<V>): Array<[string, V]> { return Object.entries(d) as Array<[string, V]>; },
} as const;
```

---

### 3) `mergeDict(a, b)` — b wins immutably

Return a **new** null-proto dict with keys from `a` and `b` (values from `b` overwrite).

**Starter — `mergeDict.ts`**

```ts
import type { Dict } from "./makeDict";

export function mergeDict<V>(a: Dict<V>, b: Dict<V>): Dict<V> {
  const out = Object.create(null) as Dict<V>;
  for (const [k, v] of Object.entries(a)) (out as any)[k] = v;
  for (const [k, v] of Object.entries(b)) (out as any)[k] = v;
  return out;
}
```

---

### 4) `serializeDict(d)` — JSON stringify

Return pretty JSON if `space` provided. Tests verify that `__proto__` is serialized as a **normal key** if present.

**Starter — `serializeDict.ts`**

```ts
import type { Dict } from "./makeDict";

export function serializeDict<V>(d: Dict<V>, space?: number): string {
  return JSON.stringify(d, null, space);
}
```

---

### 5) `fromPairsNullProto(pairs)` — safe rebuild

Build a null-proto dict from pairs; ensure no prototype is introduced.

**Starter — `fromPairsNullProto.ts`**

```ts
import type { Dict } from "./makeDict";

export function fromPairsNullProto<V>(pairs: Array<[string, V]>): Dict<V> {
  const d = Object.create(null) as Dict<V>;
  for (const [k, v] of pairs) (d as any)[k] = v;
  return d;
}
```

---

## Quiz (checks)

1. The safest way to check membership on a **null-proto** dict is:
   A) `dict.hasOwnProperty(k)`
   B) `k in dict`
   C) **`Object.hasOwn(dict, k)`** ✅
   D) `Reflect.has(dict, k)`

2. Why is `Object.create(null)` used for dictionaries?
   A) It’s faster in all cases
   B) **It removes the prototype to avoid inherited keys/pollution** ✅
   C) It preserves insertion order
   D) It enables symbol keys

3. Which operation would accidentally **reintroduce a prototype**?
   A) `Object.create(null)`
   B) **`Object.assign({}, dict)`** ✅
   C) `JSON.stringify(dict)`
   D) `Object.keys(dict)`

4. For non-string keys and guaranteed insertion order, choose:
   A) Null-proto dict
   B) **`Map`** ✅
   C) Array of pairs only
   D) `Object.fromEntries`

5. Which statement about numeric keys in a null-proto dict is true?
   A) They’re stored as numbers
   B) **They’re coerced to strings (like any object)** ✅
   C) They’re rejected
   D) They’re sorted automatically

---

## Takeaways

* **Null-prototype** dictionaries are great for safe, JSON-friendly **string-keyed** tables.
* Use **`Object.hasOwn`** and `Object.keys/entries`—they work fine without a prototype.
* Avoid `{}` when cloning/merging dicts; always create new containers with **`Object.create(null)`**.
* Reach for **Map** when keys aren’t strings or when you need insertion order and `.size`.

---

## What’s next

Wrap up Level 3 with **Objects L3 — Freeze, Seal & Prevent Extensions**, where you’ll control object mutability (`freeze`, `seal`, `preventExtensions`), learn what each guarantees, and how to design clear, immutable APIs.
