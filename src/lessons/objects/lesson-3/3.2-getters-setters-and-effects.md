---
id: objects-l3-getters-setters-and-effects
title: "Getters, Setters & Side Effects"
topic: objects
level: 3
lesson: 3.2
prereqs:
  - objects-l3-descriptors-and-defineproperty
  - objects-l2-assign-spread-rest-shallow-copy
outcomes:
  - Define **accessor properties** (get/set) and know when to use them vs methods/fields
  - Avoid surprise **side effects** during enumeration, copying, and JSON serialization
  - Implement **lazy/cached** getters and **invalidatable** computed properties
  - Understand `this` binding, prototype accessors, and how accessors interact with **descriptors**
  - Recognize performance and debuggability trade-offs; design **explicit** APIs
tags: ["objects","getters","setters","accessor","defineProperty","json","enumeration","performance","lazy"]
est_minutes: 40
checks:
  - type: quiz
    id: objects-l3-getters-setters-quiz
  - type: unit
    entry: makeLazy.ts
    tests: makeLazy.test.ts
  - type: unit
    entry: cachedProp.ts
    tests: cachedProp.test.ts
  - type: unit
    entry: invalidateCache.ts
    tests: invalidateCache.test.ts
  - type: unit
    entry: listAccessorProps.ts
    tests: listAccessorProps.test.ts
  - type: unit
    entry: safeJsonWithAccessors.ts
    tests: safeJsonWithAccessors.test.ts
---

## Why this matters

Accessors (`get`/`set`) look like fields but run **code**. That’s powerful (derivations, validation, lazy init) but also risky: they can trigger unexpectedly during **spread/assign**, `JSON.stringify`, or iteration. Mastering accessors means choosing them intentionally, avoiding surprise work, and keeping APIs clear.

---

## Accessor properties: the shape

A property is either **data** or **accessor** (never both):

```ts
// Accessor via literal
const user = {
  first: "Amina",
  last: "Khan",
  get full() { return `${this.first} ${this.last}`; },
  set full(v: string) {
    const [first, ...rest] = v.split(" ");
    this.first = first; this.last = rest.join(" ");
  }
};

// Accessor via defineProperty
Object.defineProperty(user, "initials", {
  get() { return this.first[0] + this.last[0]; },
  enumerable: true,
  configurable: true
});
````

Descriptor:

```ts
// Accessor: { get?: Function, set?: Function, enumerable: boolean, configurable: boolean }
```

> No `value`/`writable` on accessors.

---

## When to use (and when not)

**Good fits**

* **Derived fields**: cheap, deterministic computation from other fields.
* **Validation/normalization** on set (e.g., trimming email, clamping ranges).
* **Lazy init**: compute once on first access, then cache.

**Prefer methods/fields**

* Non-trivial work (I/O, heavy computation) → use a **method** (`.computeTotal()`).
* Anything with **side effects** that would surprise readers during iteration/serialization.
* Code that can **throw** in normal paths → prefer explicit call sites.

---

## Side effects & gotchas

* **Spread/assign** and `Object.entries/values` **read** accessor values if **enumerable** → the **getter runs**.
* `JSON.stringify` enumerates own **enumerable string** keys and **reads** each → getters run; if a getter **throws**, stringify throws.
* Accessors are *not* copied as accessors by spread/assign; the **value** is copied (data property). To preserve accessors, clone with **descriptors** (see previous lesson).

---

## Patterns

### 1) Lazy (compute once → convert to data property)

```ts
export function makeLazy<T extends object, K extends PropertyKey>(
  obj: T,
  key: K,
  compute: () => unknown
): T {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: true,
    get() {
      const v = compute();
      // Replace accessor with a data property
      Object.defineProperty(this, key, {
        value: v, writable: false, enumerable: true, configurable: true
      });
      return v;
    }
  });
  return obj;
}
```

* First read computes and memoizes; later reads are cheap.
* Optional: make `writable: true` if you want manual overrides.

### 2) Cached derived property with **invalidate()**

```ts
export function cachedProp<T extends object, K extends PropertyKey>(
  obj: T,
  key: K,
  compute: () => unknown
) {
  let cacheSet = false;
  let cache: unknown;
  Object.defineProperty(obj, key, {
    enumerable: true, configurable: true,
    get() { if (!cacheSet) { cache = compute(); cacheSet = true; } return cache; }
  });
  Object.defineProperty(obj, Symbol.for(`invalidate:${String(key)}`), {
    value() { cacheSet = false; cache = undefined; },
    enumerable: false
  });
  return obj as T & Record<K, unknown>;
}
```

### 3) Safe JSON with accessors (avoid accidental work)

Provide an explicit `toJSON()` that returns **data only**:

```ts
const model = {
  data: [1,2,3],
  get heavy() { /* expensive */ return this.data.reduce((a,b)=>a+b,0) },
  toJSON() { return { data: this.data }; } // omit heavy
};
JSON.stringify(model); // uses toJSON result
```

---

## Accessors on the prototype

Defining accessors on prototypes/classes is common:

```ts
class Rect {
  #w = 0; #h = 0;
  constructor(w: number, h: number) { this.#w = w; this.#h = h; }
  get area() { return this.#w * this.#h; }          // lives on prototype
  set width(v: number) { this.#w = Math.max(0, v); }
}
```

* `this` is the **receiver** (the instance).
* Be careful with `this` if you **extract** getters/setters; they require a receiver.

---

## Converting between accessor/data

* You can **redefine** an accessor into a data property (e.g., for caching).
* If the property is `configurable: false`, you **cannot** change kind (accessor↔data).

---

## Performance notes

* Getters are **function calls**; trivial ones are fine, but don’t hide **heavy** work.
* Lazy caching eliminates repeated work but adds complexity (invalidations).
* Profilers blame the getter name; keep them simple to debug.

---

## Common pitfalls

* Making accessors **enumerable** when they do heavy work → they’ll run during copies/JSON.
* Using setters for **validation** that silently mutate — prefer throwing or explicit methods for clarity.
* Forgetting that **spread/assign** collapse accessors into **data**.
* Relying on `writable` on accessors (doesn’t exist) — you control mutability via `set` presence.

---

## Walkthrough: “stats” with cached sum and invalidation

```ts
type Stats = { values: number[] };
function attachStats(s: Stats) {
  cachedProp(s as any, "sum", () => s.values.reduce((a,b)=>a+b,0));
  (s as any).invalidateSum = (s as any)[Symbol.for("invalidate:sum")];
  return s as Stats & { sum: number; invalidateSum(): void };
}

const s = attachStats({ values: [1,2,3] });
s.sum;            // 6 (compute)
s.sum;            // 6 (cached)
s.values.push(10);
s.sum;            // still 6
s.invalidateSum();
s.sum;            // 16 (recompute)
```

---

## Exercises

### 1) `makeLazy(obj, key, compute)` — compute-once accessor

Create a getter that computes once and then turns into a **data property** with that value.

**Starter — `makeLazy.ts`**

```ts
export function makeLazy<T extends object, K extends PropertyKey>(
  obj: T, key: K, compute: () => unknown
): T {
  Object.defineProperty(obj, key, {
    configurable: true, enumerable: true,
    get() {
      const v = compute();
      Object.defineProperty(this, key, {
        value: v, writable: false, enumerable: true, configurable: true
      });
      return v;
    }
  });
  return obj;
}
```

---

### 2) `cachedProp(obj, key, compute)` — memoized getter

Implement a getter that caches its result **without** redefining the property; provide a hidden invalidation symbol.

**Starter — `cachedProp.ts`**

```ts
export function cachedProp<T extends object, K extends PropertyKey>(
  obj: T, key: K, compute: () => unknown
): T {
  let has = false; let val: unknown;
  Object.defineProperty(obj, key, {
    enumerable: true, configurable: true,
    get() { if (!has) { val = compute(); has = true; } return val; }
  });
  Object.defineProperty(obj, Symbol.for(`invalidate:${String(key)}`), {
    value() { has = false; val = undefined; }, enumerable: false
  });
  return obj;
}
```

---

### 3) `invalidateCache(obj, key)` — helper to call the invalidator

Call the symbol-based invalidation function created by `cachedProp`.

**Starter — `invalidateCache.ts`**

```ts
export function invalidateCache(obj: object, key: PropertyKey) {
  const sym = Symbol.for(`invalidate:${String(key)}`);
  const fn = (obj as any)[sym];
  if (typeof fn === "function") fn();
}
```

---

### 4) `listAccessorProps(obj)` — audit accessors

Return a list of own keys that are **accessor properties** with `{ key, enumerable, configurable, hasGetter, hasSetter }`.

**Starter — `listAccessorProps.ts`**

```ts
export type AccessorInfo = {
  key: string | symbol;
  enumerable: boolean;
  configurable: boolean;
  hasGetter: boolean;
  hasSetter: boolean;
};

export function listAccessorProps(obj: object): AccessorInfo[] {
  const out: AccessorInfo[] = [];
  const descs = Object.getOwnPropertyDescriptors(obj);
  for (const k of Reflect.ownKeys(descs)) {
    const d = (descs as any)[k];
    if ("get" in d || "set" in d) {
      out.push({
        key: k,
        enumerable: !!d.enumerable,
        configurable: !!d.configurable,
        hasGetter: typeof d.get === "function",
        hasSetter: typeof d.set === "function",
      });
    }
  }
  return out;
}
```

---

### 5) `safeJsonWithAccessors(x)` — stringify without running heavy getters

Return JSON that **omits accessor properties** (string keys) to avoid running getters. Symbols are omitted by JSON anyway.

**Starter — `safeJsonWithAccessors.ts`**

```ts
export function safeJsonWithAccessors(x: unknown): string {
  const seen = new WeakSet<object>();
  function replacer(this: any, key: string, value: any) {
    if (key === "") return value; // root
    if (value && typeof value === "object") {
      if (seen.has(value)) return undefined;
      seen.add(value);
    }
    // Omit accessor props on the holder object
    const holder = this as object;
    const d = Object.getOwnPropertyDescriptor(holder, key);
    if (d && ("get" in d || "set" in d)) return undefined;
    return value;
  }
  return JSON.stringify(x, replacer);
}
```

---

## Quiz (checks)

1. Which statements about accessors are true? *(choose all)*

* They have `get`/`set` instead of `value`/`writable`. ✅
* They can be both data and accessor at once. ❌
* `enumerable: true` means they’ll run during spread/entries/JSON. ✅
* `writable` controls whether a getter may run. ❌

2. After spreading `{ get x(){ return 1 } }`, the resulting property `x` on the target is:
   A) An accessor getter again
   B) **A data property with value `1`** ✅
   C) Non-enumerable
   D) Missing

3. `JSON.stringify(obj)` will call getters when:
   A) Never
   B) Only if configurable
   C) **The getter is on an own, enumerable, string-keyed property** ✅
   D) Only in strict mode

4. You can change an accessor to a data property if:
   A) Always
   B) **It is `configurable: true`** ✅
   C) It is `enumerable: true`
   D) It has both get and set

5. A good pattern for **expensive** computed values is:
   A) Enumerable getter that computes every access
   B) **Lazy getter that memoizes or converts to a data property** ✅
   C) Hidden getter with `enumerable: false` and heavy CPU
   D) Do it in a setter that runs often

---

## Takeaways

* Accessors are great for **derived, cheap, or validated** fields; avoid hiding heavy work behind property reads.
* Enumerable accessors **run** during copies, iteration, and JSON—be intentional or make them non-enumerable / provide `toJSON`.
* For performance, use **lazy** or **cached** getters with explicit **invalidation**.
* Preserve accessors only with **descriptor-based** cloning; spread/assign copy **values**.

---

## What’s next

Move on to **Objects L3 — Prototype Chain & Own vs Inherited** to see how lookups traverse prototypes, how shadowing works, and how to safely iterate or override behavior without surprises.

