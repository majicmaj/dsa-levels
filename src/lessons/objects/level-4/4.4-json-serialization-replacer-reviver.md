---
id: objects-l4-json-serialization-replacer-reviver
title: "JSON Serialization (replacer & reviver, stable output)"
topic: objects
level: 4
lesson: 4.4
prereqs:
  - objects-l4-entries-pairs-and-fromentries
  - objects-l2-assign-spread-rest-shallow-copy
  - objects-l3-getters-setters-and-effects
outcomes:
  - Predict what **`JSON.stringify`** includes/excludes and how it walks objects
  - Use a **replacer** (function/whitelist) and **`toJSON`** to control output
  - Rebuild data with a **reviver** (e.g., rehydrate `Date`, `BigInt` via custom encoding)
  - Produce **stable, diff-friendly** JSON by **sorting keys** deterministically
  - Safely serialize **Map/Set/undefined/NaN/Infinity/Symbol/functions** with explicit policies
tags: ["objects","json","stringify","parse","replacer","reviver","toJSON","stable","dates","map","set","bigint"]
est_minutes: 40
checks:
  - type: quiz
    id: objects-l4-json-quiz
  - type: unit
    entry: toJsonStable.ts
    tests: toJsonStable.test.ts
  - type: unit
    entry: reviveDates.ts
    tests: reviveDates.test.ts
  - type: unit
    entry: stringifyWithReplacer.ts
    tests: stringifyWithReplacer.test.ts
  - type: unit
    entry: mapSetSerializer.ts
    tests: mapSetSerializer.test.ts
  - type: unit
    entry: parseSafe.ts
    tests: parseSafe.test.ts
---

## Why this matters

JSON is the lingua franca of web apps. But `JSON.stringify` has sharp edges: it **skips** some values, **invokes** getters/`toJSON`, **throws** on cycles/`BigInt`, and **orders keys** in ways that can make diffs noisy. This lesson gives you precise control.

---

## What `JSON.stringify` actually does

- Visits **own, enumerable, string-keyed** properties.  
  - **Skips** symbols and non-enumerables.
- On arrays: serializes indices in ascending order, holes → `null`.
- Runs `toJSON` if present on a value (e.g., `Date.prototype.toJSON()` → ISO string).
- Applies **replacer** (function or whitelist array) if provided.
- Numbers: `NaN`/`±Infinity` become `null`.  
- Values that are `undefined`, functions, or symbols:
  - As **object properties** → omitted.
  - As **array elements** → become `null`.
  - As **top-level** → result is `undefined` (i.e., nothing).
- **BigInt** throws `TypeError` by default.
- **Cycles** throw `TypeError`.

> Key order: follows object enumeration rules (integer-like strings first, then other strings by insertion). For deterministic diffs, **sort keys yourself**.

---

## Controlling output

### `toJSON` (on the value)
Attach a method returning a JSON-safe representation:
```ts
const model = {
  data: [1,2,3],
  get heavy() { /* expensive */ return this.data.reduce((a,b)=>a+b,0); },
  toJSON() { return { data: this.data }; } // omit heavy
};
JSON.stringify(model); // uses toJSON result
````

### Replacer (function)

Called for every key/value (post-order):

```ts
function redactReplacer(this: any, key: string, value: unknown) {
  if (key === "token") return undefined; // drop
  return value;
}
JSON.stringify(user, redactReplacer, 2);
```

### Replacer (whitelist array)

Only the listed keys (depth-aware) are kept:

```ts
JSON.stringify(user, ["id", "name"]); // shallow whitelist
```

---

## Rebuilding with a reviver

`JSON.parse(json, reviver)` walks the structure depth-first **after** parsing and lets you transform values.

### Rehydrate Dates

```ts
export function reviveDates(json: string) {
  const iso = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/;
  return JSON.parse(json, (_k, v) => (typeof v === "string" && iso.test(v)) ? new Date(v) : v);
}
```

### Custom encodings (BigInt, Map/Set)

Encode before stringify; decode in reviver:

```ts
// Encode: { __type: "BigInt", value: "123" }
export const encodeJson = (x: unknown) =>
  JSON.stringify(x, (_k, v) => typeof v === "bigint" ? { __type: "BigInt", value: v.toString() }
    : v instanceof Map ? { __type: "Map", entries: [...v] }
    : v instanceof Set ? { __type: "Set", values: [...v] }
    : v, 2);

export const decodeJson = (s: string) =>
  JSON.parse(s, (_k, v) => v && v.__type === "BigInt" ? BigInt(v.value)
    : v && v.__type === "Map" ? new Map(v.entries)
    : v && v.__type === "Set" ? new Set(v.values)
    : v);
```

---

## Stable, diff-friendly JSON (sorted keys)

Default key order can differ across construction paths. For clean diffs, **sort keys** consistently:

```ts
export function toJsonStable(x: unknown, space = 2): string {
  const seen = new WeakSet<object>();
  const stringify = (v: unknown): any => {
    if (v && typeof v === "object") {
      if (seen.has(v as object)) throw new Error("Cycle detected");
      seen.add(v as object);
      if (Array.isArray(v)) return v.map(stringify);
      const keys = Reflect.ownKeys(v as object)
        .filter(k => typeof k === "string") // JSON ignores symbols
        .sort((a, b) => (a as string).localeCompare(b as string));
      const out: Record<string, unknown> = {};
      for (const k of keys) {
        const val = (v as any)[k];
        if (val !== undefined && typeof val !== "function" && typeof val !== "symbol") {
          out[k as string] = stringify(val);
        }
      }
      return out;
    }
    if (typeof v === "number" && !Number.isFinite(v)) return null;
    if (typeof v === "bigint") throw new Error("BigInt not supported (encode explicitly).");
    return v;
  };
  return JSON.stringify(stringify(x), null, space);
}
```

---

## Handling Maps/Sets explicitly

Choose a policy up front:

* **Array form**: `{"__type":"Map","entries":[[k,v],...]}` / `{"__type":"Set","values":[...]}`
* **Object form (string keys only)**: `Object.fromEntries(map)` if all keys are strings and unique.

Be clear in docs/tests about which you use.

---

## Safety notes

* Replacers may **invoke getters** (reading values). For heavy accessors, prefer `toJSON` or make them non-enumerable.
* Beware of **prototype pollution** when merging parsed objects into existing objects—prefer **assigning into null-proto dicts** or validating keys.
* Never `eval` JSON; always `JSON.parse`.

---

## Common pitfalls

* Expecting symbols/non-enumerables in JSON — they’re ignored.
* Forgetting `BigInt` throws on stringify unless encoded.
* Assuming key order is stable between differently-constructed but equivalent objects.
* Serializing `Map`/`Set` without an agreed format → lossy or `{}` in JSON.

---

## Walkthrough: app config snapshot (stable + dates)

```ts
type Cfg = { name: string; createdAt: Date; flags: { compact: boolean } };

export function snapshotCfg(cfg: Cfg) {
  // 1) Convert to JSON-safe shape via toJSON (Date auto → ISO), no getters
  const plain = { ...cfg, createdAt: cfg.createdAt }; // Date -> ISO via stringify
  // 2) Stable, sorted keys for diffable snapshots
  return toJsonStable(plain, 2);
}
```

---

## Exercises

### 1) `toJsonStable(value, space?)` — stable, sorted-key JSON

Implement a stable stringify that:

* Sorts **string keys** lexicographically
* Drops `undefined`/functions/symbols
* Replaces `NaN/Infinity` with `null`
* Throws on cycles

**Starter — `toJsonStable.ts`**

```ts
export function toJsonStable(x: unknown, space = 2): string {
  const seen = new WeakSet<object>();
  const walk = (v: unknown): any => {
    if (v && typeof v === "object") {
      if (seen.has(v as object)) throw new Error("Cycle");
      seen.add(v as object);
      if (Array.isArray(v)) return (v as unknown[]).map(walk);
      const keys = Object.keys(v as object).sort();
      const out: Record<string, unknown> = {};
      for (const k of keys) {
        const val = (v as any)[k];
        if (val !== undefined && typeof val !== "function" && typeof val !== "symbol") out[k] = walk(val);
      }
      return out;
    }
    if (typeof v === "number" && !Number.isFinite(v)) return null;
    if (typeof v === "bigint") throw new Error("BigInt not supported");
    return v;
  };
  return JSON.stringify(walk(x), null, space);
}
```

---

### 2) `reviveDates(json)` — parse with Date rehydration

Detect ISO strings and return `Date` instances.

**Starter — `reviveDates.ts`**

```ts
export function reviveDates(s: string): unknown {
  const iso = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/;
  return JSON.parse(s, (_k, v) => (typeof v === "string" && iso.test(v)) ? new Date(v) : v);
}
```

---

### 3) `stringifyWithReplacer(value, replacer)` — function replacer wrapper

Call `JSON.stringify` with a **function** replacer that’s provided by the user; pass through `space`.

**Starter — `stringifyWithReplacer.ts`**

```ts
export function stringifyWithReplacer(
  value: unknown,
  replacer: (this: any, key: string, value: unknown) => unknown,
  space = 2
): string {
  return JSON.stringify(value, replacer as any, space)!;
}
```

---

### 4) `mapSetSerializer(x)` — encode Map/Set for JSON

Convert `Map`/`Set` to tagged JSON and leave other values as-is.

**Starter — `mapSetSerializer.ts`**

```ts
export function mapSetSerializer(x: unknown): string {
  return JSON.stringify(x, (_k, v) =>
    v instanceof Map ? { __type: "Map", entries: [...v] } :
    v instanceof Set ? { __type: "Set", values: [...v] } :
    v
  );
}
```

---

### 5) `parseSafe(s)` — safe parse with result object

Return `{ ok: true, value }` or `{ ok: false, error }` without throwing.

**Starter — `parseSafe.ts`**

```ts
export function parseSafe(s: string): { ok: true; value: unknown } | { ok: false; error: Error } {
  try { return { ok: true, value: JSON.parse(s) }; }
  catch (e) { return { ok: false, error: e as Error }; }
}
```

---

## Quiz (checks)

1. `JSON.stringify` will **omit** which of these when they appear as **object properties**? *(choose all)*

* `undefined` ✅
* functions ✅
* symbols ✅
* `NaN`

2. In arrays, `JSON.stringify([undefined, function(){}, Symbol()])` becomes:
   A) `[]`
   B) **`[null,null,null]`** ✅
   C) `["undefined","function","Symbol()"]`
   D) Throws

3. Which runs during stringification?
   A) **`toJSON` if present on the value** ✅
   B) Non-enumerable getters
   C) All prototype properties
   D) Reviver

4. Which will **throw** by default in `JSON.stringify`?
   A) `Date`
   B) `NaN`
   C) **`BigInt`** ✅
   D) `undefined`

5. To get **stable, diff-friendly** JSON regardless of insertion order, you should:
   A) Use `JSON.stringify(value, null, 2)`
   B) **Sort keys deterministically before stringifying** ✅
   C) Use `toString()` on the object
   D) Use `for…in` order

---

## Takeaways

* `JSON.stringify` only sees **own, enumerable, string** keys; it runs `toJSON` and your **replacer**.
* Use a **reviver** to rebuild richer types (`Date`, tagged `Map/Set`, custom `BigInt`).
* For clean diffs and reproducible snapshots, **sort keys** (stable stringify).
* Decide and document policies for **undefined/NaN/Infinity/Map/Set/BigInt** up front, and test them.

---

## What’s next

Level 5 time: **Objects L5 — Record & Index Signatures (Advanced)**, where we’ll go deep on exact object types, excess property checks, and safer dictionary modeling with TypeScript.
