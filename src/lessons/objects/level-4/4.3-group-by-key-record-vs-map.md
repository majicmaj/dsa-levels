---
id: objects-l4-group-by-key-record-vs-map
title: "Group by Key (Record<K, T[]> vs Map<K, T[]>)"
topic: objects
level: 4
lesson: 4.3
prereqs:
  - objects-l4-entries-pairs-and-fromentries
  - objects-l4-invert-and-collision-policies
  - objects-l2-keys-values-entries-hasown
outcomes:
  - Build **group by key** utilities as either `Record<K, T[]>` or `Map<K, T[]>`
  - Pick **Record vs Map** based on key type, ordering, JSON-ability, and scale
  - Normalize keys (trim/lower/canonicalize) and define **collision policies** for buckets
  - "Perform common grouped operations: **counts, top-K, flatten/ungroup**"
  - Understand ordering and performance trade-offs (integer-like key order, iteration, memory)
tags: ["objects","groupBy","record","map","normalization","histogram","top-k","ungroup"]
est_minutes: 40
checks:
  - type: quiz
    id: objects-l4-groupby-quiz
  - type: unit
    entry: groupByRecord.ts
    tests: groupByRecord.test.ts
  - type: unit
    entry: groupByMap.ts
    tests: groupByMap.test.ts
  - type: unit
    entry: histogram.ts
    tests: histogram.test.ts
  - type: unit
    entry: topKFromGroups.ts
    tests: topKFromGroups.test.ts
  - type: unit
    entry: ungroup.ts
    tests: ungroup.test.ts
  - type: unit
    entry: normalizeKey.ts
    tests: normalizeKey.test.ts
---

## Why this matters

“Group by” turns a flat list into buckets keyed by some property—core for reporting, indexing, and analytics. In JS/TS you’ll choose between:
- **`Record<K, T[]>`** (object dictionary of arrays)  
- **`Map<K, T[]>`** (general-purpose, ordered map)

Choosing well—and normalizing keys—prevents subtle bugs and makes downstream operations (counts, top-K, flatten) straightforward.

---

## Record vs Map (decision table)

| Consideration | `Record<K, T[]>` (object) | `Map<K, T[]>` |
|---|---|---|
| Key type | **String** (or string-like union) | **Any** `PropertyKey` (string/number/symbol) and objects |
| JSON-ability | ✅ Easily serializable | ⚠️ Needs materialization (entries) |
| Insertion order | Spec order for strings (integer-likes first, then insertion) | ✅ Preserves insertion order |
| Prototype concerns | Use `Object.create(null)` for dict-like | N/A (no prototype) |
| Size & updates at scale | OK, but Maps often faster for heavy churn | ✅ Good for frequent add/remove |
| TypeScript narrow keys | ✅ `Record<'a'|'b', T[]>` for closed sets | Less natural for closed sets |

**Rule of thumb:** string-only, JSON-bound? → `Record`. Need non-string keys, strict insertion order, or high-churn? → `Map`.

---

## Core shapes

### Record-based grouping
```ts
export function groupByRecord<T, K extends string>(
  items: readonly T[],
  keyOf: (t: T) => K
): Record<K, T[]> {
  const out = Object.create(null) as Record<K, T[]>;
  for (const item of items) {
    const k = keyOf(item);
    (out[k] ??= []).push(item);
  }
  return out;
}
````

### Map-based grouping

```ts
export function groupByMap<T, K>(
  items: readonly T[],
  keyOf: (t: T) => K
): Map<K, T[]> {
  const m = new Map<K, T[]>();
  for (const item of items) {
    const k = keyOf(item);
    const bucket = m.get(k);
    if (bucket) bucket.push(item);
    else m.set(k, [item]);
  }
  return m;
}
```

---

## Key normalization (critical!)

Decide a **canonical form** *before* grouping:

* Strings: `trim().toLowerCase()`, Unicode normalize (`NFC`)
* Paths/URLs: strip trailing slashes, normalize case if needed
* Objects: stable keying (stringify deterministically) or extract an ID

```ts
export function normalizeKey(s: string): string {
  return s.normalize("NFC").trim().toLowerCase();
}
```

Use it in `keyOf`:

```ts
const byTag = groupByRecord(posts, p => normalizeKey(p.tag));
```

---

## Common group operations

### Histogram (counts per key)

```ts
export function histogram<T, K extends string>(
  items: readonly T[],
  keyOf: (t: T) => K
): Record<K, number> {
  const out = Object.create(null) as Record<K, number>;
  for (const t of items) out[keyOf(t)] = (out[keyOf(t)] ?? 0) + 1;
  return out;
}
```

### Top-K buckets by size

```ts
export function topKFromGroups<K extends string>(
  groups: Record<K, unknown[]>,
  k: number
): Array<[K, number]> {
  const entries = Object.entries(groups) as Array<[K, unknown[]]>;
  entries.sort((a,b) => b[1].length - a[1].length);
  return entries.slice(0, k).map(([k, arr]) => [k, arr.length]);
}
```

### Ungroup (flatten with key attached)

```ts
export function ungroup<K extends string, T>(
  groups: Record<K, T[]>
): Array<{ key: K; value: T }> {
  const out: Array<{ key: K; value: T }> = [];
  for (const [k, arr] of Object.entries(groups) as Array<[K, T[]]>) {
    for (const v of arr) out.push({ key: k, value: v });
  }
  return out;
}
```

For `Map`, iterate with `for (const [k, arr] of map)`.

---

## Ordering considerations

* **Record** enumeration: integer-like keys (`"0"`, `"1"`, …) come first, then other strings in insertion order. If you need stable **display order**, **sort entries** explicitly before UI.
* **Map** preserves insertion order **exactly**.

---

## Pitfalls & guardrails

* Grouping without normalization causes near-duplicate buckets (`"Tech"` vs `"tech "`).
* Using `Object.keys` on a dict with potential prototype pollution—prefer **null-proto** dicts.
* Assuming `Record` retains insertion order for integer-like keys—it won’t.
* Serializing a `Map` directly—`JSON.stringify(new Map())` → `{}`. Convert with `Object.fromEntries(map)` or a custom format.

---

## Walkthrough: tag analytics

```ts
type Post = { id: string; tag: string; words: number };

const groups = groupByRecord<Post, string>(posts, p => normalizeKey(p.tag));
const counts = Object.fromEntries(
  Object.entries(groups).map(([k, arr]) => [k, arr.length])
);
const top5 = topKFromGroups(groups, 5);
const flat = ungroup(groups); // [{key:"tech", value: Post}, ...]
```

---

## Exercises

### 1) `groupByRecord(items, keyOf)`

Return a **null-proto** `Record<K, T[]>` using `??=` for bucket creation.

**Starter — `groupByRecord.ts`**

```ts
export function groupByRecord<T, K extends string>(
  items: readonly T[],
  keyOf: (t: T) => K
): Record<K, T[]> {
  const out = Object.create(null) as Record<K, T[]>;
  for (const t of items) {
    const k = keyOf(t);
    (out[k] ??= []).push(t);
  }
  return out;
}
```

---

### 2) `groupByMap(items, keyOf)`

Use a `Map<K, T[]>` and preserve insertion order.

**Starter — `groupByMap.ts`**

```ts
export function groupByMap<T, K>(
  items: readonly T[],
  keyOf: (t: T) => K
): Map<K, T[]> {
  const m = new Map<K, T[]>();
  for (const t of items) {
    const k = keyOf(t);
    const b = m.get(k);
    if (b) b.push(t); else m.set(k, [t]);
  }
  return m;
}
```

---

### 3) `histogram(items, keyOf)`

Return counts per key as a **null-proto** `Record<K, number>`.

**Starter — `histogram.ts`**

```ts
export function histogram<T, K extends string>(
  items: readonly T[],
  keyOf: (t: T) => K
): Record<K, number> {
  const out = Object.create(null) as Record<K, number>;
  for (const t of items) {
    const k = keyOf(t);
    out[k] = (out[k] ?? 0) + 1;
  }
  return out;
}
```

---

### 4) `topKFromGroups(groups, k)`

Accept `Record<string, unknown[]>` and return top-K `[key, size]` pairs.

**Starter — `topKFromGroups.ts`**

```ts
export function topKFromGroups(
  groups: Record<string, unknown[]>,
  k: number
): Array<[string, number]> {
  const entries = Object.entries(groups) as Array<[string, unknown[]]>;
  entries.sort((a,b) => b[1].length - a[1].length);
  return entries.slice(0, k).map(([k, arr]) => [k, arr.length]);
}
```

---

### 5) `ungroup(groups)`

Flatten a `Record<K, T[]>` into an array of `{key, value}`.

**Starter — `ungroup.ts`**

```ts
export function ungroup<K extends string, T>(
  groups: Record<K, T[]>
): Array<{ key: K; value: T }> {
  const out: Array<{ key: K; value: T }> = [];
  for (const [k, arr] of Object.entries(groups) as Array<[K, T[]]>) {
    for (const v of arr) out.push({ key: k, value: v });
  }
  return out;
}
```

---

### 6) `normalizeKey(s)`

Implement `NFC + trim + lower`.

**Starter — `normalizeKey.ts`**

```ts
export function normalizeKey(s: string): string {
  return s.normalize("NFC").trim().toLowerCase();
}
```

---

## Quiz (checks)

1. You need **object keys** (not strings) as group keys. Choose:
   A) `Record<K, T[]>`
   B) **`Map<K, T[]>`** ✅
   C) `Object.fromEntries` only
   D) JSON stringify the keys

2. Grouping tags for an API response you’ll `JSON.stringify`. Prefer:
   A) **`Record<string, T[]>`** ✅
   B) `Map<string, T[]>` directly
   C) Symbol keys
   D) WeakMap

3. Why normalize keys before grouping strings?
   A) To speed up GC
   B) **To merge equivalent labels (`"Tech"` vs `"tech "`), avoiding split buckets** ✅
   C) To preserve insertion order
   D) To support symbols

4. With a **Record** of groups, key enumeration order is:
   A) Insertion order always
   B) **Integer-like strings first, then other strings in insertion order** ✅
   C) Symbols first
   D) Random

5. `JSON.stringify(new Map([["a",[1,2]]]))` yields:
   A) `'{"a":[1,2]}'`
   B) `'[["a",[1,2]]]'`
   C) **`'{}'` in many environments (not serialized as you expect)** ✅
   D) Throws by default

---

## Takeaways

* Use **Record** for JSON-friendly, string-key grouping; use **Map** for non-string keys or when insertion order matters strictly.
* Always **normalize** keys before grouping; define explicit downstream ops (counts, top-K, flatten).
* Be explicit about **ordering** and **serialization**—objects and Maps differ here.
* Prefer **null-proto** dicts for Record-based buckets to avoid prototype surprises.

---

## What’s next

Wrap L4 with **Objects L4 — JSON Serialization (replacer & reviver)** to safely encode/decode Dates, handle `undefined`, maintain stable key order for diffs, and avoid accidental accessor execution.
