---
id: objects-l4-entries-pairs-and-fromentries
title: "Entries ↔ FromEntries (Transformations)"
topic: objects
level: 4
lesson: 4.1
prereqs:
  - objects-l2-keys-values-entries-hasown
  - objects-l2-enumeration-order-caveats
  - objects-l2-assign-spread-rest-shallow-copy
outcomes:
  - Convert objects ⇄ arrays of pairs with `Object.entries` and `Object.fromEntries`
  - Build **map/filter/reduce** style transforms over objects via entries
  - Understand what `entries` includes/excludes (own + enumerable + **string** keys)
  - Include **symbols** or **non-enumerables** when you really need them
  - Preserve / control **ordering** and handle **duplicate keys** policies on rebuild
tags: ["objects","entries","fromEntries","pairs","transform","symbols","enumerable","order"]
est_minutes: 35
checks:
  - type: quiz
    id: objects-l4-entries-fromentries-quiz
  - type: unit
    entry: toPairs.ts
    tests: toPairs.test.ts
  - type: unit
    entry: fromPairs.ts
    tests: fromPairs.test.ts
  - type: unit
    entry: mapValues.ts
    tests: mapValues.test.ts
  - type: unit
    entry: filterEntries.ts
    tests: filterEntries.test.ts
  - type: unit
    entry: sortEntriesStable.ts
    tests: sortEntriesStable.test.ts
crosslinks:
  - { to: arrays-l3-stable-sorting-and-keys, why: "Stable sorting and multi-key comparators for entries" }
  - { to: arrays-l2-sort-and-compare, why: "Comparator basics to order entries before rebuilding" }
---

## Why this matters

Most real-world object work is **transform → filter → reshape**. Arrays already have rich tools (map/filter/reduce), so the fastest way to power up objects is to hop to **entries** (pairs), do the work, then hop back with `fromEntries`. This lesson makes that round-trip precise, including symbols/ordering edge cases.

---

## Quick refresher — what gets included

```ts
Object.entries(obj); // -> Array<[string, unknown]>
// Includes: own + enumerable + STRING keys
// Excludes: symbols, non-enumerables, prototype keys
````

To include **symbols** or **non-enumerables**, use `Reflect.ownKeys` + descriptors and build your own pairs (see Advanced below).

`Object.fromEntries(iterable)` builds a plain object from `[key, value]` pairs. Keys may be **string or symbol** (i.e., any `PropertyKey`). Non-enumerability cannot be set with `fromEntries`—it creates **enumerable data properties**.

---

## Core patterns

### Map an object’s values

```ts
const prices = { apple: 100, pear: 80 };
const withTax = Object.fromEntries(
  Object.entries(prices).map(([k, v]) => [k, Math.round(v * 1.07)])
);
// { apple: 107, pear: 86 }
```

### Filter by key or value

```ts
const activeOnly = Object.fromEntries(
  Object.entries(users).filter(([_k, u]) => u.active)
);
```

### Reduce to something else

```ts
const sum = Object.entries(points).reduce((s, [_k, v]) => s + v, 0);
```

### Rename keys (shallow)

```ts
function renameKeys<T extends object>(obj: T, map: Record<string, string>) {
  return Object.fromEntries(
    Object.entries(obj).map(([k, v]) => [map[k] ?? k, v])
  );
}
```

---

## Ordering rules (recap)

When you turn an object into entries via `Object.entries`, you’ll get keys in:

1. integer-like strings (`"0"`, `"1"`, …) ascending
2. other strings in insertion order

If you want a **display order**, sort the entries **explicitly** before `fromEntries` (and remember: objects don’t *guarantee* arbitrary custom order semantics—order applies when enumerating).

---

## Advanced: include symbols / non-enumerables

```ts
function entriesAll(obj: object): Array<[string | symbol, unknown]> {
  return Reflect.ownKeys(obj).map(k => {
    const d = Object.getOwnPropertyDescriptor(obj, k)!;
    // If accessor, reading d.value would not exist; decide policy.
    return [k, "value" in d ? d.value : undefined];
  });
}

const obj = { a: 1, [Symbol.for("s")]: 2 };
const pairs = entriesAll(obj);
const copy = Object.fromEntries(pairs); // symbol preserved if enumerable on rebuild
```

> `fromEntries` always creates **enumerable data** properties. To copy **exact** flags/accessors, use descriptors (see L3).

---

## Common pitfalls

* Expecting `Object.entries` to include **symbols** or **non-enumerables** (it won’t).
* Assuming `fromEntries` preserves **getters/setters** or non-enumerability—it **doesn’t** (data, enumerable).
* Rebuilding with duplicate keys in your pairs—by default **last write wins**.
* Relying on object order for logic; prefer **sorted arrays** or **Map** when order is critical.

---

## Walkthrough: object → entries → transform → object

```ts
type Score = Record<string, number>;
function curve(scores: Score, add = 5): Score {
  return Object.fromEntries(
    Object.entries(scores).map(([name, s]) => [name, s + add])
  );
}
```

---

## Exercises

### 1) `toPairs(obj)` — own enumerable string-keyed pairs

Return `Array<[string, unknown]>` using `Object.entries`.

**Starter — `toPairs.ts`**

```ts
export function toPairs(obj: object): Array<[string, unknown]> {
  return Object.entries(obj);
}
```

---

### 2) `fromPairs(entries)` — build an object (last wins)

Given `Array<[PropertyKey, unknown]>`, return a plain object built with `Object.fromEntries`. Keys can be **string or symbol**.

**Starter — `fromPairs.ts`**

```ts
export function fromPairs(entries: Array<[PropertyKey, unknown]>): Record<string | symbol, unknown> {
  return Object.fromEntries(entries as any);
}
```

---

### 3) `mapValues(obj, fn)` — value transform, same keys

Apply `fn(v, k)` to each value and return a **new** object.

**Starter — `mapValues.ts`**

```ts
export function mapValues<T extends object, R>(
  obj: T,
  fn: (value: T[keyof T], key: keyof T & string) => R
): Record<keyof T & string, R> {
  return Object.fromEntries(
    Object.entries(obj).map(([k, v]) => [k, fn(v as any, k as any)])
  ) as any;
}
```

---

### 4) `filterEntries(obj, pred)` — keep some pairs

Keep entries where `pred(k, v)` is true.

**Starter — `filterEntries.ts`**

```ts
export function filterEntries<T extends object>(
  obj: T,
  pred: (key: keyof T & string, value: T[keyof T]) => boolean
): Partial<T> {
  return Object.fromEntries(
    Object.entries(obj).filter(([k, v]) => pred(k as any, v as any))
  ) as Partial<T>;
}
```

---

### 5) `sortEntriesStable(obj, cmp)` — sort then rebuild

Sort entries with a comparator `(a: [k,v], b: [k,v]) => number` and return the rebuilt object. (Remember: you’re defining **display** order; logic should not rely on key order.)

**Starter — `sortEntriesStable.ts`**

```ts
export function sortEntriesStable<T extends object>(
  obj: T,
  cmp: (a: [string, T[keyof T]], b: [string, T[keyof T]]) => number
): Record<string, T[keyof T]> {
  const entries = Object.entries(obj) as Array<[string, T[keyof T]]>;
  entries.sort(cmp);
  return Object.fromEntries(entries) as Record<string, T[keyof T]>;
}
```

---

## Quiz (checks)

1. `Object.entries(obj)` includes:
   A) Own + prototype + symbols
   B) **Own + enumerable + string keys** ✅
   C) All own keys including non-enumerables
   D) Symbols only

2. `Object.fromEntries([['x',1],['x',2]])` yields:
   A) `{ x: 1 }`
   B) **`{ x: 2 }` (last wins)** ✅
   C) `{ x: [1,2] }`
   D) Throws

3. To include **symbol** keys when extracting pairs you should:
   A) Use `Object.entries`
   B) **Use `Reflect.ownKeys` and build pairs manually** ✅
   C) Use `Object.keys`
   D) It’s not possible

4. `fromEntries` creates properties that are:
   A) Non-enumerable data props
   B) Accessor props (get/set)
   C) **Enumerable data props** ✅
   D) Prototype props

5. If you need **custom order** for display, you should:
   A) Rely on object insertion order
   B) **Sort the entries array before `fromEntries`** ✅
   C) Use `for…in`
   D) Use JSON stringify

---

## Takeaways

* Hop to **entries**, do array things, then hop back with `fromEntries`.
* `entries` ignores **symbols/non-enumerables**; use `Reflect.ownKeys` when needed.
* `fromEntries` creates **enumerable data** props; duplicate keys → **last wins**.
* Make ordering **explicit** with a sorted entries array; don’t hide logic in implicit object order.

---

## What’s next

Move on to **Objects L4 — Invert & Collision Policies** to flip key↔value safely and choose policies for duplicates (`first` / `last` / `group`), plus type-safe helpers.