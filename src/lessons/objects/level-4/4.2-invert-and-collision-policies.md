---
id: objects-l4-invert-and-collision-policies
title: "Invert & Collision Policies (first/last/group)"
topic: objects
level: 4
lesson: 4.2
prereqs:
  - objects-l4-entries-pairs-and-fromentries
  - objects-l2-enumeration-order-caveats
outcomes:
  - Invert objects **safely**: value→key with explicit **collision policies**
  - Choose the right **key encoding** for values (string/symbol) and avoid silent data loss
  - Implement **first-win**, **last-win**, and **group** policies
  - Understand when to use **Record** vs **Map** for inversion
  - Normalize values before inverting (e.g., lowercase, trim, stable stringify)
tags: ["objects","invert","collision","group","entries","map","record","normalization"]
est_minutes: 35
checks:
  - type: quiz
    id: objects-l4-invert-quiz
  - type: unit
    entry: invertFirst.ts
    tests: invertFirst.test.ts
  - type: unit
    entry: invertLast.ts
    tests: invertLast.test.ts
  - type: unit
    entry: invertGroup.ts
    tests: invertGroup.test.ts
  - type: unit
    entry: invertWithKeyFn.ts
    tests: invertWithKeyFn.test.ts
  - type: unit
    entry: stableStringify.ts
    tests: stableStringify.test.ts
---

## Why this matters

“Inverting” (`{ k: v } → { v: k }`) is common for building **reverse lookups** and de-duplication tools. But values can collide (`a→1`, `b→1`), values might not be strings, and casing/whitespace differences can split buckets. Define **explicit policies** and encodings so your inversion is **predictable** and **lossless** (or intentionally lossy).

---

## Collision policies

Given an input object `O: Record<string, V>`:

- **first-win**: keep the **first** key seen for a value; ignore later duplicates.
- **last-win**: later keys **overwrite** earlier ones (default of naive `fromEntries`).
- **group**: collect **all keys** that share the same value → `Record<string, string[]>`.

> For large/unknown key spaces or non-string values, prefer a **Map**-based implementation internally, materializing to an object at the edge.

---

## Keys, symbols, and encoding values

Object keys must be **string** or **symbol**. When inverting:
- If `V` is already `string | symbol | number`, you can coerce (`number → string`).
- If `V` is **object/array/Date/Map** etc., you need a **key function**:
  - **Stable stringify** (e.g., sorted keys) for JSON-like values
  - Domain-specific key: e.g., user `{id, email}` → `id` as the key
  - Be explicit about **normalization** (trim/lowercase) before inversion

> Symbols are allowed as keys in `fromEntries`, but `Object.entries` won’t include them later. Reserve symbols for internal reverses.

---

## Implementations (shape)

### First-win (object)
```ts
export function invertFirst<T extends Record<string, PropertyKey>>(obj: T) {
  const out: Record<string | symbol, string> = {};
  for (const [k, v] of Object.entries(obj)) {
    const key = String(v);          // number→string; symbols need handling below
    if (!(key in out)) out[key] = k;
  }
  return out;
}
````

### Last-win (object)

```ts
export function invertLast<T extends Record<string, PropertyKey>>(obj: T) {
  const out: Record<string | symbol, string> = {};
  for (const [k, v] of Object.entries(obj)) out[String(v)] = k; // later overwrites
  return out;
}
```

### Group (object)

```ts
export function invertGroup<T extends Record<string, PropertyKey>>(obj: T) {
  const out: Record<string | symbol, string[]> = {};
  for (const [k, v] of Object.entries(obj)) {
    const key = String(v);
    (out[key] ??= []).push(k);
  }
  return out;
}
```

> To support **symbol values** precisely, handle them separately: `typeof v === "symbol" ? v : String(v)`, and store into a `Map<PropertyKey, ...>` internally before materializing.

---

## With a key function (stable & normalized)

```ts
export function invertWithKeyFn<T extends Record<string, unknown>>(
  obj: T,
  toKey: (v: unknown, k: string) => PropertyKey
) {
  const m = new Map<PropertyKey, string>(); // change to Map<PropertyKey, string[]> for group
  for (const [k, v] of Object.entries(obj)) {
    const key = toKey(v, k);
    if (!m.has(key)) m.set(key, k); // first-win
  }
  // materialize to object; symbol keys preserved if present
  return Object.fromEntries(m.entries());
}
```

### Stable stringify helper (for JSON-shaped values)

```ts
export function stableStringify(x: unknown): string {
  if (x === null || typeof x !== "object") return JSON.stringify(x);
  const keys = Reflect.ownKeys(x as object).sort((a,b)=>String(a).localeCompare(String(b)));
  const o: any = Array.isArray(x) ? [] : {};
  for (const k of keys) (o as any)[k as any] = stableStringify((x as any)[k as any]);
  return JSON.stringify(o);
}
```

---

## When to use Map during inversion

* Values are **objects** or **symbols** → use `Map<PropertyKey, ...>` to avoid coercion.
* You need **insertion order** for reporting.
* You want to carry **non-enumerable** or **meta** alongside keys.

Convert to a plain object with `Object.fromEntries(map)` at the edge if you need JSON.

---

## Common pitfalls

* **Silent overwrite** when two different keys share the same value (use **group** or document **last-win**).
* Building keys with plain `JSON.stringify` (unstable property order; Date/Map/Set issues).
* Forgetting to **normalize** case/whitespace before inversion when semantics require it.
* Using `Object.entries` / `fromEntries` and expecting **symbols** in entries—they’re excluded by entries (use `Reflect.ownKeys` if needed).

---

## Walkthrough: case-insensitive reverse index

```ts
type Emails = Record<string, string>; // name -> email

function invertEmailFirst(emails: Emails) {
  return invertWithKeyFn(emails, (v) => String(v).trim().toLowerCase());
}
// "Amina" -> "a@b.com", "amina2" -> "A@B.COM"  → first-win keeps the earliest
```

---

## Exercises

### 1) `invertFirst(obj)` — first writer wins

Input: `Record<string, PropertyKey>`. Output: `Record<string | symbol, string>`.

* Do **not** overwrite existing outputs.
* Coerce numbers to strings; handle symbols by storing them as **symbol keys** (use a Map internally, then materialize).

**Starter — `invertFirst.ts`**

```ts
export function invertFirst(obj: Record<string, PropertyKey>): Record<string | symbol, string> {
  const map = new Map<PropertyKey, string>();
  for (const [k, v] of Object.entries(obj)) {
    if (!map.has(v as PropertyKey)) map.set(v as PropertyKey, k);
  }
  return Object.fromEntries(map);
}
```

---

### 2) `invertLast(obj)` — last writer wins

Later keys overwrite earlier ones.

**Starter — `invertLast.ts`**

```ts
export function invertLast(obj: Record<string, PropertyKey>): Record<string | symbol, string> {
  const map = new Map<PropertyKey, string>();
  for (const [k, v] of Object.entries(obj)) map.set(v as PropertyKey, k);
  return Object.fromEntries(map);
}
```

---

### 3) `invertGroup(obj)` — group keys by value

Return `Record<string | symbol, string[]>` in which groups preserve **insertion order** of original keys.

**Starter — `invertGroup.ts`**

```ts
export function invertGroup(obj: Record<string, PropertyKey>): Record<string | symbol, string[]> {
  const map = new Map<PropertyKey, string[]>();
  for (const [k, v] of Object.entries(obj)) {
    const arr = map.get(v as PropertyKey);
    if (arr) arr.push(k); else map.set(v as PropertyKey, [k]);
  }
  return Object.fromEntries(map);
}
```

---

### 4) `invertWithKeyFn(obj, toKey)` — custom key encoder

Support arbitrary values by supplying `toKey(v, k)` that returns **string | symbol**. Implement **first-win** by default.

**Starter — `invertWithKeyFn.ts`**

```ts
export function invertWithKeyFn(
  obj: Record<string, unknown>,
  toKey: (v: unknown, k: string) => PropertyKey
): Record<string | symbol, string> {
  const map = new Map<PropertyKey, string>();
  for (const [k, v] of Object.entries(obj)) {
    const key = toKey(v, k);
    if (!map.has(key)) map.set(key, k);
  }
  return Object.fromEntries(map);
}
```

---

### 5) `stableStringify(x)` — deterministic keying for JSON-like values

Produce a **deterministic** string representation (sorted keys, recursing). Arrays preserve order; objects sort keys; primitives via `JSON.stringify`.

**Starter — `stableStringify.ts`**

```ts
export function stableStringify(x: unknown): string {
  if (x === null || typeof x !== "object") return JSON.stringify(x);
  if (Array.isArray(x)) return `[${x.map(stableStringify).join(",")}]`;
  const keys = Reflect.ownKeys(x as object).sort((a,b)=>String(a).localeCompare(String(b)));
  const parts: string[] = [];
  for (const k of keys) {
    const v = (x as any)[k as any];
    parts.push(`${JSON.stringify(String(k))}:${stableStringify(v)}`);
  }
  return `{${parts.join(",")}}`;
}
```

---

## Quiz (checks)

1. Inversion defaulting to **last-win** happens because:
   A) `Object.keys` sorts keys
   B) **Later pairs overwrite earlier during rebuild (`fromEntries`)** ✅
   C) JSON stringify order
   D) Symbols are dropped

2. If multiple input keys share the same value, which policies are valid? *(choose all)*

* **first-win** ✅
* **last-win** ✅
* **group (array of original keys)** ✅
* “random-win”

3. Which value types require a **key function** or Map-based approach to invert safely?
   A) `string | number | symbol`
   B) **Objects/arrays/Date/Map/Set** ✅
   C) `boolean` only
   D) `null` only

4. `Object.entries` and `Object.fromEntries` together will NOT preserve:
   A) **Accessors and non-enumerability** ✅
   B) Enumerable data properties
   C) String keys
   D) Insertion order among non-integer-like strings

5. Best practice for **case-insensitive** inversion of emails is to:
   A) Invert directly with `invertLast`
   B) **Normalize with `.trim().toLowerCase()` in a key function** ✅
   C) Use symbols for all emails
   D) JSON stringify values

---

## Takeaways

* Inversion is easy—but **collisions** and **value encoding** determine correctness.
* Pick a policy: **first**, **last**, or **group**; document it.
* Use a **Map** internally for non-string/symbol values; materialize to an object when needed.
* Normalize and/or **stable-stringify** complex values for predictable keys.

---

## What’s next

Continue to **Objects L4 — Group by Key (Record vs Map)** to build `Record<K, T[]>` shapes, compare them to `Map<K, T[]>`, and design stable, normalized grouping utilities for real-world data.
