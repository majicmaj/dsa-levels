---
id: objects-l5-practical-object-patterns
title: "Practical Object Patterns (APIs, DTOs, Configs)"
topic: objects
level: 5
lesson: 5.4
prereqs:
  - objects-l4-json-serialization-replacer-reviver
  - objects-l5-record-and-index-signatures
  - objects-l5-utility-types-mapped-modifiers
  - objects-l5-conditional-types-advanced-remapping
  - objects-l3-descriptors-and-defineproperty
outcomes:
  - "Design **end-to-end object flows**: input → validate/normalize → internal model → DTO serialize"
  - Create **runtime mappers** that mirror your **type-level** key remaps (snake_case ↔ camelCase)
  - Implement **versioned payload** adapters (V1/V2) that converge to a single internal shape
  - Build **immutable config** pipelines with exact keys, defaults, and redaction
  - Ship **safe reducers** using structural sharing + shallow/deep freeze where appropriate
tags: ["objects","dto","api","config","normalization","versioning","serialization","immutability","typescript"]
est_minutes: 55
checks:
  - type: quiz
    id: objects-l5-practical-patterns-quiz
  - type: unit
    entry: keyMapRuntime.ts
    tests: keyMapRuntime.test.ts
  - type: unit
    entry: toDtoFromDto.ts
    tests: toDtoFromDto.test.ts
  - type: unit
    entry: versionedDecode.ts
    tests: versionedDecode.test.ts
  - type: unit
    entry: buildConfig.ts
    tests: buildConfig.test.ts
  - type: unit
    entry: redactAndWhitelist.ts
    tests: redactAndWhitelist.test.ts
  - type: unit
    entry: reducerImmutable.ts
    tests: reducerImmutable.test.ts
---

## Why this matters

Real apps juggle **incoming JSON**, **internal domain objects**, and **outgoing DTOs**. If your type-level intentions (exact keys, renames, optionality) aren’t reflected at **runtime**, bugs slip in: extra keys, missing defaults, wrong casing, silent overwrites. This lesson gives you small, composable patterns you can drop into any project.

---

## The end-to-end pipeline (mental model)

```

wire JSON (unknown)
→ decode & validate (narrow shape, coerce types)
→ normalize keys (snake ↔ camel)
→ fill defaults & freeze (internal model)
→ business logic
→ DTO serialize (explicit whitelists, casing, redaction)

````

Key rules:
- **Mirror** your **type-level** transforms at runtime.
- **Whitelist** outbound fields; **ignore** unknown inbound fields (or log).
- Prefer **immutable** internal models; perform updates via **structural sharing**.

---

## Type-level vs runtime key remapping

Type-level (from previous lessons):

```ts
type RenameKeys<T, M extends Record<PropertyKey, PropertyKey>> = {
  [K in keyof T as K extends keyof M ? M[K] : K]: T[K]
};
````

Runtime to match:

```ts
export function renameKeysRuntime<
  T extends Record<PropertyKey, unknown>,
  M extends Record<PropertyKey, PropertyKey>
>(obj: T, map: M): Record<PropertyKey, unknown> {
  const out: Record<PropertyKey, unknown> = {};
  for (const k of Reflect.ownKeys(obj)) {
    const to = (k in map ? (map as any)[k] : k) as PropertyKey;
    const d = Object.getOwnPropertyDescriptor(obj, k)!;
    // Copy by value (enumerable data only) for DTOs; avoid triggering getters accidentally.
    if ("value" in d) out[to] = d.value;
  }
  return out;
}
```

> For *descriptor-preserving* clones, use the patterns from L3. For DTOs, copying **data** is usually correct.

---

## Case study: User DTO (snake\_case API ↔ camelCase internal)

### Domain model (internal)

```ts
type User = Readonly<{
  id: string;
  displayName: string;
  email?: string;
  createdAt: Date;
  flags: { admin: boolean; beta?: boolean };
}>;
```

### API DTOs

```ts
// Incoming/outgoing JSON-safe shapes
type UserDTOv1 = {
  id: string;
  display_name: string;
  email?: string | null;
  created_at: string;          // ISO
  admin?: boolean;             // v1 nested flags flattened
};

type UserDTOv2 = {
  id: string;
  display_name: string;
  email?: string | null;
  created_at: string;
  flags?: { admin?: boolean; beta?: boolean };
  _v: 2;                       // explicit version tag
};
```

### Decode (unknown → User)

```ts
type Incoming = UserDTOv2 | UserDTOv1;

const snakeToCamel = {
  display_name: "displayName",
  created_at: "createdAt"
} as const;

export function decodeUser(input: unknown): User {
  // 1) Basic shape narrow (lightweight; use a validator in real apps)
  if (!input || typeof input !== "object") throw new Error("bad payload");
  const raw = input as Record<string, unknown>;

  // 2) Normalize keys
  const camel = renameKeysRuntime(raw, snakeToCamel) as any;

  // 3) Version-adapt → v2-ish
  const flags =
    camel.flags && typeof camel.flags === "object"
      ? { admin: !!(camel.flags as any).admin, beta: !!(camel.flags as any).beta }
      : { admin: !!camel.admin, beta: false };

  // 4) Coerce/validate fields, fill defaults
  const user: User = Object.freeze({
    id: String(camel.id),
    displayName: String(camel.displayName ?? ""),
    email: camel.email == null ? undefined : String(camel.email),
    createdAt: new Date(String(camel.createdAt)),
    flags: Object.freeze({ admin: !!flags.admin, beta: !!flags.beta })
  });

  return user;
}
```

### Encode (User → DTO v2 snake\_case)

```ts
const camelToSnake = {
  displayName: "display_name",
  createdAt: "created_at"
} as const;

export function encodeUserV2(u: User): UserDTOv2 {
  const base = {
    id: u.id,
    display_name: u.displayName,
    email: u.email ?? null,
    created_at: u.createdAt.toISOString(),
    flags: { admin: !!u.flags.admin, beta: !!u.flags.beta },
    _v: 2 as const
  };
  // Whitelist + stable key order is recommended for diffable snapshots
  return base;
}
```

---

## Versioned decoders (graceful evolution)

Create a single **normalize** function that understands old & new formats and always returns **one** internal shape.

```ts
type DecodeResult<T> = { ok: true; value: T } | { ok: false; error: Error };

export function decodeVersioned<T>(parsers: Array<(x: unknown) => T>): (x: unknown) => DecodeResult<T> {
  return (x) => {
    for (const p of parsers) {
      try { return { ok: true, value: p(x) }; } catch {}
    }
    return { ok: false, error: new Error("No version matched") };
  };
}

// Usage: const decodeUserAny = decodeVersioned<User>([decodeUserV2, decodeUserV1]);
```

---

## Immutable config builder (exact keys + defaults + freeze)

```ts
type RawConfig = Partial<{
  host: string;
  port: number | string;
  compact: boolean | "true" | "false";
}>;

type Config = Readonly<{
  host: string;
  port: number;
  compact: boolean;
}>;

export function buildConfig(input: RawConfig): Config {
  const host = input.host?.trim() || "localhost";
  const port = typeof input.port === "string" ? Number(input.port) : (input.port ?? 3000);
  const compact = input.compact === "true" ? true :
                  input.compact === "false" ? false :
                  !!input.compact;

  const cfg = { host, port, compact } as const;
  return Object.freeze(cfg);
}
```

Pair with **exact** compile-time constraints when constructing fixed tables:

```ts
const LABELS = {
  idle: "Idle",
  loading: "Loading…",
  done: "Done"
} as const satisfies Record<"idle" | "loading" | "done", string>;
```

---

## Redaction & whitelisting (safe boundaries)

```ts
type Redactor = (k: string, v: unknown) => unknown;

export function whitelist(obj: object, keys: readonly string[]): Record<string, unknown> {
  const out: Record<string, unknown> = Object.create(null);
  for (const k of keys) if (Object.hasOwn(obj, k)) out[k] = (obj as any)[k];
  return out;
}

export function redact(obj: object, redactor: Redactor): Record<string, unknown> {
  const out: Record<string, unknown> = {};
  for (const [k, v] of Object.entries(obj)) out[k] = redactor(k, v);
  return out;
}

// Example: remove secrets, mask emails
const safe = redact(user, (k, v) => k === "email" ? (v ? "***" : v) : v);
```

---

## Reducers with structural sharing (and freeze)

```ts
type State = Readonly<{ count: number; user?: User }>;
type Action =
  | { type: "INC"; by?: number }
  | { type: "SET_USER"; payload: User }
  | { type: "RESET" };

export function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "INC": {
      const next = { ...state, count: state.count + (action.by ?? 1) };
      return Object.freeze(next);
    }
    case "SET_USER": {
      const next = { ...state, user: action.payload };
      return Object.freeze(next);
    }
    case "RESET": return Object.freeze({ count: 0 });
  }
}
```

> Freeze in dev to catch accidental mutation; consider skipping in hot prod paths for performance unless you rely on it.

---

## Common pitfalls

* **Type-only remaps** without runtime mapping → wrong keys on the wire.
* Accepting inbound objects wholesale (`{...req.body}`) → **excess keys** leak inside.
* Mutating long-lived objects → **shape churn** and hard-to-debug side effects.
* Forgetting to **normalize** string/number/boolean representations (e.g., `"3000"`).
* Serializing accessors or heavy getters unintentionally — prefer **toJSON** or explicit whitelists.

---

## Exercises

### 1) `keyMapRuntime.ts` — general key mapper

Implement a function that remaps keys based on a mapping record (string keys only) and **drops unknown symbol keys** to keep JSON-safe.

**Starter**

```ts
export function keyMapRuntime<T extends Record<string, unknown>, M extends Record<string, string>>(
  obj: T,
  map: M
): Record<string, unknown> {
  const out: Record<string, unknown> = {};
  for (const [k, v] of Object.entries(obj)) {
    const to = (map as Record<string, string>)[k] ?? k;
    out[to] = v;
  }
  return out;
}
```

---

### 2) `toDtoFromDto.ts` — snake\_case ↔ camelCase transformers

Export:

* `toDTO(u: { displayName: string; createdAt: Date; [k: string]: unknown })` → `{ display_name, created_at, ... }`
* `fromDTO(d: { display_name: string; created_at: string; [k: string]: unknown })` → normalized internal `{ displayName, createdAt: Date, ... }`

**Starter**

```ts
export function toDTO(u: any) {
  return {
    ...u,
    display_name: u.displayName,
    created_at: u.createdAt instanceof Date ? u.createdAt.toISOString() : String(u.createdAt),
  };
}

export function fromDTO(d: any) {
  return {
    ...d,
    displayName: d.display_name,
    createdAt: new Date(String(d.created_at)),
  };
}
```

---

### 3) `versionedDecode.ts` — converge V1/V2 to one shape

Accept either:

```ts
type V1 = { id: string; display_name: string; admin?: boolean; created_at: string };
type V2 = { id: string; display_name: string; created_at: string; flags?: { admin?: boolean }; _v: 2 };
```

Return `{ id, displayName, createdAt: Date, flags: { admin: boolean } }`.

**Starter**

```ts
export type Normal = { id: string; displayName: string; createdAt: Date; flags: { admin: boolean } };

export function versionedDecode(x: unknown): Normal {
  if (!x || typeof x !== "object") throw new Error("bad payload");
  const o = x as any;
  const displayName = String(o.display_name ?? "");
  const createdAt = new Date(String(o.created_at));
  const admin = o.flags?.admin ?? o.admin ?? false;
  return { id: String(o.id), displayName, createdAt, flags: { admin: !!admin } };
}
```

---

### 4) `buildConfig.ts` — exact config with defaults & freeze

Input may have `{ host?: string; port?: string | number; compact?: boolean | "true" | "false" }`. Output is frozen `{ host: string; port: number; compact: boolean }`.

**Starter**

```ts
export type Config = Readonly<{ host: string; port: number; compact: boolean }>;

export function buildConfig(input: Partial<{ host: string; port: string | number; compact: boolean | "true" | "false" }>): Config {
  const host = input.host?.trim() || "localhost";
  const port = typeof input.port === "string" ? Number(input.port) : (input.port ?? 3000);
  const compact = input.compact === "true" ? true : input.compact === "false" ? false : !!input.compact;
  return Object.freeze({ host, port, compact });
}
```

---

### 5) `redactAndWhitelist.ts` — outbound safety

Implement `whitelist(obj, keys)` and `redact(obj, pred)` where `pred(k,v)` returns `undefined` to drop a field.

**Starter**

```ts
export function whitelist(obj: object, keys: readonly string[]) {
  const out: Record<string, unknown> = Object.create(null);
  for (const k of keys) if (Object.hasOwn(obj, k)) out[k] = (obj as any)[k];
  return out;
}

export function redact(obj: object, pred: (k: string, v: unknown) => unknown) {
  const out: Record<string, unknown> = {};
  for (const [k, v] of Object.entries(obj)) {
    const r = pred(k, v);
    if (r !== undefined) out[k] = r;
  }
  return out;
}
```

---

### 6) `reducerImmutable.ts` — structural sharing + freeze

Implement a reducer for `{ count: number; name?: string }` supporting `INC(by?)`, `SET_NAME(name)`, `RESET`. Always return **frozen** state.

**Starter**

```ts
type State = Readonly<{ count: number; name?: string }>;
type Action =
  | { type: "INC"; by?: number }
  | { type: "SET_NAME"; name: string }
  | { type: "RESET" };

export function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "INC": return Object.freeze({ ...state, count: state.count + (action.by ?? 1) });
    case "SET_NAME": return Object.freeze({ ...state, name: action.name });
    case "RESET": return Object.freeze({ count: 0 });
  }
}
```

---

## Quiz (checks)

1. The safest way to ensure your **snake↔camel** type-level rename is honored at runtime is to:
   A) Rely on `as` key remapping only
   B) **Write a matching runtime mapper (e.g., `renameKeysRuntime`) and test it** ✅
   C) Spread the object and hope order matches
   D) Use `JSON.stringify`/`parse`

2. A **versioned decoder** should:
   A) Throw on any unknown key
   B) **Accept known old/new variants and normalize to one internal shape** ✅
   C) Always return the latest DTO
   D) Modify the input in place

3. For internal models, you generally prefer:
   A) Mutability for speed
   B) **Immutability + structural sharing** ✅
   C) Deep clone everything on each update
   D) Symbols for all keys

4. Outbound serialization should use:
   A) All properties on the object
   B) **An explicit whitelist and redaction policy** ✅
   C) `for…in` over the prototype chain
   D) Accessor getters for expensive fields

5. When decoding numeric fields that may arrive as strings, you should:
   A) Keep them as strings
   B) **Coerce and validate (`Number(...)`) and provide defaults** ✅
   C) Use `parseInt` everywhere
   D) Discard the field

---

## Takeaways

* Keep **type-level** transforms (rename, exactness, optionality) in lockstep with **runtime** mappers.
* Normalize inbound payloads to **one** internal shape; version adapters keep your core simple.
* Build **immutable** internal models; update via **structural sharing**, freeze in dev for safety.
* Outbound: **whitelist** + **redact**; avoid leaking secrets and accidental fields.
* Test the pipeline end-to-end: decode → model → encode produces the intended JSON.

---

## What’s next

You’ve completed **Objects** 🎉. Next up: **Strings — Fundamentals to Power Moves** (search, slice, regex basics, Unicode correctness, and composition tricks like `.split('').sort().join('')`), with cross-links to Arrays where needed.