---
id: objects-l5-record-and-index-signatures
title: "Record & Index Signatures (Advanced)"
topic: objects
level: 5
lesson: 5.1
prereqs:
  - objects-l1-index-signatures-and-shapes
  - objects-l4-entries-pairs-and-fromentries
  - objects-l4-json-serialization-replacer-reviver
outcomes:
  - Model dictionaries precisely with **`Record`**, **index signatures**, and **literal-union keys**
  - Understand **exactness** vs **open** shapes, and how `noUncheckedIndexedAccess` changes safety
  - Constrain keys using **template-literal** types and **narrowed unions** from `as const`
  - Build **exhaustive** maps from unions and detect **missing keys** at compile time
  - Use `satisfies` and `satisfies Record<...>` to preserve inferences while checking shape
tags: ["objects","typescript","record","index-signature","exactness","satisfies","template-literal","noUncheckedIndexedAccess"]
est_minutes: 45
checks:
  - type: quiz
    id: objects-l5-record-index-quiz
  - type: unit
    entry: keysOf.ts
    tests: keysOf.test.ts
  - type: unit
    entry: enumRecord.ts
    tests: enumRecord.test.ts
  - type: unit
    entry: requireAllKeys.ts
    tests: requireAllKeys.test.ts
  - type: unit
    entry: prefixRecord.ts
    tests: prefixRecord.test.ts
  - type: unit
    entry: safeGet.ts
    tests: safeGet.test.ts
---

## Why this matters

TypeScript gives you two big levers for “string → value” tables:

- **`Record<K, V>`** — exact key sets when `K` is a **union** of literals.
- **Index signatures** — open tables: `{ [k: string]: V }`.

Choosing correctly controls **what keys are allowed**, whether **missing keys** are caught, and if unchecked indexing returns **`V` vs `V | undefined`** (especially with `noUncheckedIndexedAccess`).

---

## Exact vs open shapes

### Exact key sets with `Record<Union, V>`
```ts
type Status = "idle" | "loading" | "success" | "error";
type StatusLabels = Record<Status, string>;

const labels: StatusLabels = {
  idle: "Idle",
  loading: "Loading…",
  success: "Done",
  error: "Failed"
  // Add a new Status? TS forces you to update this map. ✅
};
````

* **Pro:** Exhaustive, no stray keys, great for enums/closed sets.
* **Con:** Can’t add arbitrary keys at runtime (by type).

### Open dictionaries with index signatures

```ts
type Counts = { [key: string]: number };
const c: Counts = {};
c["/home"] = 1;           // any string accepted
c.nope = 0;               // also allowed
```

* **Pro:** Dynamic keys, flexible.
* **Con:** You *can’t* statically ensure “only these keys exist”.

> You can **combine** fixed props with an index signature, but the indexer’s value type must be compatible with the fixed props’ types.

---

## `noUncheckedIndexedAccess` (highly recommended)

When enabled, indexing with a possibly-missing key yields **`T | undefined`**:

```ts
type Dict = Record<string, number>; // or {[k:string]:number}
declare const d: Dict;

const n1: number = d["x"];      // without flag: OK (unsafe)
const n2: number | undefined = d["x"]; // with flag: safer, forces null checks
```

This is closer to JavaScript’s runtime semantics (missing → `undefined`). It nudges you toward `??` or presence checks.

---

## Preserve inference while checking shape: `satisfies`

`satisfies` validates a value against a type **without** widening its inferred literal types.

```ts
const levels = ["debug","info","warn","error"] as const;
type Level = typeof levels[number];

// Preserve exact keys & values while checking against a Record constraint
const colors = {
  debug: "#777",
  info: "#2b8a3e",
  warn: "#d9480f",
  error: "#c92a2a"
} satisfies Record<Level, string>;

// `colors` keeps specific string literals for values (no widening to string).
```

This is great for **exhaustive maps** where you also want precise value literals for downstream type logic.

---

## Template-literal key types

Derive key spaces programmatically:

```ts
type Metric = "views" | "likes";
type Prefixed = `app:${Metric}`;            // "app:views" | "app:likes"
type PrefixedRecord = Record<Prefixed, number>;

const r: PrefixedRecord = {
  "app:views": 10,
  "app:likes": 2
};
```

You can combine unions and template literals for **namespacing** or “feature-flag” style keys.

---

## From data → union (with `as const`)

A `readonly` tuple can become your source of truth for a key union:

```ts
const roles = ["admin","editor","viewer"] as const;
type Role = typeof roles[number]; // "admin" | "editor" | "viewer"

const perms = {
  admin: ["read","write","delete"],
  editor: ["read","write"],
  viewer: ["read"]
} satisfies Record<Role, string[]>;
```

Add a new role and TS points out where you need updates.

---

## Guarding completeness: compile-time checks

Create helpers that **fail** when some keys are missing:

```ts
export function requireAllKeys<
  K extends string,
  V
>(obj: Partial<Record<K, V>>, all: readonly K[]): Record<K, V> {
  // Runtime check to pair with static types
  for (const k of all) {
    if (!(k in obj)) throw new Error(`Missing key: ${k}`);
  }
  return obj as Record<K, V>;
}
```

Combine with `as const` arrays for **both** static errors (if typed) and runtime safety.

---

## Common pitfalls

* Using `{[k:string]:T}` when you really wanted **exact keys** → bugs on typos and missing keys.
* Expecting `Record<string, T>` to restrict keys — it **doesn’t**; it’s still open.
* Forgetting `noUncheckedIndexedAccess` — you’ll treat missing keys as if they’re present.
* Widening with `const obj: Record<Union, string> = { ... }` when you want literal inference → prefer `satisfies`.

---

## Patterns you’ll reuse

### Keys-of (string) helper for iteration

```ts
export function keysOf<T extends object>(o: T): Array<keyof T & string> {
  return Object.keys(o) as Array<keyof T & string>;
}
```

### Enum-like to `Record` (from tuple)

```ts
export function enumRecord<K extends readonly string[], V>(
  keys: K,
  make: (k: K[number]) => V
): Record<K[number], V> {
  const out = {} as Record<K[number], V>;
  for (const k of keys) (out as any)[k] = make(k);
  return out;
}
```

### Prefix a Record’s keys (template literal remap)

```ts
type Prefix<P extends string, K extends string> = `${P}${K}`;
export function prefixRecord<P extends string, K extends string, V>(
  prefix: P,
  r: Record<K, V>
): Record<Prefix<P, K>, V> {
  const out: any = {};
  for (const k in r) out[`${prefix}${k}`] = r[k];
  return out as Record<Prefix<P, K>, V>;
}
```

---

## Walkthrough: building a safe label map

```ts
const STATUSES = ["idle","loading","success","error"] as const;
type Status = typeof STATUSES[number];

const labels = {
  idle: "Idle",
  loading: "Loading…",
  success: "Done",
  error: "Failed"
} satisfies Record<Status, string>;

for (const k of STATUSES) {
  console.log(k, labels[k]); // k is Status; labels[k] is string
}
```

Turn it into a namespaced config:

```ts
const namespaced = prefixRecord("ui:", labels);
// type: Record<"ui:idle" | "ui:loading" | "ui:success" | "ui:error", string>
```

---

## Exercises

### 1) `keysOf(o)` — typed keys utility

Return `Array<keyof T & string>` (own enumerable string keys).

**Starter — `keysOf.ts`**

```ts
export function keysOf<T extends object>(o: T): Array<keyof T & string> {
  return Object.keys(o) as Array<keyof T & string>;
}
```

---

### 2) `enumRecord(keys, make)` — build exact `Record` from tuple

Given `keys` as `readonly string[]` (e.g., `as const`), return a `Record<K[number], V>` by calling `make(k)`.

**Starter — `enumRecord.ts`**

```ts
export function enumRecord<K extends readonly string[], V>(
  keys: K,
  make: (k: K[number]) => V
): Record<K[number], V> {
  const out = {} as Record<K[number], V>;
  for (const k of keys) (out as any)[k] = make(k);
  return out;
}
```

---

### 3) `requireAllKeys(obj, all)` — runtime + type check

Accept `obj: Partial<Record<K,V>>` and `all: readonly K[]`. If any key is missing, throw; otherwise return `Record<K,V>`.

**Starter — `requireAllKeys.ts`**

```ts
export function requireAllKeys<K extends string, V>(
  obj: Partial<Record<K, V>>,
  all: readonly K[]
): Record<K, V> {
  for (const k of all) {
    if (!(k in obj)) throw new Error(`Missing key: ${k}`);
  }
  return obj as Record<K, V>;
}
```

---

### 4) `prefixRecord(prefix, r)` — remap keys with template-literals

Build `Record<\`\${P}\${K}\`, V>`from`Record\<K, V>\`.

**Starter — `prefixRecord.ts`**

```ts
type Prefix<P extends string, K extends string> = `${P}${K}`;
export function prefixRecord<P extends string, K extends string, V>(
  prefix: P,
  r: Record<K, V>
): Record<Prefix<P, K>, V> {
  const out: any = {};
  for (const k in r) out[`${prefix}${k}`] = r[k];
  return out as Record<Prefix<P, K>, V>;
}
```

---

### 5) `safeGet(dict, key)` — reflect `noUncheckedIndexedAccess`

If `dict` has an index signature or `Record<string, V>`, return **`V | undefined`**. If `dict` is `Record<Union, V>` and `key` is that union, return **`V`**.

**Starter — `safeGet.ts`**

```ts
export function safeGet<
  D extends Record<string, any>,
  K extends string
>(dict: D, key: K):
  D extends Record<K, infer VExact> ? VExact :
  D extends Record<string, infer VAny> ? VAny | undefined :
  unknown {
  return (dict as any)[key];
}
```

> Tests will assert behavior across both exact and open records.

---

## Quiz (checks)

1. You want a compile-time error if a label is missing for one of `"red" | "green" | "blue"`. Choose:
   A) `{ [k: string]: string }`
   B) **`Record<"red" | "green" | "blue", string>`** ✅
   C) `Map<string, string>`
   D) `Record<string, string>`

2. With **`noUncheckedIndexedAccess`** enabled, indexing `Record<string, number>` with an arbitrary string yields:
   A) `number`
   B) **`number | undefined`** ✅
   C) `unknown`
   D) `never`

3. To validate a value matches `Record<Role, string>` **without** widening literal values, use:
   A) Type assertion `as Record<Role, string>`
   B) **`satisfies Record<Role, string>`** ✅
   C) Non-null assertion
   D) Enum

4. Template-literal types let you form which key space?
   A) Only characters `[A-Z]`
   B) **Concatenations like `` `api:${K}` `` when `K` is a union** ✅
   C) Random strings at runtime
   D) Symbols only

5. Which statement about `Record<string, T>` is **true**?
   A) It restricts keys to a fixed set
   B) **It allows any string key (open), just like an index signature** ✅
   C) It disables `noUncheckedIndexedAccess`
   D) It guarantees insertion order

---

## Takeaways

* **`Record<Union, V>`** enforces **exhaustive** maps; **index signatures** keep shapes open.
* Enable **`noUncheckedIndexedAccess`** to reflect reality: unknown keys → `undefined`.
* Use **`as const`** tuples → unions → `Record` to keep data & types in sync.
* Prefer **`satisfies`** to validate shape while **preserving literal inference**.
* Template-literal key types help you derive **namespaced** or patterned key sets safely.

---

## What’s next

Proceed to **Objects L5 — Exact Types & Excess Property Checks** to learn how to model exact object shapes, control inference/widening, and catch stray props with `satisfies`, `as const`, and strict object literal checks.
