---
id: objects-l5-conditional-types-advanced-remapping
title: "Conditional Types & Advanced Key Remapping"
topic: objects
level: 5
lesson: 5.3
prereqs:
  - objects-l5-utility-types-mapped-modifiers
  - objects-l5-record-and-index-signatures
outcomes:
  - "Use **conditional types** (`T extends U ? X : Y`) and understand **distributive** behavior over unions"
  - Extract keys by value kind (`KeysMatching<T, V>`, `RequiredKeys<T>`, `OptionalKeys<T>`)
  - "Build ergonomic API helpers: `AtLeast< T, K >` (require at least one), `XOR<A, B>` / `OnlyOne<T, K>` (mutually exclusive)"
  - "Remap keys **conditionally** with `as` + condition (`T[K] extends … ? … : never`)"
  - Improve readability of complex intersections with **`Prettify<T>`** (aka `Simplify`)
tags: ["objects","typescript","conditional-types","distributive","key-remapping","xor","atleast","keys-matching","mapped-types"]
est_minutes: 55
checks:
  - type: quiz
    id: objects-l5-conditional-quiz
  - type: unit
    entry: keysMatching.ts
    tests: keysMatching.test.ts
  - type: unit
    entry: requiredOptionalKeys.ts
    tests: requiredOptionalKeys.test.ts
  - type: unit
    entry: valueOf.ts
    tests: valueOf.test.ts
  - type: unit
    entry: atLeast.ts
    tests: atLeast.test.ts
  - type: unit
    entry: xor.ts
    tests: xor.test.ts
  - type: unit
    entry: conditionalRemap.ts
    tests: conditionalRemap.test.ts
---


## Why this matters

Conditional types + key remapping unlock TypeScript’s *power moves*: you can **filter keys by value**, require **at least one** option, enforce **mutually exclusive** shapes, and dynamically **rename or drop keys** based on their types—all at compile time. These patterns make your object APIs safer without runtime code.

---

## Warm-up: conditional types & distribution

Basic form:
```ts
type IfExtends<T, U, Y, N> = T extends U ? Y : N;
````

**Distributive** conditional types: if `T` is a **naked** generic in `T extends ... ? :`, then `A | B` distributes:

```ts
type ToArray<T> = T extends any ? T[] : never;
type R = ToArray<string | number>; // string[] | number[]
```

To **stop** distribution, wrap `T` (e.g., in a tuple):

```ts
type NonDistributive<T> = [T] extends [any] ? T[] : never;
type R2 = NonDistributive<string | number>; // (string | number)[]
```

---

## Keys by value kind

### `KeysMatching<T, V>`

```ts
export type KeysMatching<T, V> = {
  [K in keyof T]-?: T[K] extends V ? K : never
}[keyof T];
```

### `RequiredKeys<T>` / `OptionalKeys<T>`

```ts
export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T];

export type OptionalKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? K : never
}[keyof T];
```

### `ValueOf<T>` (aka `Values<T>`)

```ts
export type ValueOf<T> = T[keyof T];
```

---

## Conditional **key remapping** (`as`)

Filter/rename keys based on value type:

```ts
// Keep only string props
type OnlyStrings<T> = {
  [K in keyof T as T[K] extends string ? K : never]: T[K]
};

// Prefix function-valued props with "fn:"
type NamespaceFns<T> = {
  [K in keyof T as T[K] extends Function ? `fn:${Extract<K, string>}` : K]: T[K]
};
```

> Using `... as never` **drops** a key; using a template literal can **rename** it.

---

## At least one / XOR patterns

### `AtLeast<T, K>` — require at least one of K

```ts
export type AtLeast<T, K extends keyof T> =
  Partial<T> &
  { [P in K]-?: Required<Pick<T, P>> }[K]; // union of single-required variants
```

Usage:

```ts
type CreateUser = { email?: string; phone?: string; name: string };
type CreateUserReq = AtLeast<CreateUser, "email" | "phone">;
// must provide email or phone (or both)
```

### `OnlyOne<T, K>` — exactly one from K (others forbidden)

```ts
type _One<T, P extends keyof T, K extends keyof T> =
  Required<Pick<T, P>> & Partial<Record<Exclude<K, P>, never>>;

export type OnlyOne<T, K extends keyof T> =
  Omit<T, K> & { [P in K]: _One<T, P, K> }[K];
```

### `XOR<A, B>`

```ts
type Without<T, K> = { [P in Exclude<keyof T, keyof K>]?: never };
export type XOR<A, B> = (A | B) extends object
  ? (A & Without<B, A>) | (B & Without<A, B>)
  : A | B;
```

---

## Make intersections readable: `Prettify<T>`

Intersections are accurate but messy. Wrap them for display:

```ts
export type Prettify<T> = { [K in keyof T]: T[K] } & {};
// Use in IDE types: Prettify<OnlyOne<...>>
```

---

## Common pitfalls

* Forgetting that conditional types **distribute** over unions; wrap in a tuple to **stop** distribution when needed.
* Using `OnlyOne` but forgetting to **omit** the key set from the base (`Omit<T, K>`), allowing duplicates to sneak in.
* Remapping keys with `as` but not **Extract**ing to `string` when using template literals: `Extract<K,string>` avoids `string | number` issues.
* Confusing `KeysMatching<T, V>` vs `PickByValue<T, V>` (previous lesson): first returns **key union**, second returns **object**.

---

## Walkthroughs

### A) Optional vs required detection

```ts
type User = { id: string; name?: string; admin?: boolean; created: Date };
type RequiredUserKeys = RequiredKeys<User>; // "id" | "created"
type OptionalUserKeys = OptionalKeys<User>; // "name" | "admin"
```

### B) Input validation shape

```ts
type NewItem = { sku: string; upc?: string; ean?: string };
type NewItemInput = AtLeast<NewItem, "upc" | "ean">; // require at least one code
```

### C) CLI flags XOR

```ts
type FromFile = { file: string };
type FromStdin = { stdin: true };
type Source = XOR<FromFile, FromStdin>;
```

---

## Exercises

### 1) `keysMatching.ts` — get keys whose values extend V

Return a key union.

```ts
// starter
export type KeysMatching<T, V> = {
  [K in keyof T]-?: T[K] extends V ? K : never
}[keyof T];
```

---

### 2) `requiredOptionalKeys.ts` — detect required/optional

Export `RequiredKeys<T>` and `OptionalKeys<T>` as defined above.

```ts
// starter
export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T];

export type OptionalKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? K : never
}[keyof T];
```

---

### 3) `valueOf.ts` — values union

Implement `ValueOf<T>`.

```ts
// starter
export type ValueOf<T> = T[keyof T];
```

---

### 4) `atLeast.ts` — require at least one

Given `T` and key set `K`, implement `AtLeast<T, K>`.

```ts
// starter
export type AtLeast<T, K extends keyof T> =
  Partial<T> & { [P in K]-?: Required<Pick<T, P>> }[K];
```

---

### 5) `xor.ts` — mutually exclusive

Export `OnlyOne<T, K>` and `XOR<A, B>`.

```ts
// starter
type _One<T, P extends keyof T, K extends keyof T> =
  Required<Pick<T, P>> & Partial<Record<Exclude<K, P>, never>>;

export type OnlyOne<T, K extends keyof T> =
  Omit<T, K> & { [P in K]: _One<T, P, K> }[K];

type Without<T, K> = { [P in Exclude<keyof T, keyof K>]?: never };
export type XOR<A, B> = (A | B) extends object
  ? (A & Without<B, A>) | (B & Without<A, B>)
  : A | B;
```

---

### 6) `conditionalRemap.ts` — keep only string props; prefix fn props

Create two type utilities:

* `OnlyStrings<T>` — drop non-string properties
* `NamespaceFns<T>` — rename function-valued keys to `fn:<key>`

```ts
// starter
export type OnlyStrings<T> = {
  [K in keyof T as T[K] extends string ? K : never]: T[K]
};

export type NamespaceFns<T> = {
  [K in keyof T as T[K] extends Function ? `fn:${Extract<K, string>}` : K]: T[K]
};
```

---

## Quiz (checks)

1. Conditional types **distribute** over unions when:
   A) The checked type is wrapped in a tuple
   B) **The checked type is a naked generic (`T extends … ? :`)** ✅
   C) You use `infer`
   D) Never

2. Which yields a **key union** of properties whose values extend `number`?
   A) `PickByValue<T, number>`
   B) **`KeysMatching<T, number>`** ✅
   C) `ValueOf<T>`
   D) `keyof T`

3. How do you **drop** a key inside a mapped type?
   A) `as void`
   B) **Remap it `as never`** ✅
   C) Set its type to `never` without remapping
   D) Use `Exclude<T, never>`

4. `AtLeast<T, K>` typically expands to:
   A) `T` exactly
   B) **`Partial<T>` intersected with a **union** where each variant requires one `K`** ✅
   C) `Required<T>`
   D) `Omit<T, K>`

5. To prevent conditional type distribution you should:
   A) Use `infer`
   B) **Wrap the type parameter: `[T] extends [U] ? ...`** ✅
   C) Use `unknown` instead of `any`
   D) Add `readonly`

---

## Takeaways

* Conditional types power **type-level logic**; know when they **distribute** and how to stop it.
* Extracting **key unions** and **remapping conditionally** lets you tailor object types precisely.
* `AtLeast`, `OnlyOne`, and `XOR` encode common API constraints (and prevent invalid combinations).
* Use `Prettify<T>` to make complex type results readable in tooling.

---

## What’s next

Close out Objects with **Objects L5 — Practical Object Patterns (APIs & DTOs)**: combine everything—descriptors, exact records, conditional remaps, JSON serializers—into realistic, type-safe patterns for configs, DTOs, and reducers.
