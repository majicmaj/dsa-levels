---
id: objects-l5-exact-types-and-excess-checks
title: "Exact Types & Excess Property Checks"
topic: objects
level: 5
lesson: 5.2
prereqs:
  - objects-l5-record-and-index-signatures
  - objects-l3-descriptors-and-defineproperty
outcomes:
  - Explain how **object literal** assignment triggers **excess property checks** (and when it doesn’t)
  - Use **`satisfies`** and **`as const`** to validate shape while preserving literal inference
  - Enforce **no extra keys** with generic helpers (`exact<Shape>()`, `Strict<T,Shape>`)
  - Contrast **exact maps** (closed `Record<Union, V>`) vs **open** index-signature shapes
  - Catch missing keys **and** flag unexpected ones at compile time and (optionally) at runtime
tags: ["objects","typescript","excess-property-checks","satisfies","as-const","exact-types","record","index-signature"]
est_minutes: 45
checks:
  - type: quiz
    id: objects-l5-exact-excess-quiz
  - type: unit
    entry: exactHelper.ts
    tests: exactHelper.test.ts
  - type: unit
    entry: strictAssign.ts
    tests: strictAssign.test.ts
  - type: unit
    entry: makeExactRecord.ts
    tests: makeExactRecord.test.ts
  - type: unit
    entry: literalVsVariable.ts
    tests: literalVsVariable.test.ts
  - type: unit
    entry: assertNoExtraKeys.ts
    tests: assertNoExtraKeys.test.ts
---

## Why this matters

TypeScript’s **utility types** and **mapped types** let you *transform* object types: make fields optional/readonly, select/omit subsets, rename keys, or compute new key spaces. Mastering them turns repetitive shape work into small, reusable **type functions**.

---

## Mapped types & modifiers (the core idea)

A mapped type loops over keys and builds a new object type:

```ts
type Readonlyish<T> = { readonly [K in keyof T]: T[K] };
type Partialish<T>  = { [K in keyof T]?: T[K] };

// Add/remove modifiers with +/-:
type Mutable<T>     = { -readonly [K in keyof T]: T[K] };
type Requiredish<T> = { [K in keyof T]-?: T[K] };
````

* `readonly` modifier: mark props readonly (`+readonly` to add, `-readonly` to remove).
* `?` optional modifier: mark props optional (`+?` to add, `-?` to remove).

> The built-ins `Readonly<T>`, `Partial<T>`, and `Required<T>` are equivalent to the examples above.

---

## Built-in utility types (quick reference)

* `Readonly<T>` — all props readonly (shallow)
* `Partial<T>` — all props optional (shallow)
* `Required<T>` — all props required (shallow)
* `Pick<T, K>` — subset of keys
* `Omit<T, K>` — all but `K`
* `Record<K, V>` — map literal union `K` to `V` (exact when `K` is a union)

Other handy (not object-only): `NonNullable<T>`, `ReturnType<F>`, `Parameters<F>`, `InstanceType<C>`.

---

## Key **remapping** with `as`

You can rename/filter keys inside a mapped type:

```ts
// Remove keys by remapping to never:
type OmitWithAs<T, K extends PropertyKey> = {
  [P in keyof T as Exclude<P, K>]: T[P]
};

// Rename keys via a mapping record
type RenameKeys<T, Map extends Record<PropertyKey, PropertyKey>> = {
  [P in keyof T as P extends keyof Map ? Map[P] : P]: T[P]
};
```

This is the foundation for `PickByValue`, namespacing, or prefix/suffix tricks.

---

## Custom utilities you’ll reuse

### 1) `Mutable<T>` — strip readonly (shallow)

```ts
export type Mutable<T> = { -readonly [K in keyof T]: T[K] };
```

### 2) `SetOptional<T, K>` — make some keys optional

```ts
export type SetOptional<T, K extends keyof T> =
  Omit<T, K> & { [P in K]?: T[P] };
```

### 3) `PickByValue<T, V>` — keep keys whose values extend `V`

```ts
export type PickByValue<T, V> = {
  [K in keyof T as T[K] extends V ? K : never]: T[K]
};
```

### 4) `RenameKeys<T, Map>` — rename selected keys by a mapping

```ts
export type RenameKeys<T, M extends Record<PropertyKey, PropertyKey>> = {
  [K in keyof T as K extends keyof M ? M[K] : K]: T[K]
};
```

### 5) `Merge<T, U>` — right overrides left (type-level)

```ts
export type Merge<T, U> = Omit<T, keyof U> & U;
```

---

## Deep variants (pragmatic approach)

Deep utilities are tricky (functions, Maps/Sets, cycles). For **MVP**, support **plain objects & arrays**; leave other objects as-is.

```ts
export type DeepReadonly<T> =
  T extends Function ? T :
  T extends readonly (infer A)[] ? readonly DeepReadonly<A>[] :
  T extends (infer A)[] ? readonly DeepReadonly<A>[] :
  T extends object ? { readonly [K in keyof T]: DeepReadonly<T[K]> } :
  T;
```

> This is a type transformation only. It doesn’t freeze at runtime (pair with `deepFreeze` from earlier lesson for behavior).

---

## Patterns

### Optional subset then merge back

```ts
type User = { id: string; name: string; email?: string; admin?: boolean };
type Editable = SetOptional<User, "email" | "admin">; // both optional regardless of original
```

### Narrow object by value kind

```ts
type OnlyFns<T> = PickByValue<T, (...args: any) => any>;
```

### Rename for API boundaries

```ts
type ClientUser = { id: string; createdAt: string };
type ServerUser = RenameKeys<ClientUser, { createdAt: "created_at" }>;
```

---

## Common pitfalls

* **Deep vs shallow**: built-ins are **shallow**. Don’t expect nested props to change.
* `Readonly<T>` does not prevent **methods** from mutating internals; it marks properties as read-only at the type level.
* Key remapping with `as` only affects **type names**, not runtime behavior—ensure your transforms are mirrored in code if needed.
* `Merge<T,U>` is order-sensitive; `U` wins. Keep `Omit<T, keyof U> & U` in mind.

---

## Walkthrough: “DTO shapes” from domain models

```ts
type User = {
  id: string;
  name: string;
  email: string;
  meta: { flags: string[] };
  createdAt: Date;
};

type UserDTO =
  RenameKeys<
    Pick<User, "id" | "name" | "email" | "createdAt">,
    { createdAt: "created_at" }
  > & {
    meta?: never; // explicitly not allowed
  };

// At runtime you’d map `createdAt` to ISO string and drop `meta`.
```

---

## Exercises

### 1) `mutable.ts` — implement `Mutable<T>`

Remove readonly from all properties (shallow).

**Starter**

```ts
export type Mutable<T> = { -readonly [K in keyof T]: T[K] };
```

---

### 2) `setOptional.ts` — implement `SetOptional<T, K>`

Make keys `K` optional; keep others unchanged.

**Starter**

```ts
export type SetOptional<T, K extends keyof T> =
  Omit<T, K> & { [P in K]?: T[P] };
```

---

### 3) `pickByValue.ts` — implement `PickByValue<T, V>`

Keep only properties whose value type extends `V`.

**Starter**

```ts
export type PickByValue<T, V> = {
  [K in keyof T as T[K] extends V ? K : never]: T[K]
};
```

---

### 4) `renameKeys.ts` — implement `RenameKeys<T, Map>`

Rename keys using a mapping record (missing mapping → keep key).

**Starter**

```ts
export type RenameKeys<T, M extends Record<PropertyKey, PropertyKey>> = {
  [K in keyof T as K extends keyof M ? M[K] : K]: T[K]
};
```

---

### 5) `deepReadonly.ts` — implement `DeepReadonly<T>` (arrays + plain objects)

Functions unchanged; arrays become `readonly` arrays; recurse into objects.

**Starter**

```ts
export type DeepReadonly<T> =
  T extends Function ? T :
  T extends readonly (infer A)[] ? readonly DeepReadonly<A>[] :
  T extends (infer A)[] ? readonly DeepReadonly<A>[] :
  T extends object ? { readonly [K in keyof T]: DeepReadonly<T[K]> } :
  T;
```

---

### 6) `merge.ts` — implement `Merge<T, U>`

Right-hand side overrides left for overlapping keys.

**Starter**

```ts
export type Merge<T, U> = Omit<T, keyof U> & U;
```

---

## Quiz (checks)

1. Which mapped-type syntax **removes** optional from all props?
   A) `{ [K in keyof T]+?: T[K] }`
   B) **`{ [K in keyof T]-?: T[K] }`** ✅
   C) `{ -readonly [K in keyof T]: T[K] }`
   D) `{ readonly [K in keyof T]: T[K] }`

2. `Readonly<T>` affects:
   A) Nested objects deeply
   B) **Only the top level (shallow)** ✅
   C) Runtime mutation
   D) Class methods

3. To **rename** `createdAt` → `created_at` at the type level, you should use:
   A) `Pick` + `Omit` only
   B) `Partial`
   C) **Mapped type with `as` key remapping** ✅
   D) `Record`

4. `PickByValue<{a:number;b:string;c:number}, number>` yields keys:
   A) `a` only
   B) **`a | c`** ✅
   C) `b` only
   D) `a | b | c`

5. Which is a correct **deep-readonly** array rule?
   A) `T extends any[] ? T : never`
   B) **`T extends (infer A)[] ? readonly DeepReadonly<A>[] : ...`** ✅
   C) `readonly T[]`
   D) `DeepReadonly<T>[]`

---

## Takeaways

* Mapped types + `+/-` modifiers power `Readonly/Partial/Required` and your own **custom** utilities.
* **Key remapping** with `as` lets you filter/rename keys at the type level.
* Deep variants should be **purpose-built** (decide how to treat arrays, functions, special objects).
* Keep runtime ↔ type transforms in sync—types don’t change runtime data automatically.

---

## What’s next

Head to **Objects L5 — Conditional Types & Key Remapping (Advanced Patterns)**: distribute over unions, extract keys by value, build `AtLeast<T, K>`, `XOR`, and ergonomic API types using `infer` and conditional logic.