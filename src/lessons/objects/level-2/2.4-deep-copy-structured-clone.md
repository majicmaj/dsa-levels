---
id: objects-l2-deep-copy-structured-clone
title: "Deep Copy Intro (structuredClone, JSON tricks, caveats)"
topic: objects
level: 2
lesson: 2.4
prereqs:
  - objects-l2-assign-spread-rest-shallow-copy
  - objects-l2-enumeration-order-caveats
outcomes:
  - Explain **shallow vs deep** copy and why spread/assign are shallow
  - Use **`structuredClone`** for robust deep copies (supports Maps/Sets/Dates/RegExps/TypedArrays, cyclic graphs)
  - Know what **is not** cloneable (functions, DOM nodes, WeakMap/WeakSet, closures) and how to handle it
  - Compare **JSON round-trip** to `structuredClone` and understand data loss & errors (e.g., `Date`, `BigInt`, cycles)
  - Perform **zero-copy buffer transfer** with `structuredClone(value, { transfer })` when appropriate
tags: ["objects","deep-copy","structuredClone","JSON","cycles","map","set","typedarray","transfer"]
est_minutes: 35
checks:
  - type: quiz
    id: objects-l2-deep-copy-quiz
  - type: unit
    entry: deepCopy.ts
    tests: deepCopy.test.ts
  - type: unit
    entry: copyMapSetManually.ts
    tests: copyMapSetManually.test.ts
  - type: unit
    entry: jsonDateRoundTrip.ts
    tests: jsonDateRoundTrip.test.ts
  - type: unit
    entry: cyclicClone.ts
    tests: cyclicClone.test.ts
  - type: unit
    entry: transferBuffer.ts
    tests: transferBuffer.test.ts
---

## Why this matters

Spread/assign give **shallow** copies; nested objects/arrays remain shared. For safe transformations, snapshotting state, worker messages, or defensive copying, you need a **deep** copy that preserves structure without keeping references to the original graph.

---

## Shallow vs deep (quick recap)

```ts
const a = { inner: { n: 1 } };
const b = { ...a };       // shallow
b.inner.n = 2;            // mutates a.inner too
````

**Deep copy** duplicates nested containers so changes don’t leak across boundaries.

---

## `structuredClone` at a glance

`structuredClone(value, options?)` performs a **deep clone** of many built-in types and handles **cycles**.

**Generally supported:**

* Plain objects/arrays (including cycles)
* `Map`, `Set`
* `Date`, `RegExp`
* `ArrayBuffer`, `DataView`, **TypedArrays** (`Float32Array`, etc.)
* `BigInt`, `Error` objects (data only)
* File/Blob/ImageData (browser environments)

**Not supported (throws `DataCloneError`):**

* **Functions**, class instances with behavior (methods are just functions)
* **WeakMap/WeakSet**
* DOM nodes (unless environment adds support)
* Objects with **properties that are functions** (those properties cause an error if encountered as values)

> Availability: modern browsers and recent Node have a global `structuredClone`. If not, you’ll need a polyfill or a fallback strategy (see below).

---

## Cycles: handled

```ts
const a: any = { name: "A" };
a.self = a;
const clone = structuredClone(a);
clone.self === clone; // true
```

`JSON.stringify(a)` would throw on the cycle.

---

## Maps/Sets, Dates, RegExps: preserved

```ts
const src = {
  m: new Map([["x", 1]]),
  s: new Set([1, 2]),
  d: new Date(0),
  r: /foo/gi
};
const c = structuredClone(src);
c.m.get("x") === 1;
c.s.has(2) === true;
c.d.getTime() === 0;
c.r.source === "foo" && c.r.flags.includes("g");
```

---

## Transfer for zero-copy buffers (advanced)

You can **transfer** ownership of `ArrayBuffer`-backed data during clone:

```ts
const buf = new ArrayBuffer(8);
const view = new Uint8Array(buf);
view[0] = 123;

const cloned = structuredClone(view, { transfer: [view.buffer] });
// After transfer, the original buffer may be **detached** (length 0)
```

Use when moving large binary data between threads/workers—don’t transfer unless you’re done with the source buffer.

---

## JSON round-trip vs `structuredClone`

**JSON approach**

```ts
const copy = JSON.parse(JSON.stringify(value));
```

**Pros:** ubiquitous, tiny.
**Cons:** drops or changes data:

* Loses `Date` (becomes ISO string), `Map`/`Set` (turn into plain objects/arrays), `RegExp`, `BigInt` (throws), `undefined` (omitted), `Infinity`/`NaN` (become `null`), and **cycles** (throws).

Use JSON only for simple, JSON-shaped data you intend to **serialize** anyway.

---

## Fallback pattern (safe-ish)

When you *prefer* `structuredClone` but need to run in mixed environments:

```ts
export function deepCopy<T>(value: T): T {
  if (typeof globalThis.structuredClone === "function") {
    return structuredClone(value);
  }
  // Last-resort fallback for JSON-shaped data only:
  return JSON.parse(JSON.stringify(value)) as T;
}
```

> Document the limitations of the fallback (no cycles, dates/maps/sets altered, `BigInt` unsupported).

---

## Common pitfalls

* Assuming deep copy keeps **methods/accessors**: clone targets are **data** only; functions are not cloned.
* Expecting JSON to preserve `Date`, `Map`, `Set`, `BigInt`, or handle cycles—it won’t.
* Forgetting to **transfer** buffers when performance matters (large binary payloads across threads).
* Relying on deep clone for **class instances**—you usually want a **domain-level copy constructor** or serializer instead.

---

## Walkthrough: resilient deep copy helper

```ts
export function deepCopySafe<T>(value: T): T {
  if (typeof structuredClone === "function") return structuredClone(value);
  // If you know your data is JSON-compatible, allow fallback; otherwise throw for clarity:
  throw new Error("structuredClone not available and fallback disabled");
}
```

Decide **policy** up front: fail fast vs lossy fallback.

---

## Exercises

### 1) `deepCopy(value)` — prefer structuredClone, fallback to JSON

Return a deep copy of `value`. If `structuredClone` exists, use it; otherwise use JSON **only** when the value is JSON-safe; if serialization fails, rethrow.

**Starter — `deepCopy.ts`**

```ts
export function deepCopy<T>(value: T): T {
  if (typeof (globalThis as any).structuredClone === "function") {
    return (globalThis as any).structuredClone(value);
  }
  try {
    return JSON.parse(JSON.stringify(value)) as T;
  } catch (err) {
    throw new Error("Deep copy failed: structuredClone unavailable and JSON round-trip failed.");
  }
}
```

---

### 2) `copyMapSetManually(src)` — manual deep copy as a learning aid

Given `{ m: Map<unknown, unknown>, s: Set<unknown> }`, produce a deep copy **without** `structuredClone`:

* Recreate `Map`/`Set` shallowly (keys/values copied by reference is OK for this exercise)
* Preserve contents and sizes.

**Starter — `copyMapSetManually.ts`**

```ts
export function copyMapSetManually(src: { m: Map<any, any>; s: Set<any> }) {
  return {
    m: new Map(src.m),
    s: new Set(src.s),
  };
}
```

---

### 3) `jsonDateRoundTrip` — keep Dates through JSON

Implement a pair:

* `toJsonWithDates(x)` — uses a **replacer** to encode `Date` as `{__type:"Date", value: ISO}`
* `fromJsonWithDates(str)` — uses a **reviver** to decode back to `Date`

**Starter — `jsonDateRoundTrip.ts`**

```ts
export function toJsonWithDates(x: unknown): string {
  return JSON.stringify(x, (_k, v) => v instanceof Date ? { __type: "Date", value: v.toISOString() } : v);
}

export function fromJsonWithDates(s: string): unknown {
  return JSON.parse(s, (_k, v) => (v && v.__type === "Date") ? new Date(v.value) : v);
}
```

---

### 4) `cyclicClone(obj)` — prove cycles work with structuredClone

Return a deep clone using `structuredClone`. If not available, throw a clear error (don’t try JSON).

**Starter — `cyclicClone.ts`**

```ts
export function cyclicClone<T>(obj: T): T {
  if (typeof (globalThis as any).structuredClone !== "function") {
    throw new Error("structuredClone required for cyclic graphs.");
  }
  return (globalThis as any).structuredClone(obj);
}
```

---

### 5) `transferBuffer(view)` — transfer a TypedArray’s buffer

* Accept a `Uint8Array` (or any TypedArray)
* Clone with `structuredClone(view, { transfer: [view.buffer] })`
* Return `{ cloned, detachedSourceByteLength }` where `detachedSourceByteLength` reflects the source after transfer (often `0`)

**Starter — `transferBuffer.ts`**

```ts
export function transferBuffer(view: Uint8Array) {
  if (typeof (globalThis as any).structuredClone !== "function") {
    throw new Error("structuredClone with transfer is required.");
  }
  const cloned = (globalThis as any).structuredClone(view, { transfer: [view.buffer] });
  // In environments that support transfer, the original buffer becomes detached.
  const detachedSourceByteLength = view.byteLength;
  return { cloned, detachedSourceByteLength };
}
```

---

## Quiz (checks)

1. Which **does** `structuredClone` handle out of the box? *(choose all)*

* `Map` ✅
* `Set` ✅
* `Date` ✅
* **Functions** ❌

2. What happens when cloning a cyclic object with `JSON.stringify`?
   A) It works but is slow
   B) It drops the cycle
   C) **It throws** ✅
   D) It replaces cycles with `null`

3. Which statement about **transfer** is true?
   A) It makes the clone faster but keeps the source usable
   B) **It can **detach** the original buffer so the clone owns the memory** ✅
   C) It only works for `RegExp`
   D) It’s the default behavior for all objects

4. JSON round-trip will:
   A) Preserve `Date` as `Date`
   B) Keep `BigInt` by stringifying it
   C) **Drop `undefined` and convert `NaN/Infinity` to `null`** ✅
   D) Preserve `Map` as `Map`

5. Which is **not** cloneable by `structuredClone`?
   A) `RegExp`
   B) **`WeakMap`** ✅
   C) `ArrayBuffer`
   D) `Float32Array`

---

## Takeaways

* Prefer **`structuredClone`** for deep copy: it handles many built-ins and cycles.
* Use **JSON** only for JSON-shaped data you intend to serialize; it loses types & fails on cycles.
* For large binary data across threads, consider **transfer** to avoid copying.
* Don’t rely on deep clone for class instances or behavior—use **domain-specific serializers** or copy constructors.

---

## What’s next

Level 3 begins: **Objects L3 — Property Descriptors & `defineProperty`** to control enumerability/writability/configurability, create getters/setters, and build minimal dictionaries with `Object.create(null)`.
