---
id: objects-l2-assign-spread-rest-shallow-copy
title: "Assign, Spread & Rest (Shallow Copy Semantics)"
topic: objects
level: 2
lesson: 2.2
prereqs:
  - objects-l2-keys-values-entries-hasown
  - objects-l1-delete-and-shapes
outcomes:
  - Predict exactly what **`Object.assign`** and **spread** `{...src}` copy (own, enumerable props; string **and** symbol)
  - Understand precedence/overwrite rules when merging (`right` wins), and how getters are **invoked** during copy
  - Use **object rest** `{a, ...rest}` to implement **immutable omit** patterns
  - Know what is **not** copied (prototype, non-enumerables, accessors vs data) and why copies are **shallow**
  - Choose between assign/spread/rest idioms in reducers and utility helpers
tags: ["objects","assign","spread","rest","merge","shallow-copy","enumerable","symbols"]
est_minutes: 35
checks:
  - type: quiz
    id: objects-l2-assign-spread-quiz
  - type: unit
    entry: mergeRight.ts
    tests: mergeRight.test.ts
  - type: unit
    entry: cloneShallow.ts
    tests: cloneShallow.test.ts
  - type: unit
    entry: omitRest.ts
    tests: omitRest.test.ts
  - type: unit
    entry: assignVsSpreadGetters.ts
    tests: assignVsSpreadGetters.test.ts
---

## Why this matters

Copying and merging objects sits at the heart of reducers, config shaping, and API payloads. Small misunderstandings—like **getters running** during copy, or **non-enumerable** props being skipped—cause subtle bugs. This lesson makes the rules crisp so you can refactor with confidence.

---

## Copying with `Object.assign` vs spread `{...src}`

**Both** do a **shallow** copy of **own, enumerable** properties (string **and** symbol) **from sources to a target**.

```ts
const src = { a: 1 };
const c1 = { ...src };                 // spread: new object target
const c2 = Object.assign({}, src);     // assign: same result
````

### Overwrite/precedence (merge)

Rightmost wins. Later sources overwrite earlier ones **per property key**.

```ts
const a = { x: 1, y: 1 };
const b = { y: 2, z: 2 };
const m1 = { ...a, ...b };                 // { x:1, y:2, z:2 }
const m2 = Object.assign({}, a, b);        // same shape
```

### Getters are **invoked**, descriptors are **flattened**

During copy, values are **read** from the source (invoking getters) and **defined as data properties** on the target (accessors lost).

```ts
const src2 = {
  get price() { console.log("getter"); return 99; },
};
const out = { ...src2 };            // logs "getter"
Object.getOwnPropertyDescriptor(out, "price")!.get; // undefined (now data prop)
```

### Non-enumerables are **skipped**

If you define a property as non-enumerable, neither spread nor assign will copy it.

```ts
const o = {};
Object.defineProperty(o, "hidden", { value: 42, enumerable: false });
({ ...o }).hidden; // undefined
```

### Prototype is **not** copied

Targets are plain objects unless you explicitly choose a different one as the first argument to `assign`:

```ts
const proto = { p: 0 };
const t = Object.assign(Object.create(proto), { x: 1 }); // t.__proto__ === proto
```

---

## Object **rest** for immutable omit

Use computed rest to drop keys without mutating:

```ts
function omitRest<T extends object, K extends keyof T>(obj: T, key: K): Omit<T, K> {
  const { [key]: _omit, ...rest } = obj as any;
  return rest as Omit<T, K>;
}

const user = { id: 1, name: "Amina", token: "…" };
omitRest(user, "token"); // { id:1, name:"Amina" }
```

Multiple keys? Pair rest with `Object.fromEntries` or filter:

```ts
function omitMany<T extends object, K extends readonly (keyof T)[]>(
  obj: T, keys: K
): Omit<T, K[number]> {
  const kill = new Set<PropertyKey>(keys as readonly PropertyKey[]);
  return Object.fromEntries(Object.entries(obj).filter(([k]) => !kill.has(k))) as any;
}
```

---

## Shallow means references are shared

Nested objects/arrays are **not cloned**—only their references are copied.

```ts
const a = { inner: { n: 1 } };
const b = { ...a };
b.inner.n = 2;
a.inner.n; // 2 — same object
```

For deep/nested copies, see the next lesson on `structuredClone` and patterns.

---

## Symbols are included (if enumerable)

```ts
const s = Symbol("m");
const src = { [s]: 5, x: 1 };
const c = { ...src };
Reflect.ownKeys(c); // ["x", Symbol(m)]
```

---

## Common pitfalls

* Expecting assign/spread to copy **non-enumerable** props — they don’t.
* Assuming **getters** survive as getters — they’re evaluated and become **data**.
* Forgetting merges are **right-winning** per key; order matters.
* Mistaking a shallow copy for deep—nested structures remain shared.

---

## Walkthrough: safe config merge with defaults

Order your spreads so **defaults** appear left, **user overrides** right:

```ts
const defaults = { retries: 3, host: "localhost" };
function mergeCfg(user: Partial<typeof defaults>) {
  return { ...defaults, ...user }; // user keys win
}
```

Attach **non-enumerable** metadata that won’t leak in spreads:

```ts
function withMeta<T extends object>(obj: T, meta: unknown): T {
  return Object.defineProperty({ ...obj }, Symbol.for("meta"), {
    value: meta, enumerable: false
  });
}
```

---

## Exercises

### 1) `mergeRight(...objs)` — rightmost wins

Create a new object merging all inputs left→right without mutating arguments. Preserve symbols if enumerable.

**Starter — `mergeRight.ts`**

```ts
export function mergeRight<T extends object[]>(...objs: T): Record<string | symbol, unknown> {
  return Object.assign({}, ...objs);
}
```

---

### 2) `cloneShallow(src)` — plain shallow clone

Return a new plain object with src’s **own enumerable** props (string+symbol). Prototype is not preserved.

**Starter — `cloneShallow.ts`**

```ts
export function cloneShallow<T extends object>(src: T): T {
  return { ...src };
}
```

---

### 3) `omitRest(obj, key)` — immutable omit with rest

Drop a single key using **computed rest**.

**Starter — `omitRest.ts`**

```ts
export function omitRest<T extends object, K extends keyof T>(obj: T, key: K): Omit<T, K> {
  const { [key]: _omit, ...rest } = obj as any;
  return rest as Omit<T, K>;
}
```

---

### 4) `assignVsSpreadGetters()` — observe getter behavior

Export a function that:

* Defines an object with a getter.
* Copies it with both assign and spread.
* Returns booleans indicating whether the target’s property is a **data property** (no getter) and whether the getter ran.

**Starter — `assignVsSpreadGetters.ts`**

```ts
export function assignVsSpreadGetters() {
  let called = 0;
  const src = {
    get v() { called++; return 7; }
  };
  const a = Object.assign({}, src);
  const b = { ...src };
  const aHasGetter = !!Object.getOwnPropertyDescriptor(a, "v")!.get;
  const bHasGetter = !!Object.getOwnPropertyDescriptor(b, "v")!.get;
  return { called, aHasGetter, bHasGetter, aValue: a.v, bValue: b.v };
}
```

---

## Quiz (checks)

1. `{...a, ...b}` resolves key conflicts by:
   A) Keeping the left value
   B) **Overwriting with the right value** ✅
   C) Merging objects deeply
   D) Throwing on duplicates

2. When copying from a source that has a **getter** for `x`:
   A) The getter is copied as a getter
   B) **The getter runs; the target gets a data property `x`** ✅
   C) The getter is skipped
   D) It becomes non-enumerable

3. Spread / `Object.assign` copy which props?
   A) All props including prototype
   B) **Own, enumerable, string & symbol** ✅
   C) Own non-enumerables only
   D) Prototype + own

4. Object **rest** `{ [key]: _, ...rest } = obj` is useful for:
   A) Mutating the input
   B) **Building an immutable object without a key** ✅
   C) Deep cloning
   D) Preserving accessors

5. Shallow copy means:
   A) Nested objects are cloned recursively
   B) **References for nested objects/arrays are reused** ✅
   C) Symbols are dropped
   D) Descriptors are preserved exactly

---

## Takeaways

* **Spread** and **assign** are equivalent for shallow copies of own+enumerable props; **order matters** when merging.
* Getters run during copy; targets receive **data properties**, not accessors.
* Use **rest** for clean immutable omit; reach for `fromEntries` when omitting multiple keys dynamically.
* Copies are **shallow** by default—deep strategies (e.g., `structuredClone`) come next.

---

## What’s next

Continue to **Objects L2 — Enumeration Order & Edge Cases** to solidify ordering rules, inherited vs own pitfalls, and symbol/non-enumerable handling across different APIs—then we’ll finish L2 with **Deep Copy Intro (`structuredClone`)**.
