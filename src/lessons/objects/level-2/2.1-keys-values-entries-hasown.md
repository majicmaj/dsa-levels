---
id: objects-l2-keys-values-entries-hasown
title: "Keys/Values/Entries & Ownness"
topic: objects
level: 2
lesson: 2.1
prereqs:
  - objects-l1-overview-and-literals
  - objects-l1-property-access
  - objects-l1-existence-optional-nullish
  - objects-l1-delete-and-shapes
outcomes:
  - Iterate **own enumerable** properties with `Object.keys/values/entries`
  - Distinguish **own** vs **inherited** properties and use `Object.hasOwn` correctly
  - List **non-enumerable** and **symbol** keys with `Object.getOwnPropertyNames`, `Object.getOwnPropertySymbols`, `Reflect.ownKeys`
  - Understand **enumeration order** rules (integer-like first, then strings, then symbols)
  - Clone and merge **shallowly** with spread/`Object.assign` and know what gets copied
tags: ["objects","enumeration","hasOwn","entries","symbols","non-enumerable","clone","merge"]
est_minutes: 35
checks:
  - type: quiz
    id: objects-l2-keys-values-entries-quiz
  - type: unit
    entry: ownEntries.ts
    tests: ownEntries.test.ts
  - type: unit
    entry: entriesToObject.ts
    tests: entriesToObject.test.ts
  - type: unit
    entry: listOwnProps.ts
    tests: listOwnProps.test.ts
  - type: unit
    entry: shallowClone.ts
    tests: shallowClone.test.ts
  - type: unit
    entry: mergeRight.ts
    tests: mergeRight.test.ts
---

## Why this matters

Most real work with objects is **enumeration** and **transformation**: turning objects into arrays (to sort, filter, map) and back again, while carefully avoiding prototype surprises. This lesson gives you a precise toolkit and teaches what’s *actually* included by each API.

---

## The big three (own + enumerable + string-keyed)

```ts
Object.keys(obj)    // -> string[]        (own, enumerable, strings only)
Object.values(obj)  // -> any[]           (own, enumerable, strings only)
Object.entries(obj) // -> [string, any][] (own, enumerable, strings only)
````

* They **ignore**:

  * properties found on the **prototype chain**
  * **non-enumerable** properties
  * **symbol**-keyed properties

> If you need symbols or non-enumerables, see below.

---

## Ownness & prototypes (recap)

* `"k" in obj` → **own OR inherited**.
* `Object.hasOwn(obj, "k")` → **own only**.
* Enumeration with `for…in` walks **enumerable** string keys across the chain (⚠️ includes inherited; **skips symbols**).

Prefer the **big three** for predictable iteration of *your own data*.

---

## Seeing everything: non-enumerables & symbols

```ts
Object.getOwnPropertyNames(obj)  // own STRING keys, enumerable + non-enumerable
Object.getOwnPropertySymbols(obj) // own SYMBOL keys (any enumerability)
Reflect.ownKeys(obj)              // own keys: strings + symbols, enumerable + non-enumerable
```

> Use `Reflect.ownKeys` when you truly need *all* own keys (e.g., meta work, libraries).

---

## Enumeration order (important)

When producing arrays (keys/entries/Reflect.ownKeys), engines use a well-defined order:

1. **Integer-like** string keys (`"0"`, `"1"`, …) in **ascending numeric** order
2. Other **string** keys in **insertion** order
3. **Symbol** keys in **insertion** order

This matters when you rely on presentation order or do object → entries → object round-trips.

---

## Shallow cloning & merging (what gets copied)

* **Spread** `{...a}` and **`Object.assign({}, a)`** copy **own, enumerable** **string AND symbol** properties.
* They do **not** copy the prototype; getters **run** if present (copying their returned values).
* It’s **shallow**: nested objects/arrays are copied by reference.

```ts
const clone = { ...src }; // same as Object.assign({}, src)
const merged = Object.assign({}, a, b, c); // later overwrite earlier
// or: const merged = { ...a, ...b, ...c };
```

---

## Patterns you’ll reuse

### Map over entries, back to object

```ts
const doubled = Object.fromEntries(
  Object.entries(prices).map(([k, v]) => [k, v * 2])
);
```

### Like `Object.entries` but with a guard

```ts
function ownEntries<T extends object>(o: T): Array<[keyof T & string, unknown]> {
  return Object.keys(o).map(k => [k, (o as any)[k]]);
}
```

---

## Common pitfalls

* Using `for…in` and forgetting it includes **inherited** keys (and skips **symbols**).
* Expecting `Object.keys` to include **non-enumerable** or **symbol** properties.
* Assuming spread copies **deeply**—it’s shallow.
* Being surprised by **integer-like** keys jumping to the front.

---

## Walkthrough: include symbol props when cloning

```ts
const sym = Symbol("meta");
const a = { x: 1, [sym]: 42 };
const b = { ...a };               // includes sym because it’s enumerable
Object.getOwnPropertyDescriptor(a, sym)!.enumerable; // true by default on literals
```

> If you explicitly define a **non-enumerable** property with `defineProperty`, spread/assign won’t copy it.

---

## Exercises

### 1) `ownEntries(obj)` — entries via keys

Return own-enumerable **string-keyed** entries as `[key, value][]`.

**Starter — `ownEntries.ts`**

```ts
export function ownEntries<T extends object>(
  obj: T
): Array<[keyof T & string, unknown]> {
  // Use Object.keys to avoid prototype keys; then read values
  return [];
}
```

---

### 2) `entriesToObject(entries)` — fromEntries poly

Build a new object from `[key, value][]`. Assume keys are strings.

**Starter — `entriesToObject.ts`**

```ts
export function entriesToObject<K extends string, V>(
  entries: Array<[K, V]>
): Record<K, V> {
  const out = {} as Record<K, V>;
  for (const [k, v] of entries) {
    (out as any)[k] = v;
  }
  return out;
}
```

---

### 3) `listOwnProps(obj)` — audit keys

Return an object with:

* `keys: string[]`
* `values: unknown[]`
* `entries: Array<[string, unknown]>`
* `names: string[]` (includes non-enumerable strings)
* `symbols: symbol[]`
* `allKeys: Array<string | symbol>` (Reflect.ownKeys order)

**Starter — `listOwnProps.ts`**

```ts
export function listOwnProps(obj: object) {
  const keys = Object.keys(obj);
  const values = Object.values(obj);
  const entries = Object.entries(obj);
  const names = Object.getOwnPropertyNames(obj);
  const symbols = Object.getOwnPropertySymbols(obj);
  const allKeys = Reflect.ownKeys(obj);
  return { keys, values, entries, names, symbols, allKeys };
}
```

---

### 4) `shallowClone(src)` — copy own enumerable (string + symbol)

Implement via spread or `Object.assign`.

**Starter — `shallowClone.ts`**

```ts
export function shallowClone<T extends object>(src: T): T {
  // Copy own, enumerable string+symbol keys; do not preserve prototype
  return { ...src };
}
```

---

### 5) `mergeRight(...objs)` — later overwrites earlier

Return a **new** object merging all inputs left→right. Don’t mutate arguments.

**Starter — `mergeRight.ts`**

```ts
export function mergeRight<T extends object[]>(...objs: T): Record<string, unknown> {
  return Object.assign({}, ...objs);
}
```

---

## Quiz (checks)

1. `Object.entries(obj)` includes which keys?
   A) All keys including prototype
   B) **Own, enumerable, string-keyed only** ✅
   C) Own, enumerable, string + symbol
   D) Everything

2. Which API returns **all own keys** (strings + symbols, enumerable + non-enumerable)?
   A) `Object.keys`
   B) `Object.getOwnPropertyNames`
   C) **`Reflect.ownKeys`** ✅
   D) `for…in`

3. `for…in` will iterate:
   A) **Enumerable string keys from own + prototype** ✅
   B) Symbols only
   C) Non-enumerables too
   D) Own keys only

4. Enumeration order for `Object.keys` is:
   A) Insertion order for all keys
   B) Random
   C) **Integer-like strings ascending, then other strings in insertion order** ✅
   D) Symbols first, then strings

5. Spread `{...a}` copies:
   A) Prototype + own keys
   B) **Own, enumerable string + symbol props (shallowly)** ✅
   C) Non-enumerables too
   D) Deep clones nested objects

---

## Takeaways

* Use `Object.keys/values/entries` for **own enumerable string** properties.
* Reach for `Reflect.ownKeys` when you truly need **everything**.
* Prefer `Object.hasOwn` to check presence on the object itself.
* Spread/`assign` perform **shallow** copies of **own enumerable** props (string + symbol), not prototypes.

---

## What’s next

Head to **Objects L2 — Assign, Spread & Rest (Shallow Copy)** to dive deeper into copy/merge semantics, getters vs data properties, and immutability-friendly patterns.
