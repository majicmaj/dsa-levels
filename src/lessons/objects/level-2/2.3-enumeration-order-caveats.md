---
id: objects-l2-enumeration-order-caveats
title: "Enumeration Order & Edge Cases"
topic: objects
level: 2
lesson: 2.3
prereqs:
  - objects-l2-keys-values-entries-hasown
  - objects-l2-assign-spread-rest-shallow-copy
outcomes:
  - Predict enumeration order for **Object.keys / values / entries**
  - Explain differences between **for…in**, `Reflect.ownKeys`, and the “big three”
  - Handle **integer-like** keys, **non-enumerables**, and **symbols** correctly
  - Round-trip objects ↔ entries arrays **without** losing intended order
  - Build utilities that expose **stable, explicit** ordering semantics
tags: ["objects","enumeration","order","symbols","non-enumerable","reflect","entries"]
est_minutes: 30
checks:
  - type: quiz
    id: objects-l2-order-quiz
  - type: unit
    entry: stableKeyOrder.ts
    tests: stableKeyOrder.test.ts
  - type: unit
    entry: ownEntriesAll.ts
    tests: ownEntriesAll.test.ts
  - type: unit
    entry: entriesRoundTrip.ts
    tests: entriesRoundTrip.test.ts
  - type: unit
    entry: copyIncludingNonEnumerable.ts
    tests: copyIncludingNonEnumerable.test.ts
---

## Why this matters

You’ll often turn objects into arrays to sort or display, then rebuild them. If you don’t know **exactly** how JS orders keys, you’ll get “why did 0,1,2 jump to the top?” or “where did my symbol go?” bugs. Let’s make the rules mechanical.

---

## The ordering rules (for own keys → arrays)

When an API returns an **array of keys** for an object, modern engines follow this order:

1) **Integer-like** string keys (`"0"`, `"1"`, …) in **ascending numeric** order  
2) Other **string** keys in **insertion** order  
3) **Symbol** keys in **insertion** order

Where each API fits:

- `Object.keys / values / entries` → own **enumerable** **string** keys only → applies rules 1–2.
- `Reflect.ownKeys` → own **strings + symbols**, enumerable + non-enumerable → applies 1–3.
- `Object.getOwnPropertyNames` → own **string** keys (enumerable + non-enumerable) → applies 1–2.
- `Object.getOwnPropertySymbols` → own **symbol** keys (any enumerability) → insertion order within symbols.

> **for…in** is different: it iterates **enumerable string** keys from **own + prototype chain** using the same string ordering per object visited, then continues up the chain. It **skips symbols**.

---

## Integer-like keys (the surprising bit)

```ts
const o = { b: 1, "10": "ten", "2": "two", a: 0 };
Object.keys(o);     // ["2", "10", "b", "a"]  ← numbers first (ascending), then insertion
````

This affects tables that display row numbers or indices stored as object keys.

**Tip:** If you want **pure insertion** order regardless of numberiness, keep data as an **array of pairs** or use a **Map**.

---

## Non-enumerable properties don’t show up (by design)

```ts
const o: any = { a: 1 };
Object.defineProperty(o, "hidden", { value: 42, enumerable: false });

Object.keys(o);             // ["a"]
Reflect.ownKeys(o);         // ["a", "hidden"]
```

Use `Reflect.ownKeys` if you truly need *everything* (strings + symbols, any enumerability).

---

## Symbols have their own lane

Symbol keys are **never** returned by `Object.keys/entries/values` and are **not** visited by `for…in`. To get them:

```ts
Object.getOwnPropertySymbols(obj); // symbols only
Reflect.ownKeys(obj);               // strings + symbols
```

---

## Choosing the right iterator (cheat sheet)

| Need                                       | Use                               |
| ------------------------------------------ | --------------------------------- |
| Own, JSON-like data (what you’d serialize) | `Object.entries`                  |
| Everything on the object (audits/tools)    | `Reflect.ownKeys` + descriptors   |
| Walk prototype chain (rare)                | `for…in` + `Object.hasOwn` inside |
| Symbols only                               | `Object.getOwnPropertySymbols`    |

---

## Patterns you’ll reuse

### Stable “all entries” utility with descriptors

```ts
type EntryFull = { key: string | symbol; value: unknown; enumerable: boolean };

export function ownEntriesAll(obj: object): EntryFull[] {
  return Reflect.ownKeys(obj).map(k => {
    const d = Object.getOwnPropertyDescriptor(obj, k)!;
    return { key: k, value: d.value, enumerable: !!d.enumerable };
  });
}
```

### Produce a stable display order

```ts
export function stableKeyOrder(obj: object): Array<string | symbol> {
  const keys = Reflect.ownKeys(obj);
  const ints: string[] = [];
  const strs: string[] = [];
  const syms: symbol[] = [];
  for (const k of keys) {
    if (typeof k === "symbol") { syms.push(k); continue; }
    // integer-like check
    if (String((+k >>> 0)) === k && +k >= 0 && +k <= 2**32 - 2) ints.push(k);
    else strs.push(k);
  }
  ints.sort((a, b) => (+a) - (+b));
  // strings & symbols remain in insertion order already
  return [...ints, ...strs, ...syms];
}
```

---

## Common pitfalls

* Expecting `Object.keys` to keep purely **insertion** order even with numeric keys.
* Using `for…in` for data transforms and accidentally catching **inherited** keys.
* Forgetting **symbols** (and **non-enumerables**) are excluded from most “big three” APIs.
* Rebuilding an object and assuming it’s “sorted” — object shapes aren’t for sorting; prefer arrays/Maps when order matters.

---

## Walkthrough: round-trip with explicit order

```ts
const src = { "2": "two", b: 1, "10": "ten", a: 0 };
const order = stableKeyOrder(src);
const entries = order.map(k => [k as any, (src as any)[k]]);
const roundTripped = Object.fromEntries(entries as [string, unknown][]);
// The key order when enumerated matches the spec rules; our `entries` lets us control display order explicitly.
```

---

## Exercises

### 1) `stableKeyOrder(obj)` — return keys in spec order

Implement as above: integer-likes asc, then other strings by insertion, then symbols by insertion.

**Starter — `stableKeyOrder.ts`**

```ts
export function stableKeyOrder(obj: object): Array<string | symbol> {
  // Reflect.ownKeys + classify + sort integers
  return [];
}
```

---

### 2) `ownEntriesAll(obj)` — include non-enumerables & symbols

Return `{ key, value, enumerable }[]` for **all own** keys.

**Starter — `ownEntriesAll.ts`**

```ts
export type EntryFull = { key: string | symbol; value: unknown; enumerable: boolean };

export function ownEntriesAll(obj: object): EntryFull[] {
  return [];
}
```

---

### 3) `entriesRoundTrip(obj)` — keep a chosen display order

Given an object, produce:

* `entries` in **display** order using `stableKeyOrder`
* `toObject()` that rebuilds from those entries

**Starter — `entriesRoundTrip.ts`**

```ts
export function entriesRoundTrip(obj: object) {
  const order: Array<string | symbol> = []; // fill with stableKeyOrder
  const entries: Array<[string | symbol, unknown]> = [];
  return {
    order,
    entries,
    toObject() {
      const out: Record<string, unknown> = {};
      for (const [k, v] of entries) if (typeof k === "string") (out as any)[k] = v;
      // note: Object.fromEntries doesn’t accept symbols for plain objects — keep that in mind for UIs
      return out;
    }
  };
}
```

---

### 4) `copyIncludingNonEnumerable(src)` — shallow copy all own data props

Create a **plain object** copy that copies **string keys** including non-enumerables (ignore accessors; copy `value` only), and **includes enumerable symbols**.

**Starter — `copyIncludingNonEnumerable.ts`**

```ts
export function copyIncludingNonEnumerable<T extends object>(src: T): Record<string | symbol, unknown> {
  const out: Record<string | symbol, unknown> = {};
  for (const k of Object.getOwnPropertyNames(src)) {
    const d = Object.getOwnPropertyDescriptor(src, k)!;
    if ("value" in d) (out as any)[k] = d.value;
  }
  for (const s of Object.getOwnPropertySymbols(src)) {
    const d = Object.getOwnPropertyDescriptor(src, s)!;
    if (d.enumerable && "value" in d) (out as any)[s] = d.value;
  }
  return out;
}
```

---

## Quiz (checks)

1. `Object.keys` returns keys in which order?
   A) Insertion order only
   B) Random
   C) **Integer-like strings ascending, then other strings in insertion order** ✅
   D) Symbols first, then strings

2. Which API returns **strings + symbols**, **enumerable + non-enumerable** for **own** keys?
   A) `Object.keys`
   B) `Object.getOwnPropertyNames`
   C) **`Reflect.ownKeys`** ✅
   D) `for…in`

3. `for…in` iterates:
   A) Symbols too
   B) **Enumerable string keys across own + prototype chain** ✅
   C) Non-enumerables only
   D) Own keys only

4. Symbols will appear in: *(choose all)*

* `Object.keys`
* `Object.getOwnPropertySymbols` ✅
* `Reflect.ownKeys` ✅
* `for…in`

5. To keep **pure insertion order** for mixed keys including numeric labels, you should prefer:
   A) Plain objects + `Object.keys`
   B) **Arrays of pairs or `Map`** ✅
   C) `for…in`
   D) JSON stringify/parse trick

---

## Takeaways

* Learn the **integer-like → strings → symbols** ordering and you’ll predict every case.
* `Object.keys/entries/values` skip **symbols** and **non-enumerables**; `Reflect.ownKeys` sees all own keys.
* Avoid `for…in` for data transforms; it walks the **prototype** too.
* When order matters, use **entries arrays** or **Map** and make ordering explicit.

---

## What’s next

Wrap up Level 2 with **Objects L2 — Deep Copy Intro (`structuredClone`)** to copy nested data safely, understand its limits (functions, class instances, Maps/Sets), and compare to JSON tricks.
