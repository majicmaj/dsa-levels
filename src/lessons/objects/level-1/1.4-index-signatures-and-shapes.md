---
id: objects-l1-index-signatures-and-shapes
title: "Index Signatures & Shapes (Record<K,V>, dictionaries)"
topic: objects
level: 1
lesson: 1.4
prereqs:
  - objects-l1-overview-and-literals
  - objects-l1-property-access
  - objects-l1-existence-optional-nullish
outcomes:
  - Model **dictionary-like** objects with index signatures and `Record<K,V>`
  - Know when to choose **Object-with-index-signature** vs **Map**
  - Restrict keys with **string-literal unions** (e.g., `Record<'dev'|'prod', string>`)
  - Understand **number vs string index signatures** and JS key coercion
  - Combine fixed properties with an index signature safely
tags: ["objects","typescript","index-signature","record","dictionary","map","keys"]
est_minutes: 30
checks:
  - type: quiz
    id: objects-l1-index-sigs-quiz
  - type: unit
    entry: makeCounterDict.ts
    tests: makeCounterDict.test.ts
  - type: unit
    entry: fromEntriesRecord.ts
    tests: fromEntriesRecord.test.ts
  - type: unit
    entry: hasKey.ts
    tests: hasKey.test.ts
  - type: unit
    entry: narrowKeys.ts
    tests: narrowKeys.test.ts
---

## Why this matters

Real apps love **“string → value”** tables: counts, lookups, settings, caches. In TypeScript you’ll model these as **index signatures** or `Record<K,V>`. Pick the right shape and your dynamic key code becomes both safe and ergonomic.

---

## Two main ways to type a dictionary

### 1) Index signature
```ts
type Counter = { [key: string]: number };

const clicks: Counter = {};
clicks["/home"] = 10;
clicks["/home"] += 1;
````

### 2) `Record<K,V>` helper

```ts
type Counter = Record<string, number>;
```

They are equivalent for `string` keys. Prefer `Record` when it improves readability—especially with **literal-union keys** (next section).

---

## Restricting keys with literal unions

You don’t always want *any* string. Use a **union of string literals** to lock keys down:

```ts
type Env = "dev" | "staging" | "prod";
type URLs = Record<Env, string>;

const urls: URLs = {
  dev: "http://localhost:3000",
  staging: "https://staging.example.com",
  prod: "https://example.com",
};

// urls.qa = "…" // ❌ Type error: "qa" is not assignable to Env
```

> With an index signature `{[k: string]: T}`, **every** string key must be allowed, so you can’t restrict to a small set. Use `Record<Union, T>` for small fixed key sets.

---

## Number vs string index signatures (coercion rule)

In JS, **object keys are strings (or symbols)**; numeric-looking keys become strings (`1 → "1"`).

TypeScript enforces a relationship if you declare **both**:

```ts
type Weird = {
  [n: number]: string;   // values for numeric access
  [s: string]: string;   // must be the same or a supertype of the number indexer
};
```

* Because `obj[1]` and `obj["1"]` address the **same** property, the **string** indexer’s value type must be **the same or wider** than the number indexer’s.

> Arrays are modeled with **number** indexers internally; but here we’re focused on plain object dictionaries.

---

## Mixing fixed properties with an index signature

You can add named properties, but their types must be **compatible** with the indexer’s value type.

```ts
type Settings = {
  appName: string;            // must be compatible with the indexer type
  [k: string]: string;        // value type is string
};

// If the indexer were number, `appName: string` would be incompatible.
```

---

## Object dictionary vs Map (when to choose which)

Use an **object dictionary** when:

* Keys are **strings** (or you’re okay with string coercion).
* You want simple JSON-ability.
* You don’t need insertion order or a precise `.size`.

Use a **Map** when:

* Keys might be **non-strings** (numbers without coercion, booleans, objects).
* You care about **insertion order** or frequent **add/remove** at scale.
* You want `.size` and iteration characteristics of `Map`.

(You’ll get deep Map lessons later; this is just the decision rule.)

---

## Helpful patterns

### Dynamic counting (dictionary)

```ts
type Counter = Record<string, number>;

function incCounter(c: Counter, k: string, by = 1) {
  c[k] = (c[k] ?? 0) + by;   // from earlier lesson: ?? keeps 0s
}
```

### Building a `Record<Union, T>` from entries

```ts
type Role = "admin" | "editor" | "viewer";

function fromEntriesRecord<K extends string, V>(
  entries: Array<[K, V]>
): Record<K, V> {
  const out = {} as Record<K, V>;
  for (const [k, v] of entries) (out as any)[k] = v;
  return out;
}
```

### Key guards

```ts
function hasKey<T extends object, K extends PropertyKey>(
  obj: T,
  k: K
): k is Extract<keyof T, K> {
  return Object.hasOwn(obj, k);
}
```

---

## Common pitfalls

* **Over-permissive index signatures**: `{ [k: string]: T }` allows **any** string; use `Record<'a'|'b', T>` for closed sets.
* **`number` vs `string` indexers**: remember coercion; string value type must be ≥ number value type if both exist.
* **Reading unknown keys**: by default `obj[someString]` is `T` with an index signature—use **`noUncheckedIndexedAccess`** in tsconfig to make unchecked indexing return `T | undefined`.
* **Choosing object when you need non-string keys**: pick a **Map**.

---

## Walkthrough: counters with whitelisted keys

```ts
type Metric = "views" | "clicks" | "purchases";
type Stats = Record<Metric, number>;

const stats: Stats = { views: 0, clicks: 0, purchases: 0 };

function bump(stats: Stats, key: Metric, by = 1) {
  stats[key] += by;        // key is restricted and type-safe
}
```

---

## Exercises

### 1) `makeCounterDict()` — basic dictionary API

Return an object with:

* `inc(key: string, by = 1)`
* `get(key: string): number`
* `toObject(): Record<string, number>`

**Starter — `makeCounterDict.ts`**

```ts
export function makeCounterDict() {
  const store: Record<string, number> = {};
  return {
    inc(key: string, by = 1) {
      store[key] = (store[key] ?? 0) + by;
    },
    get(key: string) {
      return store[key] ?? 0;
    },
    toObject() {
      return { ...store };
    }
  };
}
```

---

### 2) `fromEntriesRecord(entries)` — build a restricted Record

Given `Array<[K,V]>`, return `Record<K,V>` (assume keys are consistent at runtime).

**Starter — `fromEntriesRecord.ts`**

```ts
export function fromEntriesRecord<K extends string, V>(
  entries: Array<[K, V]>
): Record<K, V> {
  const out = {} as Record<K, V>;
  for (const [k, v] of entries) (out as any)[k] = v;
  return out;
}
```

---

### 3) `hasKey(obj, k)` — own-key type guard

Return `true` if `obj` has **own** key `k`. Use `Object.hasOwn`.

**Starter — `hasKey.ts`**

```ts
export function hasKey<T extends object, K extends PropertyKey>(
  obj: T,
  k: K
): k is Extract<keyof T, K> {
  return Object.hasOwn(obj, k);
}
```

---

### 4) `narrowKeys(obj, keys)` — only allowed keys

Given `obj` and a readonly array of allowed keys (string literal union), return a **Record of those keys** with values from `obj` or a provided fallback.

**Starter — `narrowKeys.ts`**

```ts
export function narrowKeys<
  T extends Record<string, unknown>,
  K extends readonly (keyof T & string)[]
>(
  obj: T,
  keys: K,
  fallback: unknown = undefined
): Record<K[number], unknown> {
  const out: Partial<Record<K[number], unknown>> = {};
  for (const k of keys) {
    out[k] = (Object.hasOwn(obj, k) ? (obj as any)[k] : fallback);
  }
  return out as Record<K[number], unknown>;
}
```

---

## Quiz (checks)

1. Which types model a **string-keyed dictionary**? *(choose all)*

* `{ [k: string]: T }` ✅
* `Record<string, T>` ✅
* `Map<string, T>` (also valid dictionary, but not an object index signature) ✅
* `Record<'a' | 'b', T>` ✅ (restricted keys)

2. Why must a **string** indexer’s value type be the same or **wider** than a **number** indexer’s value type when both exist?
   A) Engine limitation
   B) **Because numeric keys are coerced to strings at runtime** ✅
   C) To support arrays
   D) It’s arbitrary

3. When do you prefer `Record<'dev'|'prod', string>` over `{[k: string]: string}`?
   A) When you need JSON
   B) **When keys should be restricted to a fixed small set** ✅
   C) When values aren’t strings
   D) Never

4. Which statement is true?
   A) An index signature can restrict to `"id" | "name"` only
   B) **`Record<Union, T>` restricts keys to that union** ✅
   C) Maps can only use string keys
   D) Object keys are always numbers

5. You need non-string keys and insertion order. Choose:
   A) `Record<string, T>`
   B) `{[k: string]: T}`
   C) **`Map<K, T>`** ✅
   D) Array of tuples only

---

## Takeaways

* Use **index signatures** or `Record<K,V>` for dictionary shapes; prefer `Record<Union,V>` for **restricted key sets**.
* Remember **string coercion** of numeric keys and the value-type relationship between number & string indexers.
* Pick **Map** when you need non-string keys, insertion order, or `.size`.
* For safer dynamic indexing, consider enabling **`noUncheckedIndexedAccess`** in tsconfig.

---

## What’s next

Finish Level 1 with **Objects L1 — Delete & Shapes** to learn about `delete`, shape stability, shallow copies, and when to avoid structural changes for performance and clarity.
