---
id: objects-l1-existence-optional-nullish
title: "Existence & Safe Reads (`in`, `hasOwn`, `?.`, `??`)"
topic: objects
level: 1
lesson: 1.3
prereqs:
  - objects-l1-overview-and-literals
  - objects-l1-property-access
outcomes:
  - Choose correctly among **`in`**, **`Object.hasOwn`**, and simple reads to check for a property
  - Use **optional chaining** (`?.`, `?.[]`, `?.()`) to avoid crashes on missing links
  - Use **nullish coalescing** (`??`, `??=`) instead of `||` when `0`, `""`, or `false` are valid values
  - Explain the difference between a **missing** property and a property set to **`undefined`**
  - "Implement safe helpers: `hasOwnSafe`, `getOr`, `getInOr`"
tags: ["objects","existence","optional-chaining","nullish-coalescing","hasOwn","in"]
est_minutes: 30
checks:
  - type: quiz
    id: objects-l1-existence-quiz
  - type: unit
    entry: hasOwnSafe.ts
    tests: hasOwnSafe.test.ts
  - type: unit
    entry: getOr.ts
    tests: getOr.test.ts
  - type: unit
    entry: getInOr.ts
    tests: getInOr.test.ts
  - type: unit
    entry: coalesceNumber.ts
    tests: coalesceNumber.test.ts
---

## Why this matters

JS won’t throw when you read a **missing** property—returning `undefined` instead. That’s convenient, but it blurs “missing” vs “present but undefined”. Add in prototypes and you need the right tools: **`in`**, **`Object.hasOwn`**, and **`?.` / `??`** to keep your code safe and intention-revealing.

---

## Existence checks compared

### 1) Simple read
```ts
obj.foo            // undefined if missing
obj.foo !== undefined // true only if value is not undefined (but fails if value is actually undefined)
````

* **Problem:** `obj.foo !== undefined` treats a **present-but-undefined** property as “missing”.

### 2) `in` operator — checks **own or inherited**

```ts
"toString" in {}           // true (inherited from Object.prototype)
"foo" in { foo: undefined } // true (property exists, value undefined)
```

* Good when you want to know if a lookup **would succeed** along the prototype chain.

### 3) `Object.hasOwn(obj, key)` — **own** properties only

```ts
Object.hasOwn({ foo: undefined }, "foo"); // true
```

* The clearest way to check **only this object’s own** props.
* Polyfillable with `Object.prototype.hasOwnProperty.call(obj, key)`.

> **Rule of thumb**
>
> * **Presence on this object?** → `Object.hasOwn(obj, k)`
> * **Presence anywhere on the chain?** → `"k" in obj`
> * **Value with default?** → `obj?.k ?? defaultV`

---

## Optional chaining (`?.`) — stop safely

* Property: `obj?.prop`
* Element:  `obj?.[expr]`
* Call:     `obj.method?.(args)`

If the left side is **nullish** (`null` or `undefined`), the whole expression becomes `undefined` **without** throwing or calling.

```ts
user.profile?.address?.city
config.handlers?.onClick?.(event)
arr?.[0]
```

---

## Nullish coalescing (`??`) — only for `null`/`undefined`

Use `??` to choose a default **only** when the left side is **nullish** (`null` or `undefined`), not for other falsy values.

```ts
const port = env.PORT ?? 3000;   // 0 would be kept, only null/undefined fallback
const label = cfg.title ?? "(untitled)";
```

Contrast with `||`, which falls back on **any falsy** (`0`, `""`, `false`, `NaN`, `null`, `undefined`).

```ts
0 || 5   // 5  (maybe wrong)
0 ?? 5   // 0  (likely right)
```

### `??=` assignment

```ts
obj.count ??= 0; // only sets when obj.count is nullish
```

---

## Missing vs `undefined` (and tests)

```ts
const a = {};
const b = { x: undefined };

a.x; // undefined       (missing)
b.x; // undefined       (present but undefined)

"x" in a; // false
"x" in b; // true

Object.hasOwn(a, "x"); // false
Object.hasOwn(b, "x"); // true
```

---

## Patterns you’ll reuse

* **Defaulted read** (shallow):

  ```ts
  const retries = opts?.retries ?? 3;
  ```
* **Defaulted deep read**:

  ```ts
  const city = user?.profile?.address?.city ?? "N/A";
  ```
* **Optional call**:

  ```ts
  hook?.(data);
  ```
* **Set default once**:

  ```ts
  stats[key] ??= 0; // then increment
  ```

---

## Common pitfalls

* Using `||` when `0`, `""`, or `false` are **valid** values → use `??`.
* Assuming `in` checks only own properties—it also sees **inherited** ones.
* Writing `obj.prop !== undefined` to check presence—ambiguous if value could be `undefined`.
* Forgetting `?.[]` for dynamic keys: `obj?.[k]`.

---

## Walkthrough: reading config safely

```ts
type Cfg = {
  server?: { host?: string; port?: number };
  flags?: { compact?: boolean };
};

function readCfg(cfg: Cfg) {
  const host = cfg.server?.host ?? "localhost";
  const port = cfg.server?.port ?? 3000;
  const compact = cfg.flags?.compact ?? false;
  return { host, port, compact };
}
```

---

## Exercises

### 1) `hasOwnSafe(obj, key)` — own-property check with fallback

Implement a tiny wrapper that prefers `Object.hasOwn`, else falls back to `.hasOwnProperty.call`.

**Starter — `hasOwnSafe.ts`**

```ts
export function hasOwnSafe(obj: object, key: PropertyKey): boolean {
  // Prefer Object.hasOwn if available; otherwise use Object.prototype.hasOwnProperty.call
  return false;
}
```

---

### 2) `getOr(obj, key, defaultValue)` — shallow safe read

Return `obj?.[key] ?? defaultValue`.

**Starter — `getOr.ts`**

```ts
export function getOr<T extends object, K extends PropertyKey, V>(
  obj: T | null | undefined,
  key: K,
  defaultValue: V
): unknown /* ideally T[K] | V */ {
  // Use optional element access + nullish coalescing
  return defaultValue;
}
```

> **Type note:** Keep runtime simple; tests validate behavior. We’ll tighten generics in L5.

---

### 3) `getInOr(obj, path, defaultValue)` — deep safe read

Walk a path of keys; if any hop is nullish, return `defaultValue`.

**Starter — `getInOr.ts`**

```ts
export function getInOr(
  obj: unknown,
  path: Array<string | number | symbol>,
  defaultValue: unknown
): unknown {
  let cur: any = obj;
  for (const k of path) {
    if (cur == null) return defaultValue;
    cur = cur[k as any];
  }
  return cur ?? defaultValue;
}
```

---

### 4) `coalesceNumber(x, fallback)` — `??` vs `||` practice

Return `x` if it’s **not** nullish; otherwise `fallback`. Tests include `0`, `NaN`, `null`, `undefined`.

**Starter — `coalesceNumber.ts`**

```ts
export function coalesceNumber(x: number | null | undefined, fallback: number): number {
  // Keep 0 and NaN; only fall back on null/undefined
  return fallback;
}
```

---

## Quiz (checks)

1. `"k" in obj` returns `true` when:
   A) `obj` has **own** property `"k"`
   B) `"k"` is found on the **prototype chain**
   C) Both A and B ✅
   D) Neither

2. To check **only own** properties you should use:
   A) `"k" in obj`
   B) `obj[k] !== undefined`
   C) **`Object.hasOwn(obj, "k")`** ✅
   D) `obj.hasOwnProperty("k")` directly (unsafe on null-prototype objects)

3. Which expression **won’t throw** and returns `undefined` if any link is missing?
   A) `obj.a.b.c`
   B) **`obj?.a?.b?.c`** ✅
   C) `obj && obj.a && obj.a.b && obj.a.b.c` only
   D) `obj?.a.b.c`

4. Pick the safe default for ports when `0` is a valid value:
   A) `cfg.port || 3000`
   B) **`cfg.port ?? 3000`** ✅
   C) `cfg.port ? cfg.port : 3000`
   D) `Number(cfg.port) || 3000`

5. Given `const x = { y: undefined }`, which are **true**? *(choose all)*

* `x.y === undefined` ✅
* `"y" in x` ✅
* `Object.hasOwn(x, "y")` ✅
* `x.hasOwnProperty("y")` is always safe ❌

---

## Takeaways

* Use **`Object.hasOwn`** for own-property presence, `"in"` to include prototypes.
* Use **`?.`** to stop safely on nullish links; use **`??`** to default only for `null`/`undefined`.
* Don’t conflate **missing** with **`undefined` value**—tests should cover both cases.

---

## What’s next

Head to **Objects L1 — Index Signatures & Shapes** to model flexible dictionaries vs fixed shapes in TypeScript, and to learn when to prefer `Record<K,V>` or a `Map`.
