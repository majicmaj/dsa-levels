---
id: objects-l1-delete-and-shapes
title: "Delete & Shapes (removing keys, immutable omit, shape notes)"
topic: objects
level: 1
lesson: 1.5
prereqs:
  - objects-l1-overview-and-literals
  - objects-l1-property-access
  - objects-l1-existence-optional-nullish
  - objects-l1-index-signatures-and-shapes
outcomes:
  - Use the `delete` operator correctly (what it deletes, what it returns, when it fails)
  - Explain the difference between **deleting a key** vs **setting it to `undefined`**
  - Remove keys **immutably** with rest/spread and `Object.fromEntries`
  - Understand basic **shape/hidden-class** considerations (why churn can be slow in hot paths)
  - Avoid array “holes” caused by `delete` on indices (use `splice` instead)
tags: ["objects","delete","omit","immutability","performance","shapes"]
est_minutes: 30
checks:
  - type: quiz
    id: objects-l1-delete-shapes-quiz
  - type: unit
    entry: deleteInPlace.ts
    tests: deleteInPlace.test.ts
  - type: unit
    entry: withoutKey.ts
    tests: withoutKey.test.ts
  - type: unit
    entry: omitKeys.ts
    tests: omitKeys.test.ts
  - type: unit
    entry: compactObject.ts
    tests: compactObject.test.ts
---

## Why this matters

Sooner or later you need to **remove** fields: cleaning payloads, redacting secrets, trimming diff noise. You’ve got two main levers:

- **Mutate:** `delete obj[key]`
- **Immutable copy:** rebuild a new object **without** certain keys

Knowing when to use each—and the subtle differences—keeps your data tidy and your performance predictable.

---

## `delete` — what it actually does

- Removes an **own** property from an object. It does **not** touch the prototype.
- Returns a **boolean**: `true` if the property was removed or didn’t exist; `false` if it **couldn’t** be removed (non-configurable).
- On plain object-literal props, deletion typically **succeeds** (they’re configurable by default).

```ts
const o = { a: 1, b: 2 };
delete o.a;        // true
"a" in o;          // false
delete o.nope;     // true (nothing to do, not an error)

const base = { x: 1 };
const child = Object.create(base);
delete child.x;    // true, but doesn't affect base; "x" still found via prototype
````

> **Strict mode footnote:** deleting certain bindings (like `delete someVar`) can throw or fail; we’re focused on **object properties** here.

---

## Delete vs set to `undefined`

| Action              | Presence    | Value       | JSON.stringify                 |
| ------------------- | ----------- | ----------- | ------------------------------ |
| `delete obj.k`      | **missing** | —           | key omitted                    |
| `obj.k = undefined` | **present** | `undefined` | key omitted (for object props) |

* Both look the same in **JSON output** for plain objects (props with `undefined` are skipped), but **semantics differ**:

  * `"k" in obj` → `false` after delete; `true` after setting to `undefined`.
  * `Object.hasOwn(obj,"k")` matches the above.

**Rule of thumb**

* If you’re treating the object as a **dictionary**, `delete` is idiomatic for removal.
* If you want to **keep the shape** (e.g., fixed schema), set to `null`/`undefined` instead, or create a **new object without the key** (immutable).

---

## Immutable removal (preferred for “pure” code)

### Single key (dynamic)

```ts
export function withoutKey<T extends object, K extends keyof T>(
  obj: T, key: K
): Omit<T, K> {
  const { [key]: _omit, ...rest } = obj as any; // rest gathers the others
  return rest as Omit<T, K>;
}
```

### Multiple keys

```ts
export function omitKeys<T extends object, K extends readonly (keyof T)[]>(
  obj: T, keys: K
): Omit<T, K[number]> {
  const kill = new Set<PropertyKey>(keys as readonly PropertyKey[]);
  return Object.fromEntries(
    Object.entries(obj).filter(([k]) => !kill.has(k))
  ) as Omit<T, K[number]>;
}
```

These patterns don’t mutate the input, which plays nicely with React reducers, caching, and tests.

---

## Shapes & performance (just enough to be dangerous)

Engines often represent objects with **hidden classes** (a.k.a. shapes). Rapidly adding/removing different keys on the **same** object can cause **shape churn** and deoptimize hot code.

* Occasional `delete` is fine.
* In hot loops or long-lived objects, prefer:

  * Reusing objects with **stable keys** and setting values to `null`/`undefined`, or
  * Producing a **fresh object** with the desired shape (immutable omit).

> Don’t micro-optimize blindly—**measure** when performance matters.

---

## ⚠️ Arrays are objects too

`delete arr[1]` makes a **hole** (sparse array) and **does not** shift elements. Use `splice` or immutable `toSpliced` instead.

```ts
const a = [10, 20, 30];
delete a[1];  // [10, <1 empty item>, 30]
a.splice(1,1); // [10, 30]
```

---

## Walkthrough: redacting secrets immutably

```ts
type User = { id: string; name: string; token?: string; email?: string };

function redact(u: User): Omit<User, "token" | "email"> {
  // Option A: destructuring twice
  const { token: _t, email: _e, ...rest } = u;
  return rest;
  // Option B: generic omitKeys(u, ["token","email"] as const)
}
```

---

## Exercises

### 1) `deleteInPlace(obj, key)` — mutate & report

Delete **own** property `key` from `obj`. Return `true` iff it *was present and got removed*. Don’t traverse prototype.

**Starter — `deleteInPlace.ts`**

```ts
export function deleteInPlace<T extends object, K extends PropertyKey>(
  obj: T,
  key: K
): boolean {
  // Tip: check Object.hasOwn(obj, key) before/after
  return false;
}
```

---

### 2) `withoutKey(obj, key)` — immutable single-key remove

Return a **new object** without `key`. If missing, return a **shallow copy**.

**Starter — `withoutKey.ts`**

```ts
export function withoutKey<T extends object, K extends keyof T>(
  obj: T,
  key: K
): Omit<T, K> {
  // Use rest destructuring with a computed property
  return {} as any;
}
```

---

### 3) `omitKeys(obj, keys)` — immutable multi-key remove

Support `readonly` key arrays and preserve other props.

**Starter — `omitKeys.ts`**

```ts
export function omitKeys<T extends object, K extends readonly (keyof T)[]>(
  obj: T,
  keys: K
): Omit<T, K[number]> {
  // Build a Set and filter Object.entries
  return {} as any;
}
```

---

### 4) `compactObject(obj)` — remove nullish values (shallow)

Return a **new object** with all keys whose values are `null` or `undefined` removed.

**Starter — `compactObject.ts`**

```ts
export function compactObject<T extends Record<string, unknown>>(
  obj: T
): Partial<T> {
  // Keep entries with value !== null && value !== undefined
  return {};
}
```

---

## Quiz (checks)

1. What does `delete obj.k` return if `k` doesn’t exist?
   A) Throws
   B) `false`
   C) **`true`** ✅
   D) `undefined`

2. After `obj.k = undefined`, which is **true**?
   A) `"k" in obj` is **false**
   B) `Object.hasOwn(obj,"k")` is **false**
   C) **`"k" in obj` is true; the property is present with value `undefined`** ✅
   D) `JSON.stringify(obj)` must include `"k"`

3. Which is a correct **immutable** way to remove a dynamic key?
   A) `delete obj[key]`
   B) `const { [key]: _omit, ...rest } = obj;` **then use `rest`** ✅
   C) `obj[key] = null`
   D) `obj = Object.assign(obj, {})`

4. Using `delete` on an **array index** results in:
   A) Elements shift left
   B) **A hole (sparse array)** ✅
   C) The array length decreases
   D) A TypeError

5. `delete` removes:
   A) Own properties only ✅
   B) Prototype properties too
   C) Non-configurable properties always
   D) Array items with shift

---

## Takeaways

* `delete` removes **own properties**; returns `true` on success or no-op.
* Deleting vs setting to `undefined` affects **presence checks** (`in`/`hasOwn`).
* Prefer **immutable omit** (rest/spread, `fromEntries`) in pure code paths.
* Avoid `delete` on arrays (creates holes); use `splice`/`toSpliced`.
* Stable shapes often perform better—copy or null-out in hot paths if needed.

---

## What’s next

Level 2 time: move to **Objects L2 — Keys/Values/Entries & Shallow Copy** where you’ll iterate own props correctly, clone/merge safely, and explore enumeration order and `structuredClone` basics.