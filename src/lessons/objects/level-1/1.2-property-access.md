---
id: objects-l1-property-access
title: "Property Access (dot vs bracket, dynamic keys, symbols)"
topic: objects
level: 1
lesson: 1.2
prereqs:
  - objects-l1-overview-and-literals
outcomes:
  - Choose correctly between **dot** and **bracket** notation
  - Read/write properties with **dynamic keys** (computed at runtime)
  - Access **symbol-keyed** properties and know how they differ from string keys
  - Understand how TS typing changes with `keyof`, index signatures, and unknown keys
  - Avoid common traps: treating `"key"` and `key` the same, invalid identifier names, numeric keys
tags: ["objects","property-access","dynamic-keys","symbols","typescript"]
est_minutes: 25
checks:
  - type: quiz
    id: objects-l1-property-access-quiz
  - type: unit
    entry: getProp.ts
    tests: getProp.test.ts
  - type: unit
    entry: setProp.ts
    tests: setProp.test.ts
  - type: unit
    entry: getIn.ts
    tests: getIn.test.ts
  - type: unit
    entry: keyedCounter.ts
    tests: keyedCounter.test.ts
---

## Why this matters

You’ll read/write object properties thousands of times a day. Knowing **when** to use `obj.prop` vs `obj[prop]` keeps your code correct (and type-safe) with dynamic keys, symbols, and “weird” property names.

---

## Dot vs bracket — the rule of thumb

- **Dot** (`obj.name`) when the key is a **valid identifier** and **known at code time**.
- **Bracket** (`obj[key]`) when the key is **dynamic** (variable/expression), **not a valid identifier** (`"full-name"`), **numeric-like**, or a **symbol**.

```ts
const user = { name: "Amina", "full-name": "Amina Khan", 1: "one" as const };

user.name;            // ✅ dot
user["full-name"];    // ✅ invalid identifier → bracket
user[1];              // ✅ number coerces to "1"
const k = "name";
user[k];              // ✅ dynamic key → bracket
````

> Dot access **always** uses the literal token after the dot; `user.k` ≠ `user[k]`.

---

## Dynamic keys (computed at runtime)

```ts
function tag(obj: Record<string, unknown>, key: string, value: unknown) {
  obj[key] = value;                 // bracket is mandatory
}

const field = Math.random() > 0.5 ? "email" : "phone";
const contact: Record<string, string> = {};
contact[field] = "hidden";          // OK
```

With **TypeScript**, you can get precise types when the key is constrained:

```ts
function getProp<T extends object, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

type User = { id: number; name: string };
const u: User = { id: 1, name: "Amina" };
const id = getProp(u, "id");        // type: number
```

If your object has an **index signature**, any string key is allowed:

```ts
type Dict = { [k: string]: number };
const d: Dict = {};
d["score"] = 10;    // OK
```

---

## Symbols as keys

* Symbols are **not strings**, never collide with string keys, and **must** use bracket access.
* They’re skipped by `Object.keys`/`entries`; use `Object.getOwnPropertySymbols` to enumerate.

```ts
const meta = Symbol("meta");
const o = { [meta]: { created: Date.now() }, id: 1 };

o[meta];   // ✅ access symbol-keyed prop
// o.meta  // ❌ doesn't work: dot can't name a symbol
```

---

## Numeric keys are strings under the hood

Object keys are strings (or symbols). Numeric literals in object literals become strings:

```ts
const table = { 1: "one", 2: "two" };
table[1] === table["1"];  // true
```

---

## Safe reads vs “missing” keys

* Reading a missing property returns **`undefined`** (no throw).
* We’ll cover existence checks (`in`, `hasOwn`, `?.`, `??`) next lesson; for now, remember:

```ts
const cfg: { retries?: number } = {};
const n = cfg.retries; // undefined if missing
```

---

## Common pitfalls

* Writing `obj.key` when you meant `obj[key]` (dynamic).
* Forgetting quotes/brackets for keys like `"full-name"`.
* Expecting numeric keys to stay numeric — they become strings.
* Trying to use dot syntax for **symbols**.

---

## Walkthrough: “keyed counter” with dynamic increments

```ts
type Counter = Record<string, number>;
function inc(c: Counter, key: string, by = 1): void {
  c[key] = (c[key] ?? 0) + by;
}
const c: Counter = {};
inc(c, "views");
inc(c, "views", 2);
```

---

## Exercises

### 1) `getProp(obj, key)` — typed read

Return `obj[key]` with precise TS typing for known keys.

**Starter — `getProp.ts`**

```ts
export function getProp<T extends object, K extends keyof T>(obj: T, key: K): T[K] {
  // Return property using bracket access
  return obj[key];
}
```

---

### 2) `setProp(obj, key, value)` — dynamic write (mutates)

Set `obj[key] = value` for a **string | number | symbol** key. Keep runtime simple; tests focus on behavior.

**Starter — `setProp.ts`**

```ts
export function setProp<T extends object, K extends PropertyKey>(
  obj: T,
  key: K,
  value: unknown
): T & Record<K, unknown> {
  (obj as any)[key] = value;
  return obj as T & Record<K, unknown>;
}
```

---

### 3) `getIn(obj, path)` — safe nested read

Read a nested value by an array of keys (strings/symbols/numbers). If any level is missing, return `undefined`. Do **not** throw.

**Starter — `getIn.ts`**

```ts
export function getIn(
  obj: unknown,
  path: Array<string | number | symbol>
): unknown {
  let cur: any = obj;
  for (const k of path) {
    if (cur == null) return undefined; // null or undefined
    cur = cur[k as any];
  }
  return cur;
}
```

---

### 4) `keyedCounter()` — dynamic keys practice

Implement a simple counter object with methods:

* `inc(key: string, by = 1)`
* `get(key: string): number`
* `toObject(): Record<string, number>`

**Starter — `keyedCounter.ts`**

```ts
export function keyedCounter() {
  const store: Record<string, number> = {};
  return {
    inc(key: string, by = 1) {
      store[key] = (store[key] ?? 0) + by;
    },
    get(key: string) {
      return store[key] ?? 0;
    },
    toObject() {
      return { ...store };
    }
  };
}
```

---

## Quiz (checks)

1. When must you use **bracket** notation? *(choose all)*

* The key is stored in a **variable** ✅
* The key is a **symbol** ✅
* The key is `"full-name"` ✅
* The key is `name` known at compile time

2. What does `obj.k` read when `const k = "name"`?
   A) `obj["name"]`
   B) `obj.k` — the literal key `"k"` ✅
   C) Throws
   D) Depends on TS config

3. Which statement about **numeric keys** is true?
   A) They’re stored as numbers
   B) They’re coerced to strings ✅
   C) They become symbols
   D) They’re disallowed

4. To read a **symbol-keyed** property you should use:
   A) Dot notation
   B) `Object.keys`
   C) **Bracket notation with the symbol** ✅
   D) `obj["Symbol(meta)"]`

5. Reading a **missing** property on a plain object returns:
   A) `null`
   B) **`undefined`** ✅
   C) Throws
   D) `false`

---

## Takeaways

* Use **dot** for static, identifier-safe keys; **bracket** for **dynamic**, invalid identifier, numeric-like, or **symbol** keys.
* Numeric keys are really **strings**; symbols are distinct and skip general enumeration.
* Safe nested reads can be built with a small `getIn` helper; we’ll add `?.`/`??` in the next lesson.

---

## What’s next

Proceed to **Objects L1 — Existence & Safe Reads** to master `in`, `Object.hasOwn`, optional chaining `?.`, nullish coalescing `??`, and how they interact with holes vs `undefined`.
