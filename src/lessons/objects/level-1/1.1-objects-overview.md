---
id: objects-l1-overview-and-literals
title: "Overview & Literals (keys, shorthand, computed)"
topic: objects
level: 1
lesson: 1.1
prereqs:
  - arrays-l1-overview
outcomes:
  - Create plain objects using literals with string/number/symbol keys
  - Use **shorthand properties** and **method** syntax in object literals
  - Define **computed property names** with dynamic keys
  - Understand what counts as a valid key and how non-strings are coerced
  - Know when to reach for `Object.create(null)` for a “bare” dictionary
tags: ["objects","literals","computed-keys","shorthand","symbols","dictionary"]
est_minutes: 25
checks:
  - type: quiz
    id: objects-l1-overview-quiz
  - type: unit
    entry: pointFactory.ts
    tests: pointFactory.test.ts
  - type: unit
    entry: makeSingleEntry.ts
    tests: makeSingleEntry.test.ts
  - type: unit
    entry: renameKeyShallow.ts
    tests: renameKeyShallow.test.ts
---

## Why this matters

Objects are the **workhorse** structure in JS/TS for modeling entities, records, and dictionaries. Getting the basics—**keys, literals, shorthand, computed names**—makes everything else (enums, maps, serialization, TS typing) feel natural.

---

## What is an object (quick mental model)

- A **bag of properties** keyed by **strings** or **symbols** (numbers are coerced to strings).
- Each property has a **name** (the key) and a **value** (any JS value).
- Prototypes exist, but we’ll keep L1 focused on *own* properties and literals.

---

## Object literal basics

```ts
const user = {
  id: 42,                 // property name: "id"
  name: "Amina",
  active: true
};
````

### Shorthand properties & methods

If you already have variables with the same names, you can **shorthand**:

```ts
const id = 42, name = "Amina";
const user1 = { id, name };          // { id: 42, name: "Amina" }

const counter = {
  value: 0,
  increment() { this.value++; },     // method shorthand
};
```

> Shorthand is purely **syntax sugar**; shape is the same as `{ increment: function() { … } }`.

---

## Property names (keys): strings, numbers, symbols

* **Strings**: most common — `"id"`, `"full-name"`, `"0"`.
* **Numbers**: **coerced to strings**: `{ 1: "one" }` actually has key `"1"`.
* **Symbols**: non-string, non-colliding keys (advanced usage; just a peek here).

```ts
const k1 = "site", k2 = 7;
const s = Symbol("meta");

const settings = {
  [k1]: "prod",          // "site"
  [k2]: "lucky",         // "7"
  [s]: { hidden: true }, // symbol-keyed property (skips normal enumeration)
};
```

---

## Computed property names (dynamic keys)

Wrap an expression in `[]` to compute the key at creation time.

```ts
const field = "email";
const value = "dev@acme.io";

const obj = {
  id: 1,
  [field]: value,        // creates "email": "dev@acme.io"
  ["prefix_" + field]: "alt", // "prefix_email"
};
```

This pattern powers **dictionary-like** shapes and merges.

---

## Valid identifiers vs quoted keys

* If a key is a valid identifier (`name`, `isAdmin`) → no quotes needed.
* If it has spaces, hyphens, or starts with a number → use quotes and **bracket access** later.

```ts
const weird = {
  "full-name": "Amina Khan",
  "1st": true,
};
```

---

## Bare dictionaries with no prototype

Use `Object.create(null)` to avoid prototype keys and get a **pure key→value table**.

```ts
const dict = Object.create(null);
dict["__proto__"] = "safe"; // it’s just a normal key here
```

We’ll compare this to `Map` later; for now, it’s a handy trick when you need a minimal object table.

---

## Quick notes you’ll use soon

* **Accessing properties** (dot vs bracket) and **existence checks** come next lesson.
* Numbers as keys are **strings under the hood** → `"1"` and `1` **collide**.
* **Symbols** don’t collide with strings and are skipped by `Object.keys` / `entries` (you need `Object.getOwnPropertySymbols` to fetch them).

---

## Common pitfalls

* Expecting `{ 1: "x" }` and `{ "1": "x" }` to be different—**they’re the same**.
* Forgetting brackets for dynamic keys: `{ field: value }` stores literal key `"field"`, not the variable’s value.
* Assuming symbol-keyed properties show up in `Object.keys()`—they don’t.

---

## Walkthrough: building a small payload

```ts
type Id = number;
const key = "status";
function makeUserPayload(id: Id, status: "active" | "pending") {
  return {
    id,               // shorthand
    createdAt: Date.now(),
    [key]: status,    // computed key
    info: {
      // nested object
      tags: ["new"],
    },
  };
}
```

---

## Exercises

### 1) `pointFactory(x, y)` — shorthand + method

Create a factory that returns `{ x, y, move(dx, dy) }` where `move` mutates and returns `this`.

**Starter — `pointFactory.ts`**

```ts
export type Point = { x: number; y: number; move(dx: number, dy: number): Point };

export function pointFactory(x: number, y: number): Point {
  // Use shorthand for x,y and method shorthand for move
  return { x: 0, y: 0, move(dx: number, dy: number) { return this; } };
}
```

---

### 2) `makeSingleEntry(key, value)` — computed property name

Return an object with a **single** key/value using a computed property name. Keys can be `string | number | symbol`.

**Starter — `makeSingleEntry.ts`**

```ts
export function makeSingleEntry<K extends PropertyKey, V>(key: K, value: V): Record<K & (string | number), V> | { [k: symbol]: V } {
  // Hint: if typeof key === "symbol", return { [key]: value } typed accordingly.
  // For string/number, return a Record-like shape.
  // Keep it simple at runtime; tests focus on structure, not exact TS wizardry.
  return {} as any;
}
```

---

### 3) `renameKeyShallow(obj, fromKey, toKey)` — build a new object

Produce a **new object** where a single own property is renamed (shallow). If `fromKey` is missing, return a **shallow copy** unchanged.

**Starter — `renameKeyShallow.ts`**

```ts
export function renameKeyShallow<
  T extends object,
  FK extends keyof T,
  TK extends PropertyKey
>(obj: T, fromKey: FK, toKey: TK): Omit<T, FK> & Record<TK, T[FK]> {
  // Build a new object literal with a computed property for toKey
  // Copy other props over (shallow)
  return {} as any;
}
```

---

## Quiz (checks)

1. Which are valid **property key** types for plain objects?
   A) `string` ✅
   B) `number` (coerced to string) ✅
   C) `symbol` ✅
   D) `boolean`

2. What does this create?

```ts
const k = "email";
const o = { [k]: "a@b.com" };
```

A) `{ "k": "a@b.com" }`
B) `{ email: "a@b.com" }` ✅
C) `{ "[k]": "a@b.com" }`
D) Throws

3. In `{ 1: "a" }`, the actual key is:
   A) `1` (number)
   B) `"1"` (string) ✅
   C) `Symbol(1)`
   D) Depends on engine

4. Symbol-keyed properties appear in `Object.keys(obj)`:
   A) Always
   B) Only if enumerable
   C) **Never** (use `Object.getOwnPropertySymbols`) ✅
   D) Only in strict mode

5. Which literal is **prototype-free** (no inherited props)?
   A) `{}`
   B) `Object.create({})`
   C) `Object.create(null)` ✅
   D) `new Object()`

---

## Takeaways

* Objects map **string/symbol keys → values**; numbers become strings.
* Use **shorthand** for concise literals and **computed names** for dynamic keys.
* Prefer `Object.create(null)` when you want a **bare dictionary** without prototype baggage.
* We’ll cover **access** (dot vs bracket), **existence checks**, and **optional chaining** next.

---

## What’s next

Proceed to **Objects L1 — Property Access** to master dot vs bracket, safe reads with `?.`/`??`, and the differences between `in`, `hasOwn`, and simple equality checks.
