---
id: strings-l1-literals-escapes-templates
title: "Literals, Escapes & Template Literals"
topic: strings
level: 1
lesson: 1.1
prereqs:
  - arrays-l1-iteration-and-basics
outcomes:
  - Write single/double-quoted strings and **template literals** confidently
  - Use **escape sequences** `\n`, `\r`, `\t`, `\\`, `\'`, `\"`, `\xNN`, `\uXXXX`, `\u{1F600}`
  - Explain **why strings are immutable** and how that affects building strings
  - Interpolate values with **`${...}`**, span **multiple lines**, and use **tagged templates**
  - Use `String.raw`/custom tags to control escaping and indentation
tags: ["strings","template-literals","escapes","unicode","tagged-templates","immutability"]
est_minutes: 35
checks:
  - type: quiz
    id: strings-l1-literals-quiz
  - type: unit
    entry: normalizeNewlines.ts
    tests: normalizeNewlines.test.ts
  - type: unit
    entry: zeroPad.ts
    tests: zeroPad.test.ts
  - type: unit
    entry: dedent.ts
    tests: dedent.test.ts
  - type: unit
    entry: htmlSafe.ts
    tests: htmlSafe.test.ts
  - type: unit
    entry: labelMaker.ts
    tests: labelMaker.test.ts
crosslinks:
  - { to: strings-l2-utf16-code-units-vs-code-points, why: "Understanding why length counts code units and implications" }
  - { to: arrays-l1-iteration-101, why: "Iterating strings via arrays and code point iteration patterns" }
---

## Why this matters

Strings are everywhere—logs, URLs, UI text, parsers, and interview-style challenges. Getting **literals, escaping, and templates** right makes your code safer and your later lessons (Unicode correctness, regex, algorithms) much simpler.

---

## Literal forms

You have three primary ways to write a string:

```ts
const a = 'single quotes';
const b = "double quotes";
const c = `template literals with ${1 + 2} interpolation`;
````

* **Single/Double**: cannot contain an actual newline; use `\n` or the legacy line-continuation `\` at the end of a line (not recommended).
* **Template literals (\`)**

  * Allow **real newlines** and **\${...}** expressions.
  * Still process escapes like `\n`, `\t`, etc.
  * Can be **tagged** (e.g., `html`… see below).

---

## Escape sequences you’ll actually use

| Escape      | Meaning              | Notes                                    |
| ----------- | -------------------- | ---------------------------------------- |
| `\n`        | Line feed (LF)       | Unix newline                             |
| `\r`        | Carriage return (CR) | Windows uses CRLF (`\r\n`)               |
| `\t`        | Tab                  |                                          |
| `\\`        | Backslash            |                                          |
| `\'` / `\"` | Quote                | Use the opposite quote to avoid escaping |
| `\0`        | Null (U+0000)        | Must **not** be followed by a digit      |
| `\xNN`      | Hex byte             | e.g. `\x7A` → "z"                        |
| `\uXXXX`    | 4-hex Unicode        | e.g. `\u00E9` → "é"                      |
| `\u{1F600}` | Code point           | Works for astral chars (emoji)           |

> **Tip:** Prefer `\u{…}` for emoji/supplementary planes; `\uXXXX` can’t directly encode > U+FFFF.

---

## Immutability (quick note)

Strings are **immutable** in JS/TS: operations like `slice`, `replace`, `toUpperCase` return **new** strings. You never “edit in place”.

---

## Template literals: the power moves

### 1) Interpolation & multiline

```ts
const user = { name: "Amina", score: 42 };
const msg = `Hello ${user.name}!
Your score: ${user.score}.`;
```

### 2) `String.raw` — see the backslashes

```ts
String.raw`C:\Users\Name\file.txt`; // "C:\Users\Name\file.txt"
```

### 3) Tagged templates — customize processing

A tag function receives an array of **literal chunks** and **values** for `${...}`.

```ts
function upper(strings: TemplateStringsArray, ...vals: unknown[]) {
  return strings.map((s, i) => s + (vals[i] ?? "")).join("").toUpperCase();
}
upper`Hello, ${user.name}!`; // "HELLO, AMINA!"
```

We’ll build a practical `dedent` and an `html`-escaping tag in the exercises.

---

## Common pitfalls

* Mixing up **`\n` vs actual newline** in single/double-quoted strings (you can’t embed a literal newline there).
* Using `parseInt(str)` without a **radix** (we’ll cover Numbers later).
* Assuming `length` counts “characters” (it counts **UTF-16 code units**—covered in Strings L2).
* Forgetting to escape user content when building HTML. Use a **tag** to centralize escaping.

---

## Patterns

### Normalize mixed newlines (CRLF/CR → LF)

```ts
export const normalizeNewlines = (s: string) => s.replace(/\r\n?/g, "\n");
```

### Zero-pad identifiers

```ts
export function zeroPad(n: number, width: number) {
  const s = String(n);
  return s.length >= width ? s : "0".repeat(width - s.length) + s;
}
```

### Simple label maker (composition + templates)

```ts
export function label(user: string, score: number) {
  return `👤 ${user} — score: ${zeroPad(score, 3)}`;
}
```

---

## Exercises

### 1) `normalizeNewlines(s)` — CRLF/CR → LF

* Input may contain `\r\n` (Windows) or lone `\r` (old Mac).
* Return string with only `\n`.

**Starter — `normalizeNewlines.ts`**

```ts
export function normalizeNewlines(s: string): string {
  return s.replace(/\r\n?/g, "\n");
}
```

---

### 2) `zeroPad(n, width)` — left-pad with zeros

* `zeroPad(7, 3) → "007"`, `zeroPad(123, 2) → "123"`.

**Starter — `zeroPad.ts`**

```ts
export function zeroPad(n: number, width: number): string {
  const s = String(n);
  return s.length >= width ? s : "0".repeat(width - s.length) + s;
}
```

---

### 3) `dedent` — tagged template to strip common indentation

* Remove the minimal common leading spaces/tabs from all **non-empty** lines.
* Trim a single leading/trailing blank line if present.

**Starter — `dedent.ts`**

```ts
export function dedent(strings: TemplateStringsArray, ...vals: unknown[]): string {
  let raw = strings.map((s, i) => s + (vals[i] ?? "")).join("");
  // Normalize newlines first
  raw = raw.replace(/\r\n?/g, "\n");
  // Trim one leading/trailing blank line
  raw = raw.replace(/^\n/, "").replace(/\n\s*$/, "");
  // Compute common indent (ignore empty lines)
  const indents = raw
    .split("\n")
    .filter(line => line.trim().length)
    .map(line => line.match(/^[ \t]*/)?.[0].length ?? 0);
  const cut = indents.length ? Math.min(...indents) : 0;
  return raw
    .split("\n")
    .map(line => line.slice(0, cut).match(/^[ \t]*$/) ? line : line.slice(cut))
    .join("\n");
}
```

---

### 4) `htmlSafe` — tagged template that escapes interpolations

* Escape `& < > " '`.
* **Do not** escape the literal chunks (author-controlled).
* Provide a helper `unsafe(value)` to mark a value as trusted (pass-through).

**Starter — `htmlSafe.ts`**

```ts
const ESC: Record<string, string> = {
  "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;"
};
const re = /[&<>"']/g;
const esc = (s: string) => s.replace(re, ch => ESC[ch]);

export const unsafe = (x: unknown) => ({ __unsafe: String(x) });

export function htmlSafe(strings: TemplateStringsArray, ...vals: unknown[]) {
  let out = "";
  for (let i = 0; i < strings.length; i++) {
    out += strings[i];
    if (i < vals.length) {
      const v = vals[i];
      out += (v && typeof v === "object" && "__unsafe" in (v as any))
        ? (v as any).__unsafe
        : esc(String(v));
    }
  }
  return out;
}
```

---

### 5) `labelMaker(user, score)` — small composition task

* Use template literals + `zeroPad`.
* Example: `labelMaker("Amina", 5) → "👤 Amina — score: 005"`

**Starter — `labelMaker.ts`**

```ts
import { zeroPad } from "./zeroPad";

export function labelMaker(user: string, score: number): string {
  return `👤 ${user} — score: ${zeroPad(score, 3)}`;
}
```

---

## Quiz (checks)

1. Which literal form allows **actual** newlines without `\n`?
   A) `'single quotes'`
   B) `"double quotes"`
   C) **\`template literals\`** ✅
   D) None

2. Which escape can encode 😀 (U+1F600) directly?
   A) `\uFFFF`
   B) **`\u{1F600}`** ✅
   C) `\xF6`
   D) `\0`

3. `String.raw\`a\nb\``returns:  
   A)`"a\nb"`  
   B) **`"a\nb"`** ✅  
   C) `"a\\\nb"` 
   D)`"anb"\`

4. Tagged templates receive:
   A) One concatenated string only
   B) **An array of literal chunks + values for each interpolation** ✅
   C) Only values
   D) AST nodes

5. Strings in JS are:
   A) Mutable byte arrays
   B) **Immutable sequences of UTF-16 code units** ✅
   C) Arrays of code points
   D) Always ASCII

---

## Takeaways

* Use **template literals** for interpolation and multi-line strings; keep single/double quotes for simple literals.
* Know the common **escapes** and prefer `\u{…}` for emoji/supplementary characters.
* Strings are **immutable**—build new strings (often via array `join` for bulk work).
* Tagged templates let you centralize concerns like **dedenting** and **escaping**.

---

## What’s next

Move to **Strings L1 — Length, Indexing & Immutability** to learn how `length` really works (UTF-16), `charAt/codePointAt`, and why iterating by **code point** matters for correctness.