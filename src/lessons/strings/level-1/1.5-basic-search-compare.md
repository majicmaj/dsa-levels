---
id: strings-l1-basic-search-compare
title: "Basic Search & Compare"
topic: strings
level: 1
lesson: 1.5
prereqs:
  - strings-l1-literals-escapes-templates
  - strings-l1-length-indexing-immutability
  - strings-l1-slice-substring-substr
outcomes:
  - "Choose the right primitive for search: `includes`, `indexOf/lastIndexOf`, `startsWith/endsWith`"
  - Use **from-index** arguments to continue searches and implement “find all”
  - Understand **case sensitivity**, naive case-folding, and when to reach for locale-aware tools
  - Compare strings with `localeCompare` vs relational operators, and know sorting implications
  - "Build small utilities: `findAll`, `startsWithOneOf`, `indexOfIgnoreCase`, `lastIndexBefore`, and `compareBasic`"
tags: ["strings","search","includes","indexOf","lastIndexOf","startsWith","endsWith","localeCompare","case-insensitive"]
est_minutes: 35
checks:
  - type: quiz
    id: strings-l1-basic-search-compare-quiz
  - type: unit
    entry: findAll.ts
    tests: findAll.test.ts
  - type: unit
    entry: startsWithOneOf.ts
    tests: startsWithOneOf.test.ts
  - type: unit
    entry: indexOfIgnoreCase.ts
    tests: indexOfIgnoreCase.test.ts
  - type: unit
    entry: lastIndexBefore.ts
    tests: lastIndexBefore.test.ts
  - type: unit
    entry: compareBasic.ts
    tests: compareBasic.test.ts
---

## Why this matters

Most everyday string work is **search & compare**: “does it contain?”, “where’s the next one?”, “does it start/end with…?”, “sort these names.” These primitives are fast, built-in, and compose nicely—no regex required (until you actually need patterns).

> All positions are in **UTF-16 code units**. Searching can split emoji/graphemes; that’s acceptable for technical strings (URLs, tokens) but for user-visible text you’ll pair search with the Unicode tools from L2/L5.

---

## The core tools

### Presence check
```ts
"Hello".includes("ell");  // true
"Hello".includes("ell", 2); // false (start searching at index 2)
````

### First / last occurrence (index or -1)

```ts
const s = "bananas";
s.indexOf("na");              // 2
s.indexOf("na", 3);           // 4  (resume search from index 3)
s.lastIndexOf("na");          // 4
s.lastIndexOf("na", 3);       // 2  (search backward starting at index 3)
"abc".indexOf("z");           // -1
```

### Prefix / suffix

```ts
"/api/users".startsWith("/api/"); // true
"report.csv".endsWith(".csv");    // true
```

### Compare (sorting / ordering)

```ts
"a" < "b";                 // true (code unit order)
"ä".localeCompare("z");    // locale-aware comparison (default locale)
"10".localeCompare("2");   // "1" < "2" → returns -1 (not numeric-aware)
```

> `localeCompare` is **synchronous** and accepts options/locales; for heavy-duty sorting, prefer `Intl.Collator` (we visit this in L5).

---

## Patterns you’ll reuse

### Find all occurrences (non-overlapping, or overlapping)

```ts
export function findAll(hay: string, needle: string, opts: { overlap?: boolean } = {}) {
  if (needle === "") return []; // define policy; empty matches are messy
  const overlap = !!opts.overlap;
  const out: number[] = [];
  let i = 0;
  while (true) {
    const j = hay.indexOf(needle, i);
    if (j === -1) break;
    out.push(j);
    i = j + (overlap ? 1 : needle.length);
  }
  return out;
}
```

### Starts with any of a list (return match or `null`)

```ts
export function startsWithOneOf(s: string, prefixes: readonly string[]): string | null {
  for (const p of prefixes) if (s.startsWith(p)) return p;
  return null;
}
```

### Case-insensitive search (naive fold)

```ts
export function indexOfIgnoreCase(hay: string, needle: string, from = 0): number {
  return hay.toLowerCase().indexOf(needle.toLowerCase(), from);
}
```

> Naive folding is often okay for **ASCII-ish** matching. For true locale-aware case behavior (e.g., Turkish “İ/i”), use `toLocaleLowerCase(locale)` or better: normalize + `Intl.Collator` (L5).

### Last index **before** a bound

```ts
export function lastIndexBefore(s: string, token: string, before: number): number {
  // `before` is an index *inclusive* bound for the backward search.
  return s.lastIndexOf(token, Math.max(0, Math.min(before, s.length - 1)));
}
```

### Compare three-way (−1/0/+1) with options

```ts
export type CompareMode = "codeunit" | "locale";
export function compareBasic(a: string, b: string, mode: CompareMode = "codeunit"): number {
  if (mode === "locale") return a.localeCompare(b);
  if (a === b) return 0;
  return a < b ? -1 : 1; // code unit order
}
```

---

## Common pitfalls

* **Forgetting the from-index.** `indexOf(needle, from)` lets you **resume** a scan; don’t re-scan from the start.
* **Overlapping matches.** `"aaaa"` with `"aa"` has indices `[0,2]` (non-overlap) or `[0,1,2]` (overlap). Be explicit.
* **Case sensitivity.** All these primitives are case-sensitive; if you need case-insensitive, **fold both sides** (with caveats) or use `Intl.Collator`.
* **Sorting surprises.** `"10" < "2"` vs **numeric** expectations—use collator with `{ numeric: true }` later (L5).
* **Graphemes.** An index points to a **unit**; slicing around a match can bisect emoji/combining sequences. For UI, prefer grapheme-safe boundaries (L2).

---

## Exercises

### 1) `findAll(hay, needle, {overlap?})`

Return an array of start indices; default to **non-overlapping**. If `needle === ""`, return `[]`.

**Starter — `findAll.ts`**

```ts
export function findAll(hay: string, needle: string, opts: { overlap?: boolean } = {}): number[] {
  if (needle === "") return [];
  const overlap = !!opts.overlap;
  const out: number[] = [];
  let i = 0;
  while (true) {
    const j = hay.indexOf(needle, i);
    if (j === -1) break;
    out.push(j);
    i = j + (overlap ? 1 : needle.length);
  }
  return out;
}
```

---

### 2) `startsWithOneOf(s, prefixes)`

Return the matched prefix or `null`.

**Starter — `startsWithOneOf.ts`**

```ts
export function startsWithOneOf(s: string, prefixes: readonly string[]): string | null {
  for (const p of prefixes) if (s.startsWith(p)) return p;
  return null;
}
```

---

### 3) `indexOfIgnoreCase(hay, needle, from?)`

Naively fold both sides with `.toLowerCase()` and search from `from` (default 0).

**Starter — `indexOfIgnoreCase.ts`**

```ts
export function indexOfIgnoreCase(hay: string, needle: string, from = 0): number {
  return hay.toLowerCase().indexOf(needle.toLowerCase(), from);
}
```

---

### 4) `lastIndexBefore(s, token, before)`

Use `lastIndexOf`’s second arg to find the last occurrence **at or before** `before`.

**Starter — `lastIndexBefore.ts`**

```ts
export function lastIndexBefore(s: string, token: string, before: number): number {
  return s.lastIndexOf(token, Math.max(0, Math.min(before, s.length - 1)));
}
```

---

### 5) `compareBasic(a, b, mode?)`

Return −1/0/+1 using either code-unit order or `localeCompare`.

**Starter — `compareBasic.ts`**

```ts
export type CompareMode = "codeunit" | "locale";
export function compareBasic(a: string, b: string, mode: CompareMode = "codeunit"): number {
  if (mode === "locale") return a.localeCompare(b);
  if (a === b) return 0;
  return a < b ? -1 : 1;
}
```

---

## Quiz (checks)

1. Which method returns **−1** when not found?
   A) `includes`
   B) **`indexOf`** ✅
   C) `startsWith`
   D) `endsWith`

2. `lastIndexOf("na", 3)` on `"bananas"` returns:
   A) 4
   B) **2** ✅
   C) 3
   D) −1

3. `includes(needle, fromIndex)` begins searching:
   A) From the start
   B) **At index `fromIndex`** ✅
   C) From the end
   D) It ignores `fromIndex`

4. A naive case-insensitive search should:
   A) Lowercase the haystack only
   B) Uppercase the needle only
   C) **Fold both strings consistently (e.g., `.toLowerCase()`)** ✅
   D) Use regex always

5. For locale-aware sorting you should prefer (later):
   A) `a < b`
   B) **`Intl.Collator(locale, options)`** ✅
   C) `JSON.stringify(a).localeCompare(b)`
   D) `Math.sign(a.length - b.length)`

---

## Takeaways

* Use **`includes`** for yes/no, **`indexOf/lastIndexOf`** for precise positions, and **`startsWith/endsWith`** for edges.
* Control your scan with the **from-index**; build **find-all** with a simple loop.
* Be explicit about **case** and **overlaps**.
* For ordering, `localeCompare` works in a pinch; **`Intl.Collator`** is the scalable option (L5).
* Remember indices are **code units**; grapheme safety arrives in L2.

---

## What’s next

We’re stepping into **Strings L2 — UTF-16 vs Code Points (Essentials)** to get rock-solid on code points, surrogate pairs, and grapheme clusters—so your searches, slices, and counts match what users actually see.