---
id: strings-l1-slice-substring-substr
title: "slice vs substring (and legacy substr)"
topic: strings
level: 1
lesson: 1.2
prereqs:
  - strings-l1-literals-escapes-templates
  - strings-l1-length-indexing-immutability
outcomes:
  - Distinguish `slice`, `substring`, and legacy `substr` by **arguments** and **edge cases**
  - Predict behavior for **negative indices**, **out-of-bounds**, and **start > end**
  - "Use idiomatic patterns: **take / drop / takeLast / before / after / between**"
  - Know when **code point or grapheme–safe slicing** is required (pointer to L2)
tags: ["strings","slice","substring","substr","indices","patterns"]
est_minutes: 35
checks:
  - type: quiz
    id: strings-l1-slice-substring-quiz
  - type: unit
    entry: takeDrop.ts
    tests: takeDrop.test.ts
  - type: unit
    entry: takeLast.ts
    tests: takeLast.test.ts
  - type: unit
    entry: beforeAfter.ts
    tests: beforeAfter.test.ts
  - type: unit
    entry: between.ts
    tests: between.test.ts
  - type: unit
    entry: clip.ts
    tests: clip.test.ts
---

## Why this matters

These three look similar but **do not** behave the same—especially with negatives and swapped arguments. Picking the right one saves you from subtle off-by-one and empty-string bugs.

> Reminder: all of these operate on **UTF-16 code units**. They can split emoji or combining marks. For code point or grapheme-safe versions, use utilities from previous/next lessons (`sliceByCodePoint`, `Intl.Segmenter` in L2).

---

## TL;DR comparison

| Method | Signature | Negatives | If `start > end` | End arg meaning | Notes |
|---|---|---|---|---|---|
| **`slice(start, end?)`** | indexes | **Allowed** (from end) | **No swap** (returns `""`) | **exclusive end index** | Most predictable; array-like |
| **`substring(start, end?)`** | indexes | **Clamped to 0** | **Swaps** arguments | **exclusive end index** | Historical quirks |
| **`substr(start, length?)`** *(legacy)* | start + **length** | **Allowed** (from end) | n/a | length in units | Legacy/non-standard: avoid in new code |

### Quick mental rules
- Want negative from the end? → **`slice`** (or legacy `substr`).
- Might pass args in any order? → **`substring`** (it swaps).
- Want “take N from start”? → `slice(0, N)`.
- Want “take N from end”? → `slice(-N)`.

---

## Behavior walkthrough

```ts
const s = "abcdef";

// slice(start, end?)
s.slice(2);        // "cdef"
s.slice(2, 5);     // "cde"  (end exclusive)
s.slice(-2);       // "ef"   (from end)
s.slice(5, 2);     // ""     (no swap)

// substring(start, end?)
s.substring(2);    // "cdef"
s.substring(2, 5); // "cde"
s.substring(5, 2); // "cde"  (SWAPS to (2,5))
s.substring(-2);   // "abcdef" (negatives -> 0)

// substr(start, length?)  (legacy)
s.substr(2, 3);    // "cde"
s.substr(-2);      // "ef"   (start from end)
````

**Out-of-bounds**
All three clamp the result within the string. Overlarge ends don’t throw; you just get fewer characters.

---

## Common patterns (idiomatic)

```ts
// Take / drop (from start)
const take    = (s: string, n: number) => s.slice(0, Math.max(0, n));
const drop    = (s: string, n: number) => s.slice(Math.max(0, n));

// Take from the end
const takeLast = (s: string, n: number) => n <= 0 ? "" : s.slice(-n);

// Before / after first occurrence
const beforeFirst = (s: string, token: string) => {
  const i = s.indexOf(token);
  return i < 0 ? s : s.slice(0, i);
};
const afterFirst = (s: string, token: string) => {
  const i = s.indexOf(token);
  return i < 0 ? "" : s.slice(i + token.length);
};

// Between markers (first match; exclusive by default)
function between(
  s: string,
  start: string,
  end: string,
  opts: { include?: "none" | "start" | "end" | "both"; from?: number } = {}
) {
  const from = Math.max(0, opts.from ?? 0);
  const i = s.indexOf(start, from);
  if (i < 0) return "";
  const j = s.indexOf(end, i + start.length);
  if (j < 0) return "";
  const inc = opts.include ?? "none";
  const a = inc === "start" || inc === "both" ? i : i + start.length;
  const b = inc === "end"   || inc === "both" ? j + end.length : j;
  return s.slice(a, b);
}
```

> Need **grapheme-safe** versions later? Swap `slice` for `sliceByCodePoint` or an `Intl.Segmenter` helper (Strings L2).

---

## Pitfalls

* `substring(-2)` **doesn’t** count from the end—it treats negative as `0`.
* `slice(start, end)` does **not** swap if reversed; you might get `""`.
* `substr` uses **length**, not end index, and is considered **legacy**—don’t introduce it in new code.
* All three can split surrogate pairs (emoji) and combining sequences; prefer code point/grapheme-aware utilities when output is user-visible.

---

## Exercises

### 1) `takeDrop(s, n)` — basic helpers

Implement:

* `take(s, n)` → first `n` units (use `slice`), clamp `n < 0` to `0`.
* `drop(s, n)` → remove first `n` units (use `slice`), clamp `n < 0` to `0`.

**Starter — `takeDrop.ts`**

```ts
export const take = (s: string, n: number) =>
  s.slice(0, Math.max(0, n));

export const drop = (s: string, n: number) =>
  s.slice(Math.max(0, n));
```

---

### 2) `takeLast(s, n)` — from the right

Return the last `n` units; for `n <= 0` return `""`.

**Starter — `takeLast.ts`**

```ts
export function takeLast(s: string, n: number): string {
  return n <= 0 ? "" : s.slice(-n);
}
```

---

### 3) `beforeAfter(s, token)` — split once

Return a tuple `[before, after]` around the **first** `token`. If missing, return `[s, ""]`.

**Starter — `beforeAfter.ts`**

```ts
export function beforeAfter(s: string, token: string): [string, string] {
  const i = s.indexOf(token);
  return i < 0 ? [s, ""] : [s.slice(0, i), s.slice(i + token.length)];
}
```

---

### 4) `between(s, start, end, opts?)` — extract window

Exclusive by default; support `include: "none" | "start" | "end" | "both"` and optional `from` index to start searching.

**Starter — `between.ts`**

```ts
export type BetweenOpts = { include?: "none" | "start" | "end" | "both"; from?: number };

export function between(s: string, start: string, end: string, opts: BetweenOpts = {}): string {
  const from = Math.max(0, opts.from ?? 0);
  const i = s.indexOf(start, from);
  if (i < 0) return "";
  const j = s.indexOf(end, i + start.length);
  if (j < 0) return "";
  const inc = opts.include ?? "none";
  const a = inc === "start" || inc === "both" ? i : i + start.length;
  const b = inc === "end"   || inc === "both" ? j + end.length : j;
  return s.slice(a, b);
}
```

---

### 5) `clip(s, max, ellipsis="…")` — truncate safely by units

If `s.length <= max`, return `s`. Else return `s.slice(0, max - ellipsis.length) + ellipsis`. Clamp `max <= ellipsis.length` to just `ellipsis.slice(0, max)`.

*(We’ll do grapheme-aware clipping in L2.)*

**Starter — `clip.ts`**

```ts
export function clip(s: string, max: number, ellipsis = "…"): string {
  if (max <= 0) return "";
  if (s.length <= max) return s;
  if (max <= ellipsis.length) return ellipsis.slice(0, max);
  return s.slice(0, max - ellipsis.length) + ellipsis;
}
```

---

## Quiz (checks)

1. Which method **allows negative indices** that count from the end?
   A) `substring`
   B) **`slice`** ✅
   C) Only `substr`
   D) None

2. `substring(7, 2)` returns:
   A) `""`
   B) Throws
   C) **Same as `substring(2, 7)`** ✅
   D) Same as `slice(7, 2)`

3. The **second argument** of `slice(start, end)` is:
   A) Included index
   B) **Excluded end index** ✅
   C) Length
   D) Required

4. Why avoid `substr` in new code?
   A) It’s slow
   B) **Legacy/non-standard; start is index, second is length** ✅
   C) It throws on negatives
   D) It swaps arguments

5. You need to **take last 3 units** quickly. Pick:
   A) `substring(-3)`
   B) `substring(length - 3)`
   C) **`slice(-3)`** ✅
   D) `slice(0, -3)`

---

## Takeaways

* Prefer **`slice`** for predictability (negatives, no swaps).
* Use **`substring`** only if you want automatic arg swapping; avoid negatives.
* Treat **`substr`** as legacy; don’t introduce it.
* Remember: these work on **code units**; for emoji-safe behavior use the code point/grapheme tools in L1/L2.

---

## What’s next

Next up: **Strings L1 — Concat & Template Performance Basics** — when to use `+`, `concat`, template literals, and when array **push + join** helps for big builds.
