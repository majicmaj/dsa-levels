---
id: strings-l1-concat-templates-perf-basics
title: "Concat & Template Performance Basics"
topic: strings
level: 1
lesson: 1.3
prereqs:
  - strings-l1-literals-escapes-templates
  - strings-l1-length-indexing-immutability
  - strings-l1-slice-substring-substr
outcomes:
  - Choose between `+`, template literals, `String.prototype.concat`, and **array join** for building strings
  - Avoid **quadratic concatenation** by batching many small pieces with `push` + `join`
  - Use `String.prototype.repeat` and tiny helpers (indent, lines) for clean composition
  - Build a minimal **StringBuilder** (array-backed) for large/streamy outputs
  - Know when to reach for **tagged templates** for readability/safety (HTML escaping cross-link)
tags: ["strings","concatenation","template-literals","performance","join","repeat","string-builder"]
est_minutes: 35
checks:
  - type: quiz
    id: strings-l1-concat-perf-quiz
  - type: unit
    entry: stringBuilder.ts
    tests: stringBuilder.test.ts
  - type: unit
    entry: joinLines.ts
    tests: joinLines.test.ts
  - type: unit
    entry: indent.ts
    tests: indent.test.ts
  - type: unit
    entry: csvLine.ts
    tests: csvLine.test.ts
  - type: unit
    entry: repeatChunk.ts
    tests: repeatChunk.test.ts
---

## Why this matters

You’ll concatenate strings constantly—logs, CSV/HTML, code generators, problem solutions. Picking the right tool keeps code **readable** and avoids accidental **O(n²)** behavior when building big outputs.

---

## Your options (and when to use them)

### 1) `+` and template literals — clarity first
- Small, fixed number of pieces? Prefer these.
```ts
const name = "Amina", score = 42;
// Either is fine; templates read better with variables or newlines:
const a = "User: " + name + " (#" + score + ")";
const b = `User: ${name} (#${score})`;
````

### 2) `String.prototype.concat` — just say no (mostly)

* Rarely used; offers no real benefit over `+`.

```ts
"Hello".concat(", ", "world"); // same idea as "Hello" + ", " + "world"
```

### 3) Many small parts? Use **array push + join**

* Avoid `result += piece` in long loops. Batch pieces, then `join("")`.

```ts
const parts: string[] = [];
for (let i = 0; i < 10_000; i++) parts.push(String(i), ",");
const out = parts.join(""); // fewer intermediate strings
```

> Engines optimize a lot, but a safe rule: when concatenating **hundreds+** pieces in a loop, prefer **`join`**.

### 4) Repeated characters → `repeat`

```ts
" ".repeat(4) + "indented";
"─".repeat(80); // divider
```

### 5) Tagged templates for safety/readability

* Centralize escaping, dedenting, etc. (see `htmlSafe` and `dedent` from L1).
* Great for “structured” strings where correctness matters.

---

## Pitfalls & guardrails

* **Quadratic concatenation**: `s += chunk` repeatedly can copy the growing string each time. Use **push+join** or a builder for large outputs.
* **Unclear concatenation**: prefer templates when variables are interleaved with literals.
* **Premature micro-benching**: don’t optimize 5–10 concatenations—use the most readable form.
* **Unicode reminder**: concatenation doesn’t alter code units; emoji correctness still depends on your slicing/iteration (see L1/L2).

---

## Handy composition helpers

### Lines & blocks

```ts
export const joinLines = (lines: (string | undefined | null)[], sep = "\n") =>
  lines.filter(Boolean).join(sep);

export const indent = (text: string, n: number, ch = " ") =>
  text.split("\n").map(line => ch.repeat(n) + line).join("\n");
```

### CSV (one line; simple)

```ts
// Double quotes must be doubled per RFC4180-ish; commas/quotes/newlines get quoted
export function csvLine(fields: (string | number | boolean | null | undefined)[]): string {
  return fields.map(v => {
   
```
