---
id: strings-l1-concat-templates-perf-basics
title: "Concat & Template Performance Basics"
topic: strings
level: 1
lesson: 1.3
prereqs:
  - strings-l1-literals-escapes-templates
  - strings-l1-length-indexing-immutability
  - strings-l1-slice-substring-substr
outcomes:
  - Choose between `+`, template literals, `String.prototype.concat`, and **array join** for building strings
  - Avoid **quadratic concatenation** by batching many small pieces with `push` + `join`
  - Use `String.prototype.repeat` and tiny helpers (indent, lines) for clean composition
  - Build a minimal **StringBuilder** (array-backed) for large/streamy outputs
  - Know when to reach for **tagged templates** for readability/safety (HTML escaping cross-link)
tags: ["strings","concatenation","template-literals","performance","join","repeat","string-builder"]
est_minutes: 35
checks:
  - type: quiz
    id: strings-l1-concat-perf-quiz
  - type: unit
    entry: stringBuilder.ts
    tests: stringBuilder.test.ts
  - type: unit
    entry: joinLines.ts
    tests: joinLines.test.ts
  - type: unit
    entry: indent.ts
    tests: indent.test.ts
  - type: unit
    entry: csvLine.ts
    tests: csvLine.test.ts
  - type: unit
    entry: repeatChunk.ts
    tests: repeatChunk.test.ts
---

## Why this matters

You’ll concatenate strings constantly—logs, CSV/HTML, code generators, problem solutions. Picking the right tool keeps code **readable** and avoids accidental **O(n²)** behavior when building big outputs.

---

## Your options (and when to use them)

### 1) `+` and template literals — clarity first
- Small, fixed number of pieces? Prefer these.
```ts
const name = "Amina", score = 42;
// Either is fine; templates read better with variables or newlines:
const a = "User: " + name + " (#" + score + ")";
const b = `User: ${name} (#${score})`;
````

### 2) `String.prototype.concat` — just say no (mostly)

* Rarely used; offers no real benefit over `+`.

```ts
"Hello".concat(", ", "world"); // same idea as "Hello" + ", " + "world"
```

### 3) Many small parts? Use **array push + join**

* Avoid `result += piece` in long loops. Batch pieces, then `join("")`.

```ts
const parts: string[] = [];
for (let i = 0; i < 10_000; i++) parts.push(String(i), ",");
const out = parts.join(""); // fewer intermediate strings
```

> Engines optimize a lot, but a safe rule: when concatenating **hundreds+** pieces in a loop, prefer **`join`**.

### 4) Repeated characters → `repeat`

```ts
" ".repeat(4) + "indented";
"─".repeat(80); // divider
```

### 5) Tagged templates for safety/readability

* Centralize escaping, dedenting, etc. (see `htmlSafe` and `dedent` from L1).
* Great for “structured” strings where correctness matters.

---

## Pitfalls & guardrails

* **Quadratic concatenation**: `s += chunk` repeatedly can copy the growing string each time. Use **push+join** or a builder for large outputs.
* **Unclear concatenation**: prefer templates when variables are interleaved with literals.
* **Premature micro-benching**: don’t optimize 5–10 concatenations—use the most readable form.
* **Unicode reminder**: concatenation doesn’t alter code units; emoji correctness still depends on your slicing/iteration (see L1/L2).

---

## Handy composition helpers

### Lines & blocks

```ts
export const joinLines = (lines: (string | undefined | null)[], sep = "\n") =>
  lines.filter(Boolean).join(sep);

export const indent = (text: string, n: number, ch = " ") =>
  text.split("\n").map(line => ch.repeat(n) + line).join("\n");
```

### CSV (one line; simple)

```ts
// Double quotes must be doubled per RFC4180-ish; commas/quotes/newlines get quoted
export function csvLine(fields: (string | number | boolean | null | undefined)[]): string {
  return fields.map(v => {
    let s = v == null ? "" : String(v);
    const mustQuote = /[",\r\n]/.test(s);
    if (mustQuote) s = `"${s.replace(/"/g, '""')}"`;
    return s;
  }).join(",");
}
```

### Efficient “repeat chunk” (doubling)

```ts
// Repeat a chunk N times using "doubling" to keep concatenations ~O(log N)
export function repeatChunk(chunk: string, count: number): string {
  if (!Number.isFinite(count) || count <= 0) return "";
  let res = "", pat = chunk;
  let n = Math.floor(count);
  while (n > 0) {
    if (n & 1) res += pat;
    n >>= 1;
    if (n) pat += pat;
  }
  return res;
}
```

---

## Minimal StringBuilder (array-backed)

When building very large strings with lots of conditionals/loops, use a tiny helper to batch pieces:

```ts
export class StringBuilder {
  private parts: string[] = [];

  append(s: string): this {
    this.parts.push(s);
    return this;
  }

  line(s = ""): this {
    this.parts.push(s, "\n");
    return this;
  }

  repeat(s: string, n: number): this {
    if (Number.isFinite(n) && n > 0) this.parts.push(s.repeat(Math.floor(n)));
    return this;
  }

  clear(): this {
    this.parts.length = 0;
    return this;
  }

  toString(): string {
    return this.parts.join("");
  }
}
```

Usage:

```ts
const b = new StringBuilder();
b.append("Users:").line()
 .append("- ").append("Amina").line()
 .append("- ").append("Lee").line();
const out = b.toString();
```

> This is still strings under the hood—no mutation. It just **reduces intermediate copies** by deferring to a single `join`.

---

## Exercises

### 1) `stringBuilder.ts` — implement the class above

* Methods: `append`, `line`, `repeat`, `clear`, `toString`.
* Chainable API (return `this`).

**Starter — `stringBuilder.ts`**

```ts
export class StringBuilder {
  private parts: string[] = [];
  append(s: string): this { this.parts.push(s); return this; }
  line(s = ""): this { this.parts.push(s, "\n"); return this; }
  repeat(s: string, n: number): this {
    if (Number.isFinite(n) && n > 0) this.parts.push(s.repeat(Math.floor(n)));
    return this;
  }
  clear(): this { this.parts.length = 0; return this; }
  toString(): string { return this.parts.join(""); }
}
```

---

### 2) `joinLines.ts` — join non-empty lines with a separator

* Skip `null`/`undefined`/`""` by default.

**Starter — `joinLines.ts`**

```ts
export const joinLines = (lines: (string | null | undefined)[], sep = "\n") =>
  lines.filter(Boolean).join(sep);
```

---

### 3) `indent.ts` — indent a block by N characters

* Default fill char is space `" "`.

**Starter — `indent.ts`**

```ts
export const indent = (text: string, n: number, ch = " ") =>
  text.split("\n").map(line => ch.repeat(n) + line).join("\n");
```

---

### 4) `csvLine.ts` — CSV-encode a single row

* Quote fields containing commas, quotes, or newlines.
* Double inner quotes.

**Starter — `csvLine.ts`**

```ts
export function csvLine(fields: (string | number | boolean | null | undefined)[]): string {
  return fields.map(v => {
    let s = v == null ? "" : String(v);
    const mustQuote = /[",\r\n]/.test(s);
    if (mustQuote) s = `"${s.replace(/"/g, '""')}"`;
    return s;
  }).join(",");
}
```

---

### 5) `repeatChunk.ts` — repeat with doubling

* Implement `repeatChunk(chunk, count)` using the doubling strategy.

**Starter — `repeatChunk.ts`**

```ts
export function repeatChunk(chunk: string, count: number): string {
  if (!Number.isFinite(count) || count <= 0) return "";
  let res = "", pat = chunk;
  let n = Math.floor(count);
  while (n > 0) {
    if (n & 1) res += pat;
    n >>= 1;
    if (n) pat += pat;
  }
  return res;
}
```

---

## Quiz (checks)

1. For 2–3 small pieces, you should prefer:
   A) Array `join("")`
   B) **`+` or template literals** ✅
   C) `String.prototype.concat`
   D) A custom StringBuilder

2. Building a very long string in a loop is safest with:
   A) `result = result + chunk`
   B) **`parts.push(chunk)` then `parts.join("")`** ✅
   C) `substr`
   D) `JSON.stringify`

3. When should you consider **tagged templates**?
   A) Always
   B) Only when repeating characters
   C) **When you need centralized escaping/dedenting or readability** ✅
   D) When sorting strings

4. `repeatChunk("ab", 5)` should return:
   A) `"ab"`
   B) `"abab"`
   C) **`"ababababab"`** ✅
   D) `"ab5"`

5. The StringBuilder pattern mainly helps by:
   A) Mutating strings in place
   B) **Reducing intermediate concatenations and deferring to one `join`** ✅
   C) Making code shorter
   D) Handling Unicode normalization

---

## Takeaways

* Prefer **templates/`+`** for small, fixed concatenations; **push+join** for many pieces.
* Use `repeat` (or `repeatChunk`) for patterns; compose helpers like `indent`/`joinLines`/`csvLine`.
* A tiny **StringBuilder** can keep large outputs clear and efficient.
* Reach for **tagged templates** when you need safety or structured output.

---

## What’s next

Head to **Strings L1 — Trim, Pad & Repeat** (or continue if you already did it), then **Strings L1 — Basic Search & Compare**. After L1 wraps, we’ll move into **Unicode correctness** in L2 so your slicing/counting matches what users actually see.
