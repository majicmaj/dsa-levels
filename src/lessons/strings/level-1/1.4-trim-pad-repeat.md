---
id: strings-l1-trim-pad-repeat
title: "Trim, Pad & Repeat"
topic: strings
level: 1
lesson: 1.4
prereqs:
  - strings-l1-literals-escapes-templates
  - strings-l1-length-indexing-immutability
  - strings-l1-slice-substring-substr
outcomes:
  - Use `trim`, `trimStart`, `trimEnd` to remove **Unicode whitespace** reliably
  - Align text with `padStart` / `padEnd`; understand **target length**, pad string truncation, and edge cases
  - Generate repeated patterns with `repeat` (and safe wrappers)
  - "Build practical helpers: `stripPrefix/stripSuffix`, `trimChars`, `center`, and column formatting"
  - Know when padding/slicing by **code units** can break emoji/aligned output (preview L2/L5)
tags: ["strings","trim","padStart","padEnd","repeat","whitespace","formatting"]
est_minutes: 35
checks:
  - type: quiz
    id: strings-l1-trim-pad-repeat-quiz
  - type: unit
    entry: stripPrefixSuffix.ts
    tests: stripPrefixSuffix.test.ts
  - type: unit
    entry: trimChars.ts
    tests: trimChars.test.ts
  - type: unit
    entry: padLeftRight.ts
    tests: padLeftRight.test.ts
  - type: unit
    entry: center.ts
    tests: center.test.ts
  - type: unit
    entry: columns.ts
    tests: columns.test.ts
crosslinks:
  - { to: strings-l1-concat-templates-perf-basics, why: "Combine padding/repeat with composition patterns" }
  - { to: arrays-l2-arrays-map-filter-reduce-flatmap, why: "Compose formatting over arrays with map/filter/reduce" }
---

## Why this matters

Most UI and CLI output needs **clean edges** and **aligned columns**. JavaScript gives you three small but mighty tools—`trim*`, `pad*`, and `repeat`—that compose into many formatting tasks: zero-padding IDs, masking sensitive strings, pretty tables, etc.

> Note: these operate on **UTF-16 code units**. Alignment with emoji/grapheme clusters can drift (Strings L2/L5 show grapheme/locale-aware options).

---

## Trim family

- `s.trim()` removes **Unicode whitespace** from both ends (spaces, tabs, NBSP, BOM, etc.).
- `trimStart()` / `trimEnd()` affect only one side.

```ts
"  hello  ".trim();        // "hello" (note: NBSP counted)
"\uFEFFtitle".trimStart(); // remove BOM at start
````

> If you need to trim **specific characters**, use a custom function (see `trimChars` below).

---

## Padding: `padStart` / `padEnd`

Signature: `s.padStart(targetLength, padString = " ")` (and same for `padEnd`).

Rules you must remember:

* If `targetLength <= s.length`, return `s` unchanged.
* If `padString` is empty `""`, return `s` unchanged.
* Padding **repeats** `padString` and **truncates** to fit exactly.
* Counting is in **code units**.

```ts
"42".padStart(5, "0");     // "00042"
"cat".padEnd(8, ".-");     // "cat.-.-" (".-" repeated and truncated)
"hello".padStart(3);       // "hello" (already long enough)
```

---

## Repetition: `repeat`

Signature: `"x".repeat(count)`

* Throws `RangeError` if `count < 0` or `count` is infinite/too large.
* Fractional counts are floored.

```ts
"=".repeat(5);             // "====="
"ha".repeat(3);            // "hahaha"
```

**Safe wrapper** (avoid accidental negatives):

```ts
export function safeRepeat(s: string, n: number): string {
  if (!Number.isFinite(n) || n <= 0) return "";
  return s.repeat(Math.floor(n));
}
```

---

## Practical helpers

### Strip prefix/suffix (if present)

```ts
export function stripPrefix(s: string, prefix: string) {
  return s.startsWith(prefix) ? s.slice(prefix.length) : s;
}
export function stripSuffix(s: string, suffix: string) {
  return s.endsWith(suffix) ? s.slice(0, -suffix.length) : s;
}
```

### Trim specific characters (not just whitespace)

* Remove **a set of chars** from both ends (e.g., quotes, slashes).

```ts
export function trimChars(s: string, chars: string): string {
  if (!chars) return s;
  const set = new Set(Array.from(chars));
  let a = 0, b = s.length;
  while (a < b && set.has(s[a]!)) a++;
  while (b > a && set.has(s[b - 1]!)) b--;
  return s.slice(a, b);
}

// trimChars(`///path///`, "/") -> "path"
```

### Left/right pad with a single fill char

```ts
export const padLeft  = (s: string, w: number, ch = " ") => s.padStart(w, ch);
export const padRight = (s: string, w: number, ch = " ") => s.padEnd(w, ch);
```

### Center within a width

```ts
export function center(s: string, width: number, fill = " ") {
  if (s.length >= width) return s;
  const total = width - s.length;
  const left = Math.floor(total / 2);
  const right = total - left;
  return fill.repeat(left) + s + fill.repeat(right);
}
```

### Simple columns (monospace output)

```ts
type Row = Array<string | number | boolean | null | undefined>;

export function columns(rows: Row[], widths: number[], align: ("left"|"right")[] = []) {
  return rows.map((r) =>
    r.map((cell, i) => {
      const s = String(cell ?? "");
      const w = widths[i] ?? s.length;
      const a = align[i] ?? "left";
      return a === "right" ? s.padStart(w) : s.padEnd(w);
    }).join(" ")
  ).join("\n");
}

// columns([["id","name"],[1,"Amina"],[12,"Lee"]],[3,10],["right","left"])
```

> For emoji or full-width CJK characters, visual width ≠ code units. For true alignment in UI, prefer CSS/layout; for terminals, consider grapheme/width-aware libs (covered later).

---

## Common pitfalls

* **Assuming spaces only**: `trim` handles **Unicode** whitespace—good! Your custom regex might not; prefer `trim` for whitespace and `trimChars` for specific glyphs.
* **Empty pad string**: `padStart(len, "")` is a no-op.
* **Over-padding logic**: remember `targetLength` is final length, not “add N chars.”
* **Alignment with emoji**: `padStart/End` count code units; grapheme width may differ → alignment drifts (L2/L5 will address this).

---

## Exercises

### 1) `stripPrefixSuffix(s, pre, suf)`

If `s` starts with `pre`, remove it. If `s` ends with `suf`, remove it. Apply both sides if both match.

**Starter — `stripPrefixSuffix.ts`**

```ts
export function stripPrefixSuffix(s: string, pre: string, suf: string): string {
  if (s.startsWith(pre)) s = s.slice(pre.length);
  if (s.endsWith(suf)) s = s.slice(0, -suf.length);
  return s;
}
```

---

### 2) `trimChars(s, chars)`

Remove any of `chars` from both ends (use the Set approach above). Empty `chars` → return original.

**Starter — `trimChars.ts`**

```ts
export function trimChars(s: string, chars: string): string {
  if (!chars) return s;
  const set = new Set(Array.from(chars));
  let a = 0, b = s.length;
  while (a < b && set.has(s[a]!)) a++;
  while (b > a && set.has(s[b - 1]!)) b--;
  return s.slice(a, b);
}
```

---

### 3) `padLeftRight(s, w, ch?)`

Implement `padLeft` and `padRight` wrappers with a single `ch` (default space). Ensure `ch` isn’t empty—fallback to a space.

**Starter — `padLeftRight.ts`**

```ts
export const padLeft = (s: string, w: number, ch = " ") =>
  s.padStart(w, ch || " ");

export const padRight = (s: string, w: number, ch = " ") =>
  s.padEnd(w, ch || " ");
```

---

### 4) `center(s, width, fill?)`

Center `s` within `width` using `fill` (default space). If already wide enough, return `s`.

**Starter — `center.ts`**

```ts
export function center(s: string, width: number, fill = " "): string {
  if (s.length >= width) return s;
  const total = width - s.length;
  const left = Math.floor(total / 2);
  const right = total - left;
  return fill.repeat(left) + s + fill.repeat(right);
}
```

---

### 5) `columns(rows, widths, align?)`

Format rows as fixed-width columns (monospace assumption). Align entries per column.

**Starter — `columns.ts`**

```ts
type Row = Array<string | number | boolean | null | undefined>;

export function columns(
  rows: Row[],
  widths: number[],
  align: ("left"|"right")[] = []
): string {
  return rows.map((r) =>
    r.map((cell, i) => {
      const s = String(cell ?? "");
      const w = widths[i] ?? s.length;
      const a = align[i] ?? "left";
      return a === "right" ? s.padStart(w) : s.padEnd(w);
    }).join(" ")
  ).join("\n");
}
```

---

## Quiz (checks)

1. `trim()` removes:
   A) ASCII spaces only
   B) Tabs but not NBSP
   C) **Unicode whitespace at both ends** ✅
   D) All punctuation

2. `padStart(6, "ab")` on `"X"` yields:
   A) `"abXab"`
   B) **`"ababaX"`** (pad string truncated to fit) ✅
   C) `"aaaaaX"`
   D) `"Xababa"`

3. `"=".repeat(-1)` returns:
   A) `""`
   B) **Throws `RangeError`** ✅
   C) `"="`
   D) `"=-1"`

4. If `s.length >= targetLength`, `s.padEnd(targetLength)` returns:
   A) Padded string
   B) **`s` unchanged** ✅
   C) Truncated string
   D) Throws

5. For emoji-aligned columns, `padStart/End` may misalign because:
   A) They’re slow
   B) **They count code units, not grapheme display width** ✅
   C) They ignore tabs
   D) They trim whitespace first

---

## Takeaways

* `trim*` handles **Unicode whitespace**—use it for edges; write `trimChars` for specific glyphs.
* `padStart/End` target a **final length**, repeating and truncating the pad string as needed.
* `repeat` is your pattern generator; wrap it for safety with `safeRepeat`.
* For pretty output, compose small helpers like `stripPrefix/Suffix`, `center`, and `columns`.
* Mind code units vs display width; grapheme/locale-aware formatting comes in later levels.

---

## What’s next

Proceed to **Strings L1 — Basic Search & Compare**: `includes`, `indexOf/lastIndexOf`, `startsWith/endsWith`, and the gotchas of case-insensitive search and locale-aware comparisons.
