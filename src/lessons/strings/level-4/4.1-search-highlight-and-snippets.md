---
id: strings-l4-search-highlight-and-snippets
title: "Search, Highlight & Snippets"
topic: strings
level: 4
lesson: 4.1
prereqs: 
  - strings-l3-case-folding-and-simple-normalization
  - strings-l3-regex-basics-flags
  - strings-l3-regex-groups-capture-and-backrefs
  - strings-l3-regex-lookaround-alternation-quantifiers
  - strings-l2-safe-length-and-slicing
  - strings-l2-string-iteration-patterns
outcomes:
  - Build **folded search** that’s case-/accent-insensitive and Unicode-safe
  - Find **all match ranges** (non-overlapping by default; overlapping via lookahead) and **map them back** to original indices
  - "**Snap** unit ranges to **grapheme boundaries** for UI-safe highlights"
  - "**Merge/coalesce** overlapping/touching ranges and apply **HTML-safe** highlighting"
  - Generate **context snippets** around matches; score and select the **best** snippet
  - Handle **multi-term** queries (AND/OR) and per-term coloring
tags: ["strings","search","highlight","snippets","unicode","graphemes","case-folding","accent-folding","Intl.Segmenter"]
est_minutes: 55
concepts_introduced:
  - strings.search.folded_index
  - strings.highlight.grapheme_safe
  - strings.snippets.window_selection
concepts_reused:
  - strings.normalize.nfc
  - strings.casefold.simple
  - strings.unicode.graphemes
  - strings.unicode.safe_slice
  - strings.regex.lookaround
crosslinks:
  - { to: strings-l2-grapheme-clusters-and-emoji, why: "Snap ranges to grapheme boundaries before slicing UI text" }
  - { to: strings-l3-case-folding-and-simple-normalization, why: "Reuse folding pipeline for accent/case-insensitive search" }
  - { to: strings-l3-replace-replaceall, why: "Surrounding and escaping utilities build on replace patterns" }
checks:
  - type: quiz
    id: strings-l4-search-highlight-and-snippets-quiz
  - type: unit
    entry: foldWithMap.ts
    tests: foldWithMap.test.ts
  - type: unit
    entry: findRangesFolded.ts
    tests: findRangesFolded.test.ts
  - type: unit
    entry: mergeRanges.ts
    tests: mergeRanges.test.ts
  - type: unit
    entry: highlightHtml.ts
    tests: highlightHtml.test.ts
  - type: unit
    entry: bestSnippet.ts
    tests: bestSnippet.test.ts
---

## Why this matters

Users expect **“São” to match “sao”**, emoji to remain whole, and highlights/snippets that don’t tear characters apart. That means:

- searching with a **folded** pipeline (normalize → accent fold → case fold),
- converting **match indices** (code units) to **grapheme-safe** ranges,
- **merging** overlaps, then
- producing **escaped HTML** and clear **snippets**.

This lesson gives you a production-ready toolkit.

---

## Overview of the pipeline

1) **Fold with map**: fold the haystack but also produce a **map from folded indices to original unit indices**.  
2) **Search** in the folded haystack (string or regex) → folded index ranges.  
3) **Map back** to original unit ranges via the map.  
4) **Snap to graphemes** for UI safety.  
5) **Merge** overlapping/touching ranges.  
6) **Render**: highlight into escaped HTML or build **snippets** (windows around matches).

---

## 1) Fold **with index map**

We’ll fold **per code point** and record, for each unit of the **folded** result, the **origin unit index** in the original string. When folding removes characters (e.g., combining marks), no map entries are added for those.

```ts
// foldWithMap.ts
import { accentFold } from "./accentFold"; // from L2 lesson
import { foldCase } from "./foldCase";     // from L3 lesson

export type FoldOpts = {
  locale?: string | string[];
  useLocale?: boolean;   // default true
  accent?: boolean;      // default false (turn on for accent-insensitive)
  widthCompat?: boolean; // if true, NFKC first
  finalForm?: "NFC"|"NFD"|"NFKC"|"NFKD"; // default "NFC"
};

/** Fold string and return the folded text + a map from folded unit index -> original unit index. */
export function foldWithMap(s: string, opts: FoldOpts = {}) {
  const {
    locale, useLocale = true, accent = false, widthCompat = false, finalForm = "NFC",
  } = opts;
  // Process per code point to keep a usable mapping.
  const cps = Array.from(s); // each element is 1 code point (1 or 2 units)
  let out = "";
  const map: number[] = [];
  let unitCursor = 0;

  for (const cp of cps) {
    const origStart = unitCursor;
    unitCursor += cp.length;

    // Per-CP fold: (width-compat?) normalize piece, (accent?) fold, case fold, then final normalize
    let x = cp.normalize(widthCompat ? "NFKC" : "NFC");
    if (accent) x = accentFold(x);
    x = foldCase(x, locale, useLocale).normalize(finalForm);

    // Append and map each resulting unit back to origStart
    out += x;
    for (let k = 0; k < x.length; k++) map.push(origStart);
  }

  return { text: out, map };
}
````

---

## 2) Find ranges in **folded** haystacks

Return **non-overlapping** ranges by default (classic `indexOf` loop). Optionally support **overlapping** via lookahead.

```ts
// findRangesFolded.ts
import { foldWithMap, FoldOpts } from "./foldWithMap";

export type Range = { start: number; end: number }; // [start, end) unit indices in ORIGINAL string

export type FindOpts = FoldOpts & { overlap?: boolean };

function findAllIndices(hay: string, needle: string, overlap = false): number[] {
  if (needle === "") return [];
  const out: number[] = [];
  let i = 0;
  while (i <= hay.length - needle.length) {
    const j = hay.indexOf(needle, i);
    if (j === -1) break;
    out.push(j);
    i = j + (overlap ? 1 : needle.length);
  }
  return out;
}

/** Find matches of one or more needles with folding; map back to original unit ranges. */
export function findRangesFolded(
  haystack: string,
  needles: string | string[],
  opts: FindOpts = {}
): Range[] {
  const ns = Array.isArray(needles) ? needles : [needles];
  const { text: H, map } = foldWithMap(haystack, opts);
  const out: Range[] = [];

  for (const nRaw of ns) {
    if (!nRaw) continue;
    const needle = foldWithMap(nRaw, opts).text; // fold needle consistently
    if (!needle) continue;

    const idxs = findAllIndices(H, needle, !!opts.overlap);
    for (const j of idxs) {
      const k = j + needle.length;
      const start = map[j] ?? 0;
      const end = (k < map.length) ? map[k] : haystack.length;
      out.push({ start, end });
    }
  }
  return out;
}
```

---

## 3) Snap to **grapheme boundaries**, then **merge**

```ts
// mergeRanges.ts
import { iterGraphemes } from "./iterGraphemes"; // from L2

export type Range = { start: number; end: number };

/** Snap [start,end) outward to nearest grapheme boundaries. */
export function snapRangeToGraphemes(s: string, r: Range): Range {
  const bounds = Array.from(iterGraphemes(s), g => g.start).concat([s.length]).sort((a,b)=>a-b);
  const left = (i: number) => {
    let k = 0; while (k < bounds.length && bounds[k] <= i) k++;
    return bounds[Math.max(0, k - 1)];
  };
  const right = (i: number) => {
    let k = 0; while (k < bounds.length && bounds[k] < i) k++;
    return bounds[Math.min(bounds.length - 1, k)];
  };
  const start = Math.max(0, Math.min(r.start, r.end));
  const end = Math.max(start, r.end);
  return { start: left(start), end: right(end) };
}

/** Merge overlapping/touching ranges (assumes same coordinate space). */
export function mergeRanges(ranges: Range[], mergeTouching = true): Range[] {
  const rs = ranges.slice().sort((a,b)=> a.start - b.start || a.end - b.end);
  const out: Range[] = [];
  for (const r of rs) {
    if (!out.length) { out.push({ ...r }); continue; }
    const last = out[out.length - 1];
    const touches = mergeTouching ? r.start <= last.end : r.start < last.end;
    if (touches) last.end = Math.max(last.end, r.end);
    else out.push({ ...r });
  }
  return out;
}
```

---

## 4) HTML **highlight** (escaped)

```ts
// highlightHtml.ts
import type { Range } from "./mergeRanges";

export function escapeHtml(s: string): string {
  return s.replace(/[&<>"']/g, c => c === "&" ? "&amp;" :
                                  c === "<" ? "&lt;"  :
                                  c === ">" ? "&gt;"  :
                                  c === '"' ? "&quot;" : "&#39;");
}

/** Insert <mark> (or custom tag) around given ranges. Ranges must be non-overlapping and ordered. */
export function highlightHtml(
  s: string,
  ranges: Range[],
  tag = "mark",
  attrs: Record<string,string> = {}
): string {
  const ordered = ranges.slice().sort((a,b)=>a.start-b.start);
  const attrStr = Object.entries(attrs).map(([k,v]) => ` ${k}="${escapeHtml(v)}"`).join("");
  let i = 0, html = "";
  for (const r of ordered) {
    const a = Math.max(0, Math.min(r.start, s.length));
    const b = Math.max(0, Math.min(r.end, s.length));
    if (b <= a) continue;
    html += escapeHtml(s.slice(i, a));
    html += `<${tag}${attrStr}>` + escapeHtml(s.slice(a, b)) + `</${tag}>`;
    i = b;
  }
  html += escapeHtml(s.slice(i));
  return html;
}
```

---

## 5) Snippets: choose a **window** around matches

We’ll select a single “best” snippet: take the **earliest** merged range by default, expand **N graphemes** left/right, and add ellipses if trimmed. (Extensions: densest window scoring, multi-snippet.)

```ts
// bestSnippet.ts
import { iterGraphemes } from "./iterGraphemes";
import type { Range } from "./mergeRanges";

/** Build a grapheme-aware snippet around the first range; return { text, subranges } where subranges map into the snippet. */
export function bestSnippet(
  s: string,
  mergedRanges: Range[],
  ctxLeft = 16,
  ctxRight = 16,
  ellipsis = "…"
): { text: string; subranges: Range[] } {
  if (!mergedRanges.length) return { text: s.slice(0, Math.min(s.length, 2*(ctxLeft+ctxRight))), subranges: [] };

  // Gather graphemes with unit bounds
  const gs = Array.from(iterGraphemes(s));
  const bounds = gs.map(g => g.start);
  bounds.push(s.length);

  const first = mergedRanges[0];
  // Find grapheme indices for start/end
  const idxByStart = new Map(gs.map((g, i) => [g.start, i] as const));
  const iStart = idxByStart.get(first.start) ?? findIndexLE(bounds, first.start);
  const iEnd = idxByStart.get(first.end) ?? findIndexLE(bounds, first.end);

  const L = Math.max(0, iStart - ctxLeft);
  const R = Math.min(gs.length, iEnd + ctxRight);
  const prefix = L > 0 ? ellipsis : "";
  const suffix = R < gs.length ? ellipsis : "";
  const text = prefix + gs.slice(L, R).map(g => g.g).join("") + suffix;

  // Map mergedRanges that intersect [L,R) into snippet-local unit indices
  const baseUnit = gs.slice(L, iStart).reduce((n, g) => n + g.g.length, 0) + prefix.length;
  const subranges: Range[] = [];
  for (const r of mergedRanges) {
    if (r.end <= gs[L].start || r.start >= (R < gs.length ? gs[R].start : s.length)) continue;
    const leftUnit = Math.max(r.start, gs[L].start);
    const rightUnit = Math.min(r.end, R < gs.length ? gs[R].start : s.length);
    const leftOffset = prefix.length + unitWidth(gs, L, leftUnit);
    const rightOffset = prefix.length + unitWidth(gs, L, rightUnit);
    subranges.push({ start: leftOffset, end: rightOffset });
  }

  return { text, subranges };

  function findIndexLE(arr: number[], x: number): number {
    let i = 0; while (i < arr.length && arr[i] <= x) i++; return Math.max(0, i - 1);
  }
  function unitWidth(segs: typeof gs, fromIdx: number, unitPos: number): number {
    let w = 0;
    for (let i = fromIdx; i < segs.length && segs[i].start < unitPos; i++) w += segs[i].g.length;
    return w + (unitPos === s.length ? (R < gs.length ? 0 : 0) : 0);
  }
}
```

---

## Putting it together (recipe)

```ts
import { findRangesFolded } from "./findRangesFolded";
import { snapRangeToGraphemes, mergeRanges } from "./mergeRanges";
import { highlightHtml } from "./highlightHtml";
import { bestSnippet } from "./bestSnippet";

export function searchHighlightHtml(
  s: string,
  query: string | string[],
  opts = { accent: true, useLocale: true, locale: undefined as string | string[] | undefined }
): string {
  const rawRanges = findRangesFolded(s, query, opts);
  const snapped = rawRanges.map(r => snapRangeToGraphemes(s, r));
  const merged = mergeRanges(snapped, true);
  return highlightHtml(s, merged, "mark");
}

export function searchSnippet(
  s: string,
  query: string | string[],
  opts = { accent: true, useLocale: true, locale: undefined as string | string[] | undefined },
  ctxLeft = 16, ctxRight = 16
) {
  const rawRanges = findRangesFolded(s, query, opts);
  const snapped = rawRanges.map(r => snapRangeToGraphemes(s, r));
  const merged = mergeRanges(snapped, true);
  return bestSnippet(s, merged, ctxLeft, ctxRight);
}
```

---

## Multi-term queries (AND/OR) & colors (outline)

* **OR**: pass all terms to `findRangesFolded`, merge all ranges, one color.
* **AND**: require each term to appear at least once before rendering; or score windows containing more terms higher when selecting snippets.
* **Colors**: run `findRangesFolded` per term, snap+merge per-term (but don’t cross-merge between colors), then render in a **single pass** by walking the text and stacking tags. (Advanced exercise.)

---

## Pitfalls

* **Not snapping** to graphemes → highlights that split emoji/ZWJ sequences.
* Folding **needle** but not **haystack** (or vice versa) → misses. Fold **both** with the same options.
* Using `split('')` for windows/snippets (code units) → broken indices. Use **`Intl.Segmenter`**.
* Not escaping HTML **before** injecting tags → XSS bugs.
* Overlapping ranges with separate colors → require careful ordering; merge per color, then weave.

---

## Exercises

### 1) `foldWithMap.ts` — fold & map (provided above)

* Return `{ text, map }` as above; add tests for accent folding and dotted-I.

**Starter — `foldWithMap.ts`**

```ts
// use the implementation shown in the lesson
```

---

### 2) `findRangesFolded.ts` — folded search

* Support single or multiple needles.
* Option `{ overlap?: boolean }` to allow overlapping matches.

**Starter — `findRangesFolded.ts`**

```ts
// use the implementation shown in the lesson
```

---

### 3) `mergeRanges.ts` — snap & merge

* Implement `snapRangeToGraphemes(s, r)` and `mergeRanges(rs, mergeTouching?)`.

**Starter — `mergeRanges.ts`**

```ts
// use the implementation shown in the lesson
```

---

### 4) `highlightHtml.ts` — escaped highlighter

* Implement `escapeHtml` and `highlightHtml(s, ranges, tag?, attrs?)`.

**Starter — `highlightHtml.ts`**

```ts
// use the implementation shown in the lesson
```

---

### 5) `bestSnippet.ts` — select a window

* Build a snippet with grapheme context around the **first merged** range.
* Return `{ text, subranges }` where `subranges` are the match ranges **inside** the snippet.

**Starter — `bestSnippet.ts`**

```ts
// use the implementation shown in the lesson
```

---

## Quiz (checks)

1. Why do we search in a **folded** haystack and then map back?
   A) To avoid allocating strings
   B) **To support accent/case-insensitive matching while preserving original indices for UI** ✅
   C) Because `indexOf` only works on lowercase
   D) To speed up regex compilation

2. The safest unit for **UI highlight boundaries** is:
   A) Code units
   B) Code points
   C) **Grapheme clusters** ✅
   D) Bytes

3. After folding, how do we compute original **start** for a folded match at index `j`?
   A) Count graphemes in the match
   B) **Use `map[j]` from foldWithMap** ✅
   C) Convert to code points
   D) Use `lastIndex` from regex

4. To merge **touching** ranges like `[0,3)` and `[3,5)`, you should:
   A) Keep separate
   B) **Enable `mergeTouching`** ✅
   C) Use `substring`
   D) Normalize to NFD

5. For snippets, why count context in **graphemes** instead of code units?
   A) It’s faster
   B) **Prevents breaking user-perceived characters (emoji, ZWJ sequences)** ✅
   C) It’s required by `slice`
   D) Because regex needs it

---

## Takeaways

* Fold **both** sides consistently, keep an **index map**, and then **snap to graphemes** before rendering.
* Always **escape HTML** when injecting highlight tags.
* Merge ranges to avoid nested/duplicated tags.
* Basic “best snippet” can be **first match with grapheme context**; you can later score windows that include more terms.

---

## What’s next

Continue to **Strings L4 — Word & Line Segmentation with `Intl.Segmenter`** to build robust tokenization for previews, wrapping, and text analytics (and to power more advanced snippet scoring).
