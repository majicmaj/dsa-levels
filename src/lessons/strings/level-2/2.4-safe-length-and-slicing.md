---
id: strings-l2-safe-length-and-slicing
title: "Safe Length & Slicing (Code Points & Graphemes)"
topic: strings
level: 2
lesson: 2.4
prereqs:
  - strings-l2-utf16-code-units-vs-code-points
  - strings-l2-grapheme-clusters-and-emoji
  - strings-l2-unicode-normalization-nfc-nfd
outcomes:
  - 'Define **length & slice semantics** for three modes: `"unit"`, `"codepoint"`, `"grapheme"`'
  - Implement `safeLength` and `safeSlice` with **negative indices** and **end-exclusive** semantics
  - "**Normalize-then-slice** safely to avoid splitting canonically equivalent characters"
  - Snap arbitrary indices to **grapheme boundaries** for caret/highlight UX
  - "Build reusable helpers: `clampSlice`, `snapToBoundary`, `clipByGrapheme`"
tags: ["strings","unicode","length","slice","code-points","graphemes","Intl.Segmenter","normalization"]
est_minutes: 50
concepts_introduced:
  - strings.unicode.safe_slice
  - strings.unicode.length.modes
concepts_reused:
  - strings.unicode.surrogates
  - strings.unicode.graphemes
  - strings.normalize.nfc
crosslinks:
  - { to: strings-l1-slice-substring-substr, why: "Mirror Array/String slice semantics (end-exclusive, negatives)" }
  - { to: strings-l2-grapheme-clusters-and-emoji, why: "Use Segmenter for grapheme iteration & boundaries" }
  - { to: strings-l2-unicode-normalization-nfc-nfd, why: "Normalize before slicing for stable boundaries" }
checks:
  - type: quiz
    id: strings-l2-safe-length-and-slicing-quiz
  - type: unit
    entry: safeLength.ts
    tests: safeLength.test.ts
  - type: unit
    entry: safeSlice.ts
    tests: safeSlice.test.ts
  - type: unit
    entry: snapToBoundary.ts
    tests: snapToBoundary.test.ts
  - type: unit
    entry: clipByGrapheme.ts
    tests: clipByGrapheme.test.ts
  - type: unit
    entry: sliceNormalized.ts
    tests: sliceNormalized.test.ts
---

## Why this matters

Indexes in JavaScript strings refer to **UTF-16 code units**. Real text cares about **code points** and, ultimately, **grapheme clusters** (what users see). If you count/slice by units, you can bisect emoji, accents, or family sequences. This lesson gives you drop-in utilities for **length** and **slicing** that are safe at the code point or grapheme level and compatible with typical `slice` semantics.

---

## Three modes of thinking

```ts
type LengthMode = "unit" | "codepoint" | "grapheme";
````

* **"unit"** — raw JS behavior (`s.length`, `s.slice`): fast, may split characters.
* **"codepoint"** — safe for surrogate pairs (emoji as single element) but not ZWJ/flags.
* **"grapheme"** — user-visible characters; uses `Intl.Segmenter`.

> For **UI** text, prefer **grapheme**. For **protocol/technical** strings (IDs, URLs), unit or codepoint may be fine.

---

## Design: `safeLength` & `safeSlice`

We mirror `Array.prototype.slice`:

* `safeSlice(s, start?, end?, mode?)`

  * **End-exclusive** range.
  * **Negative indices** count from the end (in that mode).
  * Out-of-bounds are clamped.
  * Defaults: `start = 0`, `end = length(mode)`, `mode = "unit"`.

Normalization option:

* For stability, you may **normalize first** (usually `"NFC"`), otherwise equivalent strings can slice to different boundaries.

---

## Helpers & building blocks

### 1) Grapheme segmentation (reusing earlier lesson)

```ts
function getGraphemeSegments(s: string): Array<{ seg: string; startU: number }> {
  if (typeof (Intl as any)?.Segmenter === "function") {
    const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
    const out: Array<{ seg: string; startU: number }> = [];
    for (const p of seg.segment(s) as any) out.push({ seg: p.segment, startU: p.index });
    return out;
  }
  // Fallback: code point chunks; not ZWJ/flag-accurate
  const cps = Array.from(s);
  const out: Array<{ seg: string; startU: number }> = [];
  let i = 0;
  for (const cp of cps) { out.push({ seg: cp, startU: i }); i += cp.length; }
  return out;
}
```

### 2) Clamp & normalize slice indices (generic)

```ts
function normalizeSliceIndices(len: number, start?: number, end?: number): [number, number] {
  let a = start ?? 0;
  let b = end ?? len;
  if (a < 0) a = len + a;
  if (b < 0) b = len + b;
  a = Math.max(0, Math.min(a, len));
  b = Math.max(0, Math.min(b, len));
  if (b < a) b = a; // empty
  return [a, b];
}
```

---

## Implementations

### `safeLength(s, mode)`

```ts
export function safeLength(s: string, mode: "unit" | "codepoint" | "grapheme" = "unit"): number {
  if (mode === "unit") return s.length;
  if (mode === "codepoint") return Array.from(s).length;
  // grapheme
  if (typeof (Intl as any)?.Segmenter === "function") {
    const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
    let n = 0; for (const _ of seg.segment(s) as any) n++; return n;
  }
  return Array.from(s).length; // fallback
}
```

### `safeSlice(s, start, end, mode)`

```ts
export function safeSlice(
  s: string,
  start?: number,
  end?: number,
  mode: "unit" | "codepoint" | "grapheme" = "unit"
): string {
  if (mode === "unit") {
    const [a, b] = normalizeSliceIndices(s.length, start, end);
    return s.slice(a, b);
  }
  if (mode === "codepoint") {
    const cps = Array.from(s);
    const [a, b] = normalizeSliceIndices(cps.length, start, end);
    return cps.slice(a, b).join("");
  }
  // grapheme
  const gs = getGraphemeSegments(s).map(g => g.seg);
  const [a, b] = normalizeSliceIndices(gs.length, start, end);
  return gs.slice(a, b).join("");
}
```

### Snap to **grapheme boundaries** (for carets)

```ts
export type SnapDir = "left" | "right" | "nearest";

export function snapToBoundary(s: string, unitIndex: number, dir: SnapDir = "nearest"): number {
  const segs = getGraphemeSegments(s);
  const bounds = segs.map(x => x.startU).concat([s.length]).sort((a,b)=>a-b);
  const i = Math.max(0, Math.min(unitIndex, s.length));

  // Find insertion point
  let k = 0;
  while (k < bounds.length && bounds[k] < i) k++;

  if (dir === "left") return bounds[Math.max(0, k - (bounds[k] === i ? 0 : 1))];
  if (dir === "right") return bounds[Math.min(bounds.length - 1, k)];
  // nearest
  const left = bounds[Math.max(0, k - (bounds[k] === i ? 0 : 1))];
  const right = bounds[Math.min(bounds.length - 1, k)];
  return (i - left) <= (right - i) ? left : right;
}
```

### Clip by graphemes with ellipsis

```ts
export function clipByGrapheme(s: string, max: number, ellipsis = "…"): string {
  if (max <= 0) return "";
  const gs = getGraphemeSegments(s).map(g => g.seg);
  return gs.length <= max ? s : gs.slice(0, max).join("") + ellipsis;
}
```

### Normalize-then-slice

```ts
export function sliceNormalized(
  s: string,
  start?: number,
  end?: number,
  mode: "unit" | "codepoint" | "grapheme" = "grapheme",
  form: "NFC" | "NFD" | "NFKC" | "NFKD" = "NFC"
): string {
  const n = s.normalize(form);
  return safeSlice(n, start, end, mode);
}
```

---

## Pitfalls

* **Normalize after concat**: mixing normalized + raw pieces can create decomposed sequences; slice *after* normalization when output must be stable.
* **Unit vs visible width**: even graphemes don’t equal screen cells (CJK wide chars, emojis). Terminal “display width” is a separate concern.
* **Missing Segmenter**: fallbacks based on `Array.from` handle surrogate pairs but **not** ZWJ/flags—prefer a polyfill if you need perfect grapheme behavior everywhere.

---

## Exercises

### 1) `safeLength(s, mode)` — three modes

Return counts for `"unit" | "codepoint" | "grapheme"`.

**Starter — `safeLength.ts`**

```ts
export function safeLength(s: string, mode: "unit" | "codepoint" | "grapheme" = "unit"): number {
  if (mode === "unit") return s.length;
  if (mode === "codepoint") return Array.from(s).length;
  if (typeof (Intl as any)?.Segmenter === "function") {
    const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
    let n = 0; for (const _ of seg.segment(s) as any) n++; return n;
  }
  return Array.from(s).length;
}
```

---

### 2) `safeSlice(s, start?, end?, mode?)` — negative indices & end-exclusive

Mirror `slice` semantics across modes.

**Starter — `safeSlice.ts`**

```ts
function normalizeSliceIndices(len: number, start?: number, end?: number): [number, number] {
  let a = start ?? 0, b = end ?? len;
  if (a < 0) a = len + a;
  if (b < 0) b = len + b;
  a = Math.max(0, Math.min(a, len));
  b = Math.max(0, Math.min(b, len));
  if (b < a) b = a;
  return [a, b];
}

function graphemeSegments(s: string): string[] {
  if (typeof (Intl as any)?.Segmenter === "function") {
    const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
    const out: string[] = []; for (const p of seg.segment(s) as any) out.push(p.segment); return out;
  }
  return Array.from(s);
}

export function safeSlice(
  s: string, start?: number, end?: number, mode: "unit" | "codepoint" | "grapheme" = "unit"
): string {
  if (mode === "unit") {
    const [a,b] = normalizeSliceIndices(s.length, start, end); return s.slice(a,b);
  }
  if (mode === "codepoint") {
    const cps = Array.from(s); const [a,b] = normalizeSliceIndices(cps.length, start, end);
    return cps.slice(a,b).join("");
  }
  const gs = graphemeSegments(s); const [a,b] = normalizeSliceIndices(gs.length, start, end);
  return gs.slice(a,b).join("");
}
```

---

### 3) `snapToBoundary(s, unitIndex, dir?)` — grapheme-aware caret snap

Return a **code-unit** index snapped to `"left" | "right" | "nearest"` boundary.

**Starter — `snapToBoundary.ts`**

```ts
export type SnapDir = "left" | "right" | "nearest";

function segments(s: string): Array<{ startU: number; len: number }> {
  if (typeof (Intl as any)?.Segmenter === "function") {
    const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
    const out: Array<{ startU: number; len: number }> = [];
    for (const p of seg.segment(s) as any) out.push({ startU: p.index, len: p.segment.length });
    return out;
  }
  const cps = Array.from(s); const out: Array<{ startU: number; len: number }> = [];
  let i=0; for (const cp of cps) { out.push({ startU: i, len: cp.length }); i += cp.length; }
  return out;
}

export function snapToBoundary(s: string, unitIndex: number, dir: SnapDir = "nearest"): number {
  const segs = segments(s);
  const bounds = segs.map(x => x.startU).concat([s.length]).sort((a,b)=>a-b);
  const i = Math.max(0, Math.min(unitIndex, s.length));
  let k = 0; while (k < bounds.length && bounds[k] < i) k++;

  if (dir === "left") return bounds[Math.max(0, k - (bounds[k] === i ? 0 : 1))];
  if (dir === "right") return bounds[Math.min(bounds.length - 1, k)];
  const left = bounds[Math.max(0, k - (bounds[k] === i ? 0 : 1))];
  const right = bounds[Math.min(bounds.length - 1, k)];
  return (i - left) <= (right - i) ? left : right;
}
```

---

### 4) `clipByGrapheme(s, max, ellipsis?)`

Truncate to `max` graphemes, append `ellipsis` if clipped.

**Starter — `clipByGrapheme.ts`**

```ts
export function clipByGrapheme(s: string, max: number, ellipsis = "…"): string {
  if (max <= 0) return "";
  const cpsOrGs = typeof (Intl as any)?.Segmenter === "function"
    ? Array.from(new Intl.Segmenter(undefined, { granularity: "grapheme" }).segment(s) as any, (p: any) => p.segment)
    : Array.from(s);
  return cpsOrGs.length <= max ? s : cpsOrGs.slice(0, max).join("") + ellipsis;
}
```

---

### 5) `sliceNormalized(s, start?, end?, mode?, form?)`

Normalize to `form` (default `"NFC"`) then delegate to `safeSlice`.

**Starter — `sliceNormalized.ts`**

```ts
import { safeSlice } from "./safeSlice";

export function sliceNormalized(
  s: string,
  start?: number,
  end?: number,
  mode: "unit" | "codepoint" | "grapheme" = "grapheme",
  form: "NFC" | "NFD" | "NFKC" | "NFKD" = "NFC"
): string {
  return safeSlice(s.normalize(form), start, end, mode);
}
```

---

## Quiz (checks)

1. `safeSlice("A😀B", 1, 2, "unit")` returns:
   A) `"😀"`
   B) **`"\uD83D"` (half of emoji)** ✅
   C) `"B"`
   D) `""`

2. `safeSlice("A😀B", 1, 2, "codepoint")` returns:
   A) `"\uD83D"`
   B) **`"😀"`** ✅
   C) `"B"`
   D) `""`

3. For UI caret movement, you should snap indices to:
   A) Code units
   B) Code points
   C) **Grapheme boundaries** ✅
   D) Word boundaries

4. Negative indices in `safeSlice(s, -2, -1, "grapheme")` are interpreted:
   A) From the start
   B) **From the end in grapheme count** ✅
   C) As errors
   D) As zeros

5. To avoid slicing the “same looking” character differently across inputs, you should:
   A) Use `substring`
   B) Use `toLowerCase`
   C) **Normalize to NFC before slicing** ✅
   D) Convert to ASCII

---

## Takeaways

* Choose your **unit of measure**: code units (fast), code points (emoji-safe), or graphemes (user-safe).
* Implement **end-exclusive**, **negative-aware** slicing consistently across modes.
* **Normalize** first when consistent boundaries matter (e.g., indexing, highlighting).
* For UX, always **snap** to grapheme boundaries; don’t trust arbitrary indices.

---

## What’s next

Finish L2 with **Strings L2 — Iteration Patterns**: efficient scans by code point/grapheme, windowing (for previews/snippets), and bridging between search indices (code units) and grapheme-aware UI ranges.
