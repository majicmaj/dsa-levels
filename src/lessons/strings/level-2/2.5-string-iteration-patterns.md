---
id: strings-l2-string-iteration-patterns
title: "Iteration Patterns"
topic: strings
level: 2
lesson: 2.5
prereqs:
  - strings-l2-utf16-code-units-vs-code-points
  - strings-l2-grapheme-clusters-and-emoji
  - strings-l2-unicode-normalization-nfc-nfd
  - strings-l1-basic-search-compare
outcomes:
  - "Choose the right **iteration unit**: code units, **code points**, or **grapheme clusters**"
  - Implement reusable **iterators/generators** for code points & graphemes with start/end **unit indices**
  - Build **sliding windows** by grapheme for previews/snippets and n-gram tasks
  - Bridge **code-unit match indices** (from `indexOf`/regex) to **grapheme-aligned** ranges
  - "Implement practical scanners: `findAllOverlaps`, `snippetAround`, `slidingWindowGraphemes`"
tags: ["strings","iteration","unicode","code-points","graphemes","Intl.Segmenter","generators","windows","snippets"]
est_minutes: 45
concepts_introduced:
  - strings.unicode.iteration.generators
  - strings.unicode.windows.grapheme
concepts_reused:
  - strings.unicode.graphemes
  - strings.unicode.safe_slice
  - strings.normalize.nfc
crosslinks:
  - { to: strings-l2-safe-length-and-slicing, why: "Reuse safe slicing & boundary snapping" }
  - { to: strings-l3-split-join-composition, why: "Iteration feeds split/join compositions" }
  - { to: strings-l4-search-highlight-and-snippets, why: "Windows + boundary snapping for highlight UX" }
checks:
  - type: quiz
    id: strings-l2-iteration-patterns-quiz
  - type: unit
    entry: iterCodePoints.ts
    tests: iterCodePoints.test.ts
  - type: unit
    entry: iterGraphemes.ts
    tests: iterGraphemes.test.ts
  - type: unit
    entry: slidingWindowGraphemes.ts
    tests: slidingWindowGraphemes.test.ts
  - type: unit
    entry: mapUnitRangeToGraphemeRange.ts
    tests: mapUnitRangeToGraphemeRange.test.ts
  - type: unit
    entry: snippetAround.ts
    tests: snippetAround.test.ts
---

## Why this matters

Search APIs (`indexOf`, regex) return **code-unit** indices, but UI needs **grapheme-aligned** ranges. Efficient, reusable **iteration patterns** let you scan text once, keep positions, and derive windows/snippets without splitting emoji or accents.

---

## Choosing an iteration unit

- **Code unit (`s[i]`)**: lowest-level; rarely what you want.
- **Code point**: use for technical text, emoji-safe but not ZWJ/flags.
- **Grapheme**: user-visible characters; **default** for UI.

> Normalize first (usually **NFC**) if you mix sources, so boundaries stay consistent.

---

## Generators you‚Äôll reuse

### Code points with indices
```ts
// Yields: { cp: number, text: string, start: unitIndex, end: unitIndex }
export function* iterCodePoints(s: string): Generator<{ cp: number; text: string; start: number; end: number }> {
  for (let i = 0; i < s.length; ) {
    const cp = s.codePointAt(i)!;
    const size = cp > 0xFFFF ? 2 : 1;
    yield { cp, text: s.slice(i, i + size), start: i, end: i + size };
    i += size;
  }
}
````

### Graphemes with indices (uses `Intl.Segmenter` when available)

```ts
// Yields: { g: string, start: unitIndex, end: unitIndex }
export function* iterGraphemes(s: string): Generator<{ g: string; start: number; end: number }> {
  if (typeof (Intl as any)?.Segmenter === "function") {
    const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
    for (const part of seg.segment(s) as any) {
      yield { g: part.segment, start: part.index, end: part.index + part.segment.length };
    }
    return;
  }
  // Fallback: code point chunks (not ZWJ/flag-accurate)
  for (const { text, start, end } of iterCodePoints(s)) yield { g: text, start, end };
}
```

---

## Sliding windows (n-grams) by grapheme

```ts
// Example: slidingWindowGraphemes("AüëçüèΩB", 2) -> ["AüëçüèΩ", "üëçüèΩB"]
export function* slidingWindowGraphemes(s: string, width: number, step = 1): Generator<string> {
  if (width <= 0 || step <= 0) return;
  const gs = Array.from(iterGraphemes(s), p => p.g);
  for (let i = 0; i + width <= gs.length; i += step) {
    yield gs.slice(i, i + width).join("");
  }
}
```

Use-cases:

* **Previews/snippets** near a match
* Simple **n-gram** features (search/fuzzy)

---

## Bridging indices: code-unit ‚Üí grapheme-aligned

Given `startU,endU` (e.g., from `indexOf`), snap to the nearest **grapheme boundaries** so UI slices don‚Äôt split visible characters.

```ts
export function mapUnitRangeToGraphemeRange(s: string, startU: number, endU: number): { start: number; end: number } {
  let start = Math.max(0, Math.min(startU, s.length));
  let end = Math.max(0, Math.min(endU, s.length));
  if (start > end) [start, end] = [end, start];

  // Collect boundaries
  const bounds: number[] = [];
  for (const seg of iterGraphemes(s)) bounds.push(seg.start);
  bounds.push(s.length);

  // Snap helpers
  const snapLeft = (i: number) => {
    let k = 0; while (k < bounds.length && bounds[k] <= i) k++;
    return bounds[Math.max(0, k - (bounds[k - 1] === i ? 1 : 1))]; // previous boundary
  };
  const snapRight = (i: number) => {
    let k = 0; while (k < bounds.length && bounds[k] < i) k++;
    return bounds[Math.min(bounds.length - 1, k)]; // next boundary
  };

  return { start: snapLeft(start), end: snapRight(end) };
}
```

> You can choose different policies: `"nearest"`, `"outward"` (as above), or `"inward"` depending on UX.

---

## Snippets around matches (context windows)

```ts
// Return a snippet around [matchStart, matchEnd) with `left`/`right` grapheme context.
// Guarantees grapheme boundaries and adds ellipses if trimmed.
export function snippetAround(
  s: string,
  matchStart: number,
  matchEnd: number,
  left = 12,
  right = 12,
  ellipsis = "‚Ä¶"
): { text: string; range: { start: number; end: number } } {
  // Normalize outward to grapheme boundaries
  const { start: gStart, end: gEnd } = mapUnitRangeToGraphemeRange(s, matchStart, matchEnd);

  // Collect graphemes with unit bounds
  const segs = Array.from(iterGraphemes(s));
  const idxByStart = new Map(segs.map((p, i) => [p.start, i] as const));
  const iStart = idxByStart.get(gStart) ?? 0;
  const iEnd = idxByStart.get(gEnd) ?? segs.length;

  const L = Math.max(0, iStart - left);
  const R = Math.min(segs.length, iEnd + right);
  const textCore = segs.slice(L, R).map(p => p.g).join("");

  const prefix = L > 0 ? ellipsis : "";
  const suffix = R < segs.length ? ellipsis : "";
  const text = prefix + textCore + suffix;

  // Compute displayed range in the new snippet (unit indices within text)
  const startOffset = prefix.length + segs.slice(L, iStart).reduce((n, p) => n + p.g.length, 0);
  const endOffset = startOffset + segs.slice(iStart, iEnd).reduce((n, p) => n + p.g.length, 0);

  return { text, range: { start: startOffset, end: endOffset } };
}
```

---

## Performance notes

* Reuse a single `Intl.Segmenter` instance when iterating many strings.
* For huge strings, prefer **streaming generators** over building arrays when possible.
* Normalize once at input/indexing time; avoid normalizing inside tight iteration loops unless required.

---

## Exercises

### 1) `iterCodePoints(s)` ‚Äî generator with indices

Yield `{ cp, text, start, end }` for each code point.

**Starter ‚Äî `iterCodePoints.ts`**

```ts
export function* iterCodePoints(s: string): Generator<{ cp: number; text: string; start: number; end: number }> {
  for (let i = 0; i < s.length; ) {
    const cp = s.codePointAt(i)!;
    const size = cp > 0xFFFF ? 2 : 1;
    yield { cp, text: s.slice(i, i + size), start: i, end: i + size };
    i += size;
  }
}
```

---

### 2) `iterGraphemes(s)` ‚Äî generator with indices

Yield `{ g, start, end }` using `Intl.Segmenter` when available.

**Starter ‚Äî `iterGraphemes.ts`**

```ts
import { iterCodePoints } from "./iterCodePoints";

export function* iterGraphemes(s: string): Generator<{ g: string; start: number; end: number }> {
  if (typeof (Intl as any)?.Segmenter === "function") {
    const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
    for (const part of seg.segment(s) as any) yield { g: part.segment, start: part.index, end: part.index + part.segment.length };
    return;
  }
  for (const { text, start, end } of iterCodePoints(s)) yield { g: text, start, end };
}
```

---

### 3) `slidingWindowGraphemes(s, width, step?)`

Yield consecutive grapheme windows of size `width`.

**Starter ‚Äî `slidingWindowGraphemes.ts`**

```ts
import { iterGraphemes } from "./iterGraphemes";

export function* slidingWindowGraphemes(s: string, width: number, step = 1): Generator<string> {
  if (width <= 0 || step <= 0) return;
  const gs = Array.from(iterGraphemes(s), p => p.g);
  for (let i = 0; i + width <= gs.length; i += step) yield gs.slice(i, i + width).join("");
}
```

---

### 4) `mapUnitRangeToGraphemeRange(s, startU, endU)`

Snap a code-unit range outward to the nearest grapheme boundaries.

**Starter ‚Äî `mapUnitRangeToGraphemeRange.ts`**

```ts
import { iterGraphemes } from "./iterGraphemes";

export function mapUnitRangeToGraphemeRange(s: string, startU: number, endU: number): { start: number; end: number } {
  let start = Math.max(0, Math.min(startU, s.length));
  let end = Math.max(0, Math.min(endU, s.length));
  if (start > end) [start, end] = [end, start];

  const bounds: number[] = [];
  for (const seg of iterGraphemes(s)) bounds.push(seg.start);
  bounds.push(s.length);

  const snapLeft = (i: number) => {
    let k = 0; while (k < bounds.length && bounds[k] <= i) k++;
    return bounds[Math.max(0, k - 1)];
  };
  const snapRight = (i: number) => {
    let k = 0; while (k < bounds.length && bounds[k] < i) k++;
    return bounds[Math.min(bounds.length - 1, k)];
  };

  return { start: snapLeft(start), end: snapRight(end) };
}
```

---

### 5) `snippetAround(s, matchStart, matchEnd, left?, right?, ellipsis?)`

Return `{ text, range }` as defined above.

**Starter ‚Äî `snippetAround.ts`**

```ts
import { iterGraphemes } from "./iterGraphemes";
import { mapUnitRangeToGraphemeRange } from "./mapUnitRangeToGraphemeRange";

export function snippetAround(
  s: string, matchStart: number, matchEnd: number, left = 12, right = 12, ellipsis = "‚Ä¶"
): { text: string; range: { start: number; end: number } } {
  const { start: gStart, end: gEnd } = mapUnitRangeToGraphemeRange(s, matchStart, matchEnd);
  const segs = Array.from(iterGraphemes(s));
  const idxByStart = new Map(segs.map((p, i) => [p.start, i] as const));
  const iStart = idxByStart.get(gStart) ?? 0;
  const iEnd = idxByStart.get(gEnd) ?? segs.length;

  const L = Math.max(0, iStart - left);
  const R = Math.min(segs.length, iEnd + right);
  const core = segs.slice(L, R).map(p => p.g).join("");
  const prefix = L > 0 ? ellipsis : "";
  const suffix = R < segs.length ? ellipsis : "";
  const text = prefix + core + suffix;

  const startOffset = prefix.length + segs.slice(L, iStart).reduce((n, p) => n + p.g.length, 0);
  const endOffset = startOffset + segs.slice(iStart, iEnd).reduce((n, p) => n + p.g.length, 0);
  return { text, range: { start: startOffset, end: endOffset } };
}
```

---

## Quiz (checks)

1. The best default **iteration unit** for UI text is:
   A) Code units
   B) Code points
   C) **Grapheme clusters** ‚úÖ
   D) Words

2. `for‚Ä¶of` over a string iterates:
   A) Code units
   B) **Code points** ‚úÖ
   C) Grapheme clusters
   D) Bytes

3. `Intl.Segmenter` (grapheme) yields objects that include:
   A) `segment`, `index` (start unit index) ‚úÖ
   B) `byteLength`
   C) `codePage`
   D) `localeOnly`

4. You got `[startU, endU)` from `indexOf`. To slice for UI you should:
   A) Slice directly
   B) Normalize to NFD
   C) **Snap the range to grapheme boundaries** ‚úÖ
   D) Convert to ASCII

5. A **sliding window** over graphemes is useful for:
   A) JSON parsing
   B) **Context snippets and n-gram features** ‚úÖ
   C) Memory compaction
   D) URL encoding

---

## Takeaways

* Pick your **iteration unit** deliberately; prefer **graphemes** for UX.
* Write generators that yield both **text** and **unit indices**‚Äîyou‚Äôll need positions later.
* Use grapheme **sliding windows** for previews and n-grams.
* Always **bridge** code-unit indices from search to **grapheme-aligned** ranges before slicing/highlighting.

---

## What‚Äôs next

Level up to **Strings L3 ‚Äî split/join Composition** where you‚Äôll combine these iteration tools with `split`, `join`, and regex-lite pipelines to build powerful text transforms (anagrams, tokenizers, CSV-ish parsing).
