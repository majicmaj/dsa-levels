---
id: strings-l2-grapheme-clusters-and-emoji
title: "Grapheme Clusters & Emoji"
topic: strings
level: 2
lesson: 2.2
prereqs:
  - strings-l2-utf16-code-units-vs-code-points
  - strings-l1-slice-substring-substr
outcomes:
  - Explain **grapheme clusters** (user-perceived characters) vs **code points** and **code units**
  - "Identify tricky clusters: **combining marks**, **ZWJ emoji sequences**, **regional indicator flags**"
  - Use **`Intl.Segmenter`** to iterate graphemes, count safely, and avoid splitting clusters
  - Implement `graphemeLength`, `segmentGraphemes`, `safeSliceGrapheme`, and `truncateByGrapheme`
  - Detect **grapheme boundaries** for caret movement and highlighting
tags: ["strings","unicode","grapheme","emoji","Intl.Segmenter","segmentation","zwj","combining-marks"]
est_minutes: 50
concepts_introduced:
  - strings.unicode.graphemes
  - strings.unicode.segmentation.grapheme
concepts_reused:
  - strings.unicode.surrogates
  - strings.unicode.codepoints
crosslinks:
  - { to: strings-l2-unicode-normalization-nfc-nfd, why: "Canonical forms affect equality and search; normalize before indexing" }
  - { to: strings-l1-basic-search-compare, why: "Search indices point to code units; map them to grapheme boundaries for UI" }
checks:
  - type: quiz
    id: strings-l2-grapheme-quiz
  - type: unit
    entry: segmentGraphemes.ts
    tests: segmentGraphemes.test.ts
  - type: unit
    entry: graphemeLength.ts
    tests: graphemeLength.test.ts
  - type: unit
    entry: isGraphemeBoundary.ts
    tests: isGraphemeBoundary.test.ts
  - type: unit
    entry: safeSliceGrapheme.ts
    tests: safeSliceGrapheme.test.ts
  - type: unit
    entry: truncateByGrapheme.ts
    tests: truncateByGrapheme.test.ts
---

## Why this matters

Users think in **characters**, not code units or even single code points. “Characters” like `é` (e + ◌́), `👩‍🚀`, `👨‍👩‍👧‍👦`, and `🇺🇳` are **grapheme clusters**—they may span multiple code points. If you slice or count by code units or code points, you can **split** visible characters and produce corrupted text or broken UI carets/highlights.

This lesson gives you practical, production-ready **grapheme-safe** utilities using `Intl.Segmenter`.

---

## What is a grapheme cluster?

A **(extended) grapheme cluster** is the smallest sequence of code points that a user perceives as a single character. Common patterns:

- **Combining marks**: `e\u0301` → “é” (looks like one char).
- **ZWJ sequences**: `👩‍❤️‍💋‍👨` uses **Zero Width Joiner** to fuse emoji into a single glyph.
- **Skin tones**: `👍🏽` combines base + Fitzpatrick modifier.
- **Flags**: `🇺🇳` = two **regional indicators**.

> Code point level (L2.1) is already safer than code units, but still not enough for these combined forms. Graphemes are the final boss.

---

## Meet `Intl.Segmenter` (grapheme mode)

If available, this is the simplest, most accurate way to walk graphemes:

```ts
const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
const segments = seg.segment("A👨‍👩‍👧‍👦e\u0301🇺🇳");
for (const part of segments) {
  // part.segment is the substring (one grapheme)
  // part.index is the starting code-unit index
  // part.isWordLike (irrelevant for graphemes)
}
````

* **Locale**: grapheme segmentation is mostly locale-agnostic, so `undefined` locale is fine.
* **Performance**: create segmenters once and reuse.

**Fallback**: If `Intl.Segmenter` is missing, a robust polyfill is ideal. As a minimal fallback, `Array.from(s)` (code points) is better than code units but still not perfect for ZWJ/flags; we’ll provide a simple stopgap.

---

## Utilities you’ll build

### A reusable segmenter (with fallback)

```ts
function getGraphemeSegmenter():
  | Intl.Segmenter
  | { segment: (s: string) => { [Symbol.iterator](): Iterator<{ segment: string; index: number }> } } {
  if (typeof (Intl as any)?.Segmenter === "function") {
    return new Intl.Segmenter(undefined, { granularity: "grapheme" });
  }
  // Fallback: code point chunks; not ZWJ-accurate but better than code units
  return {
    segment(s: string) {
      const cps = Array.from(s);
      return {
        *[Symbol.iterator]() {
          let index = 0;
          for (const g of cps) {
            yield { segment: g, index };
            index += g.length; // length in code units of this code point (1 or 2)
          }
        }
      };
    }
  };
}
```

### Segment into graphemes

```ts
export function segmentGraphemes(s: string): string[] {
  const seg = getGraphemeSegmenter();
  const out: string[] = [];
  for (const part of seg.segment(s) as any) out.push(part.segment);
  return out;
}
```

### Count graphemes

```ts
export function graphemeLength(s: string): number {
  const seg = getGraphemeSegmenter();
  let n = 0;
  for (const _ of seg.segment(s) as any) n++;
  return n;
}
```

### Grapheme boundaries by **unit index**

```ts
export function graphemeBoundaries(s: string): Set<number> {
  const seg = getGraphemeSegmenter();
  const set = new Set<number>();
  for (const part of seg.segment(s) as any) set.add(part.index);
  set.add(s.length); // end boundary
  return set;
}

export function isGraphemeBoundary(s: string, unitIndex: number): boolean {
  if (unitIndex < 0 || unitIndex > s.length) return false;
  return graphemeBoundaries(s).has(unitIndex);
}
```

### Safe slice by **grapheme index**

```ts
export function safeSliceGrapheme(s: string, startGC: number, endGC?: number): string {
  const seg = getGraphemeSegmenter();
  let i = 0, startU = 0, endU = s.length;
  for (const part of seg.segment(s) as any) {
    if (i === startGC) startU = part.index;
    if (endGC != null && i === endGC) { endU = part.index; break; }
    i++;
  }
  if (endGC != null && endGC >= i) endU = s.length; // ran past the end; clamp
  return s.slice(startU, endU);
}
```

### Truncate by grapheme count (UI-safe)

```ts
export function truncateByGrapheme(s: string, max: number, ellipsis = "…"): string {
  if (max <= 0) return "";
  const seg = getGraphemeSegmenter();
  let i = 0, lastU = 0;
  for (const part of seg.segment(s) as any) {
    if (i === max) return s.slice(0, lastU) + ellipsis;
    lastU = part.index + part.segment.length;
    i++;
  }
  return s; // shorter than max
}
```

---

## Practical notes

* **Normalize then segment** if your pipeline mixes precomposed and decomposed forms (NFC vs NFD). We’ll cover normalization next.
* **Search & highlight**: find indices by code units (e.g., `indexOf`), then **snap** to nearest grapheme boundaries before slicing for UI.
* **Caret navigation**: move to the next/prev **boundary**; don’t increment/decrement unit indices blindly.

---

## Pitfalls

* Using `Array.from(s)` as a grapheme splitter works for surrogate pairs but **fails** on ZWJ and flags.
* Regex `.` also splits clusters unless you use the `u` flag and even then it’s code point–based, not grapheme-aware.
* Not adding the **end boundary** (`s.length`) can cause off-by-one in truncation.

---

## Exercises

### 1) `segmentGraphemes(s)` — return an array of grapheme strings

Use `Intl.Segmenter` when available; otherwise fall back to code-point chunks.

**Starter — `segmentGraphemes.ts`**

```ts
function getGraphemeSegmenter():
  | Intl.Segmenter
  | { segment: (s: string) => { [Symbol.iterator](): Iterator<{ segment: string; index: number }> } } {
  if (typeof (Intl as any)?.Segmenter === "function") {
    return new Intl.Segmenter(undefined, { granularity: "grapheme" });
  }
  return {
    segment(s: string) {
      const cps = Array.from(s);
      return {
        *[Symbol.iterator]() {
          let index = 0;
          for (const g of cps) { yield { segment: g, index }; index += g.length; }
        }
      };
    }
  };
}

export function segmentGraphemes(s: string): string[] {
  const seg = getGraphemeSegmenter();
  const out: string[] = [];
  for (const part of seg.segment(s) as any) out.push(part.segment);
  return out;
}
```

---

### 2) `graphemeLength(s)` — count graphemes

Iterate segments and count.

**Starter — `graphemeLength.ts`**

```ts
import { segmentGraphemes } from "./segmentGraphemes";
export const graphemeLength = (s: string) => segmentGraphemes(s).length;
```

---

### 3) `isGraphemeBoundary(s, unitIndex)` — boundary check

Return `true` if `unitIndex` is a grapheme boundary (start of any segment or end of string).

**Starter — `isGraphemeBoundary.ts`**

```ts
function boundaries(s: string): Set<number> {
  if (typeof (Intl as any)?.Segmenter === "function") {
    const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
    const set = new Set<number>();
    for (const p of seg.segment(s) as any) set.add(p.index);
    set.add(s.length);
    return set;
  }
  // Fallback: code point boundaries
  const set = new Set<number>();
  let i = 0;
  for (const cp of Array.from(s)) { set.add(i); i += cp.length; }
  set.add(s.length);
  return set;
}

export function isGraphemeBoundary(s: string, unitIndex: number): boolean {
  if (unitIndex < 0 || unitIndex > s.length) return false;
  return boundaries(s).has(unitIndex);
}
```

---

### 4) `safeSliceGrapheme(s, startGC, endGC?)` — grapheme-index slicing

Mirror `Array.prototype.slice` semantics but over **graphemes**.

**Starter — `safeSliceGrapheme.ts`**

```ts
export function safeSliceGrapheme(s: string, startGC: number, endGC?: number): string {
  const hasSeg = typeof (Intl as any)?.Segmenter === "function";
  const seg = hasSeg ? new Intl.Segmenter(undefined, { granularity: "grapheme" }) : null;

  let i = 0, startU = 0, endU = s.length;
  if (hasSeg) {
    for (const part of (seg as any).segment(s)) {
      if (i === startGC) startU = part.index;
      if (endGC != null && i === endGC) { endU = part.index; break; }
      i++;
    }
    if (endGC != null && endGC >= i) endU = s.length;
    return s.slice(startU, endU);
  } else {
    const gs = Array.from(s);
    return gs.slice(startGC, endGC).join("");
  }
}
```

---

### 5) `truncateByGrapheme(s, max, ellipsis?)` — UI-safe truncation

Add ellipsis if the grapheme count exceeds `max`.

**Starter — `truncateByGrapheme.ts`**

```ts
export function truncateByGrapheme(s: string, max: number, ellipsis = "…"): string {
  if (max <= 0) return "";
  if (typeof (Intl as any)?.Segmenter !== "function") {
    const cps = Array.from(s);
    return cps.length <= max ? s : cps.slice(0, max).join("") + ellipsis;
  }
  const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
  let i = 0, lastEnd = 0;
  for (const part of seg.segment(s) as any) {
    if (i === max) return s.slice(0, lastEnd) + ellipsis;
    lastEnd = part.index + part.segment.length;
    i++;
  }
  return s;
}
```

---

## Quiz (checks)

1. A **grapheme cluster** is:
   A) A single UTF-16 code unit
   B) A single Unicode code point
   C) **A user-perceived character that may span multiple code points** ✅
   D) A regex token

2. Which best handles emoji family sequences for iteration?
   A) `for (const ch of s)`
   B) `Array.from(s)`
   C) **`Intl.Segmenter(..., { granularity: "grapheme" })`** ✅
   D) `s.split("")`

3. `🇺🇳` consists of:
   A) One code unit
   B) One code point
   C) **Two regional indicator code points** ✅
   D) ZWJ + modifiers only

4. For UI-safe truncation you should:
   A) Slice by code units
   B) Slice by code points
   C) **Truncate by grapheme count** ✅
   D) Use `substring` always

5. If `Intl.Segmenter` is unavailable, the **least-bad** fallback here is:
   A) `s.split("")`
   B) **`Array.from(s)` (code points), noting it still misses ZWJ/flags** ✅
   C) `localeCompare`
   D) `encodeURI`

---

## Takeaways

* Grapheme clusters are the **right unit** for UI text operations (caret, selection, truncation, highlighting).
* Use **`Intl.Segmenter`** (grapheme) to count, slice, and iterate safely; add an end boundary at `s.length`.
* Code point fallbacks are safer than code units but still **not perfect** for ZWJ/flags—prefer a real polyfill if `Intl.Segmenter` is missing.
* Next, we’ll handle **Unicode normalization** (NFC/NFD/NFKC/NFKD), which affects equality, deduplication, and search.

---

## What’s next

Proceed to **Strings L2 — Unicode Normalization (NFC/NFD)** to make canonically equivalent strings compare and index correctly, and to set up accent-handling pipelines for search.