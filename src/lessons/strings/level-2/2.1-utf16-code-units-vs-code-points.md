---
id: strings-l2-utf16-code-units-vs-code-points
title: "UTF-16 vs Code Points (Essentials)"
topic: strings
level: 2
lesson: 2.1
prereqs:
  - strings-l1-length-indexing-immutability
  - strings-l1-slice-substring-substr
  - strings-l1-basic-search-compare
outcomes:
  - Distinguish **UTF-16 code units**, **Unicode code points**, and why `length` counts units
  - Detect and handle **surrogate pairs**; predict results of `s[i]`, `charCodeAt`, `codePointAt`
  - Convert between **code point indices** and **code unit indices**
  - Iterate by **code point** safely (`for…of`, `Array.from`, numeric iteration)
  - "Implement low-level helpers: `isHigh/LowSurrogate`, `decodeAt`, `encodeCodePoint`"
tags: ["strings","unicode","utf-16","code-points","surrogates","iteration","indexing"]
est_minutes: 45
concepts_introduced:
  - strings.unicode.surrogates
  - strings.unicode.indexing.codepoint_to_codeunit
concepts_reused:
  - strings.unicode.codepoints
crosslinks:
  - { to: strings-l2-grapheme-clusters-and-emoji, why: "Code points are not user-visible characters; graphemes come next" }
  - { to: strings-l1-length-indexing-immutability, why: "Recap: `length` counts code units; review `codePointAt`" }
checks:
  - type: quiz
    id: strings-l2-utf16-code-units-vs-code-points-quiz
  - type: unit
    entry: isSurrogate.ts
    tests: isSurrogate.test.ts
  - type: unit
    entry: decodeAt.ts
    tests: decodeAt.test.ts
  - type: unit
    entry: codePointScan.ts
    tests: codePointScan.test.ts
  - type: unit
    entry: cpIndexToUnitIndex.ts
    tests: cpIndexToUnitIndex.test.ts
  - type: unit
    entry: encodeCodePoint.ts
    tests: encodeCodePoint.test.ts
---

## Why this matters

JavaScript strings are sequences of **UTF-16 code units**. Many Unicode characters (emoji, historic scripts) don’t fit in one 16-bit unit and use a **surrogate pair** (two units). If you index/slice by units, you can split a character. This lesson makes you fluent in **code point–aware** operations—the foundation for grapheme safety in the next lesson.

---

## Three layers (mentally)

- **Code unit (UTF-16)**: what JS indexes (`s[i]`, `length`). Size: 16 bits.
- **Code point (Unicode scalar)**: the abstract character number (U+1F600 😀). In UTF-16 it’s 1 unit for BMP (≤ U+FFFF) or **2 units** (surrogate pair) for astral (> U+FFFF).
- **Grapheme cluster**: what users perceive as one char (can be multiple code points, e.g., `e` + `◌́`, or family emoji). *Next lesson.*

Example:
```ts
"😀".length;              // 2 (two code units)
[... "A😀B"];             // ["A","😀","B"]  (code point–aware)
"A😀B"[1];                // "\uD83D" (half the emoji: high surrogate)
````

---

## Surrogate pairs 101

UTF-16 uses *surrogates* to encode code points > U+FFFF:

* **High surrogate**: 0xD800–0xDBFF
* **Low surrogate** : 0xDC00–0xDFFF

In memory:

```
"😀"  U+1F600
UTF-16: \uD83D \uDE00   (high  D83D, low DE00)
```

APIs:

```ts
const s = "A😀B";
s.charCodeAt(1).toString(16); // "d83d" (high surrogate)
s.codePointAt(1)!.toString(16); // "1f600" (full code point)
String.fromCodePoint(0x1F600);  // "😀"
```

---

## Iterating by **code point**

* `for…of` and `Array.from(s)` walk **code points** (merge surrogate pairs).
* Numeric iteration by code point (indices) requires skipping the low surrogate:

```ts
export function codePointsToNumbers(s: string): number[] {
  const out: number[] = [];
  for (let i = 0; i < s.length; i++) {
    const cp = s.codePointAt(i)!;
    out.push(cp);
    if (cp > 0xFFFF) i++; // skip low surrogate
  }
  return out;
}
```

---

## Converting indices (code point ↔ code unit)

Why: UI components might think in **code point positions** (e.g., “move cursor one char right”) but DOM text nodes and many APIs use **unit indices**.

* **cpIndex → unitIndex**: walk `cpIndex` code points; add **2** for astral, **1** otherwise.
* **unitIndex → cpIndex**: walk units and count code points; if you land on a **low surrogate**, back up to the high surrogate to get the owning code point.

We’ll implement these in exercises.

---

## Low-level helpers you’ll use a lot

```ts
export const isHighSurrogate = (u: number) => u >= 0xD800 && u <= 0xDBFF;
export const isLowSurrogate  = (u: number) => u >= 0xDC00 && u <= 0xDFFF;

// Decode the code point at *unit* index i (safe around pairs)
export function decodeAt(s: string, i: number): { cp: number; size: 1 | 2 } | null {
  if (i < 0 || i >= s.length) return null;
  const u1 = s.charCodeAt(i);
  if (isHighSurrogate(u1) && i + 1 < s.length) {
    const u2 = s.charCodeAt(i + 1);
    if (isLowSurrogate(u2)) {
      // Combine surrogates: (u1,u2) -> code point
      const cp = (u1 - 0xD800) * 0x400 + (u2 - 0xDC00) + 0x10000;
      return { cp, size: 2 };
    }
  }
  if (!isLowSurrogate(u1)) return { cp: u1, size: 1 }; // BMP char or isolated high surrogate
  // Isolated low surrogate: treat as size 1 (malformed), return its unit value
  return { cp: u1, size: 1 };
}
```

---

## Pitfalls

* **Half characters**: `s[i]` or `slice` in the middle of a surrogate pair yields invalid halves.
* **Counts vs width**: `length` ≠ user-perceived character count (and certainly ≠ on-screen width).
* **Malformed strings**: It’s possible (though rare) to encounter isolated surrogates; robust decoders must handle them.

---

## Exercises

### 1) `isSurrogate.ts` — detect surrogate units

Implement `isHighSurrogate(u)` / `isLowSurrogate(u)` for a **unit value** (0–65535). Export also `isSurrogate(u)`.

**Starter — `isSurrogate.ts`**

```ts
export const isHighSurrogate = (u: number) => u >= 0xD800 && u <= 0xDBFF;
export const isLowSurrogate  = (u: number) => u >= 0xDC00 && u <= 0xDFFF;
export const isSurrogate     = (u: number) => isHighSurrogate(u) || isLowSurrogate(u);
```

---

### 2) `decodeAt.ts` — decode code point at a *unit* index

Return `{ cp, size }` where `size` is `1|2` units consumed, or `null` if `i` is out of range. Must gracefully handle malformed pairs.

**Starter — `decodeAt.ts`**

```ts
import { isHighSurrogate, isLowSurrogate } from "./isSurrogate";

export function decodeAt(s: string, i: number): { cp: number; size: 1 | 2 } | null {
  if (i < 0 || i >= s.length) return null;
  const u1 = s.charCodeAt(i);
  if (isHighSurrogate(u1) && i + 1 < s.length) {
    const u2 = s.charCodeAt(i + 1);
    if (isLowSurrogate(u2)) {
      const cp = (u1 - 0xD800) * 0x400 + (u2 - 0xDC00) + 0x10000;
      return { cp, size: 2 };
    }
  }
  if (!isLowSurrogate(u1)) return { cp: u1, size: 1 };
  return { cp: u1, size: 1 }; // isolated low surrogate
}
```

---

### 3) `codePointScan.ts` — iterate code points (numbers)

Return an array of code point numbers scanning by **unit** index with `decodeAt`.

**Starter — `codePointScan.ts`**

```ts
import { decodeAt } from "./decodeAt";

export function codePointScan(s: string): number[] {
  const out: number[] = [];
  for (let i = 0; i < s.length; ) {
    const d = decodeAt(s, i)!;
    out.push(d.cp);
    i += d.size;
  }
  return out;
}
```

---

### 4) `cpIndexToUnitIndex.ts` — convert **code point index** → unit index

Given `s` and `cpIndex` (0-based), return the **unit index** where that code point starts, or `-1` if `cpIndex` is out of range.

**Starter — `cpIndexToUnitIndex.ts`**

```ts
import { decodeAt } from "./decodeAt";

export function cpIndexToUnitIndex(s: string, cpIndex: number): number {
  if (cpIndex < 0) return -1;
  let count = 0;
  for (let i = 0; i < s.length; ) {
    if (count === cpIndex) return i;
    const d = decodeAt(s, i)!;
    i += d.size;
    count++;
  }
  return -1;
}
```

> (Optional extension in tests) Implement the inverse: `unitIndexToCpIndex`, clamping **inside** a surrogate pair to the high surrogate’s owner.

---

### 5) `encodeCodePoint.ts` — encode a code point to a JS string

For `cp <= 0xFFFF`, return `String.fromCharCode(cp)`. For astral, compute the surrogate pair or just use `String.fromCodePoint(cp)` (and add a manual branch to show the math).

**Starter — `encodeCodePoint.ts`**

```ts
export function encodeCodePoint(cp: number): string {
  if (cp <= 0xFFFF) return String.fromCharCode(cp);
  const u = cp - 0x10000;
  const hi = 0xD800 + (u >> 10);
  const lo = 0xDC00 + (u & 0x3FF);
  return String.fromCharCode(hi, lo);
  // Equivalent: return String.fromCodePoint(cp);
}
```

---

## Quiz (checks)

1. `"😀".length` equals:
   A) 1
   B) **2** ✅
   C) 4
   D) Depends on locale

2. `for (const ch of "A😀B")` yields:
   A) `"A"`, `"\uD83D"`, `"\uDE00"`, `"B"`
   B) **`"A"`, `"😀"`, `"B"`** ✅
   C) Numbers of code points
   D) Grapheme clusters

3. A **high surrogate** lives in which range?
   A) 0xDC00–0xDFFF
   B) **0xD800–0xDBFF** ✅
   C) 0xD400–0xD7FF
   D) 0xE000–0xF8FF

4. To convert a **code point index** to a **unit index**, you should:
   A) Multiply by 2
   B) **Scan the string, adding 2 for astral and 1 for BMP** ✅
   C) Use `indexOf`
   D) Use `localeCompare`

5. `codePointAt(i)` on a **low surrogate** returns:
   A) The combined astral code point
   B) **The low surrogate’s unit value (BMP number)** ✅
   C) `undefined`
   D) Throws

---

## Takeaways

* JS strings are **UTF-16** sequences; `length` and `s[i]` operate on **units**, not characters.
* Astral characters (many emoji) use **surrogate pairs** → 2 units.
* Use `for…of`, `Array.from`, and `codePointAt`/`fromCodePoint` to work at the **code point** level.
* When you must translate between **code point** and **unit** indices, **scan** with awareness of surrogate sizes.
* Next up: user-visible **grapheme clusters** (what people think of as “characters”).

---

## What’s next

Continue to **Strings L2 — Grapheme Clusters & Emoji** to handle combined characters, skin tones, family sequences, flags, and safe grapheme slicing with `Intl.Segmenter`.
