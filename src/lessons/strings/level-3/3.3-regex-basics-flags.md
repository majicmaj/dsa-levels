---
id: strings-l3-regex-basics-flags
title: "Regex Basics & Flags"
topic: strings
level: 3
lesson: 3.3
prereqs:
  - strings-l3-replace-replaceall
  - strings-l3-split-join-composition
  - strings-l2-unicode-normalization-nfc-nfd
outcomes:
  - Write regexes with **literals** and the **RegExp constructor** safely (dynamic flags & escaping)
  - "Understand and choose flags: **g** (global), **i** (ignore case), **m** (multiline), **s** (dotAll), **u** (Unicode), **y** (sticky)"
  - Use core tokens **character classes** (`.`, `\d`, `\s`, `\w`), **anchors** (`^`, `$`, `\b`, `\B`)
  - Prefer **Unicode property escapes** (`\p{L}`, `\p{N}`, `\p{M}`) with **`u`** for robust matching
  - Control scanning with **`lastIndex`**, `exec`, `match`, and **`matchAll`**; parse streams with **sticky `y`**
tags: ["strings","regex","flags","unicode","property-escapes","sticky","dotall","anchors"]
est_minutes: 45
concepts_introduced:
  - strings.regex.flags
  - strings.regex.literals_vs_constructor
  - strings.regex.property_escapes
concepts_reused:
  - strings.regex.escape_input
  - strings.unicode.codepoints
  - strings.unicode.graphemes
crosslinks:
  - { to: strings-l3-regex-groups-capture-and-backrefs, why: "Captures, named groups, backrefs come next" }
  - { to: strings-l2-string-iteration-patterns, why: "Bridge code-unit indices from regex to grapheme-aware UI" }
  - { to: strings-l4-search-highlight-and-snippets, why: "Use flags + boundaries to build highlighters" }
checks:
  - type: quiz
    id: strings-l3-regex-basics-flags-quiz
  - type: unit
    entry: makeRegex.ts
    tests: makeRegex.test.ts
  - type: unit
    entry: wildcardToRegex.ts
    tests: wildcardToRegex.test.ts
  - type: unit
    entry: findAllMatches.ts
    tests: findAllMatches.test.ts
  - type: unit
    entry: scanWithSticky.ts
    tests: scanWithSticky.test.ts
  - type: unit
    entry: isUnicodeWord.ts
    tests: isUnicodeWord.test.ts
---

## Why this matters

Regex is the swiss army knife of text. The **flags** you choose change semantics: whether matches continue (`g`), cross lines (`s`), use Unicode rules (`u`), or require matches at an exact position (`y`). Mastering these prevents “why didn’t it match?” bugs and enables clean tokenizers and highlighters.

---

## Literals vs `RegExp` constructor

- **Literal:** `/pattern/flags` — great for static patterns.
- **Constructor:** `new RegExp(source, flags)` — for **dynamic** patterns (build from user input or variables).  
  - Remember to **escape** user input (`escapeRegex` from the previous lesson).
  - In the constructor, **backslashes need only once** (unlike string-literal double escaping in many languages).

```ts
const word = "hello+world";
const re1 = /hello\+world/g;                  // literal
const re2 = new RegExp(escapeRegex(word), "g"); // dynamic, safe
````

---

## The six flags (cheat sheet)

* **g** — *global*: find **all** matches, update `lastIndex`.
* **i** — *ignore case*: ASCII-ish case-insensitivity (not locale aware).
* **m** — *multiline*: `^`/`$` match **line** boundaries, not just start/end of string.
* **s** — *dotAll*: `.` matches **line terminators** too.
* **u** — *Unicode*: enables Unicode mode → `\u{...}`, **property escapes** `\p{…}`, and treats patterns in **code points**.

  * Example: `/^.$/u.test("😀")` → **true**, but `/^.$/.test("😀")` → false.
* **y** — *sticky*: match must start exactly at `lastIndex`; great for tokenizing streams incrementally.

> Most modern text regexes should include **`u`**. Add **`s`** when you expect dots to cross line breaks.

---

## Core tokens & anchors

* **`.`** — any char (except line breaks, unless `s`).
* **Classes:** `\d` digits, `\s` whitespace, `\w` word-constituents (**ASCII only**).

  * Prefer **Unicode property escapes** with `u`:

    * `\p{L}` letters, `\p{N}` numbers, `\p{M}` combining marks, `\p{Emoji_Presentation}` (implementation-dependent), `\p{Script=Greek}` or `\p{sc=Greek}`.
* **Anchors:** `^` start, `$` end (affected by `m`), `\b` word boundary (ASCII), `\B` non-boundary.

```ts
/\p{L}+/u.test("mañana"); // true (letters with accents)
^\d{4}-\d{2}-\d{2}$/m     // line-by-line YYYY-MM-DD
```

---

## Methods & scanning styles

* `re.test(s)` → boolean, updates `lastIndex` if `g`/`y`.
* `re.exec(s)` → single match object (with `g`/`y`, resumes at `lastIndex`).
* `s.match(re)` → array of matches (with `g`) or full match + groups (without).
* `s.matchAll(reWithG)` → **iterator** of matches (modern, clean).
* `s.replace/replaceAll`, `s.split` — already covered earlier.

**Sticky (`y`)** parsing:

```ts
const re = /\s*([A-Za-z]+|\d+|[.,])/y;
let i = 0, m: RegExpExecArray | null;
re.lastIndex = i;
while ((m = re.exec("cost: 12, apples"))){
  // m[1] is the token
  i = re.lastIndex;       // MUST advance
  re.lastIndex = i;       // keep scanning from here
}
```

If the pattern fails at `lastIndex`, `y` **won’t** skip ahead (unlike `g`)—that’s the point.

---

## Multiline & dotAll gotchas

```ts
/^hello$/m.test("hi\nhello\nbye"); // true  (line anchors)
/^hello$/.test("hi\nhello\nbye");  // false (no m)

const anyBlock = /<code>.*?<\/code>/gs; // dot crosses newlines with s
```

Without `s`, you may see `.` fail across lines; a common historical workaround is `[\s\S]`.

---

## Unicode best practices

* Always add **`u`** when you rely on `\p{…}` or want `.`/quantifiers to treat **emoji as single code points**.
* **`\w`**, `\b` are **ASCII-centric**. For word-ish matching in real languages, prefer `\p{L}`/`\p{N}` and `Intl.Segmenter` (“word” mode) for tokenization.
* Normalize (`NFC`) before building regex keys if inputs may mix decomposed and composed forms.

---

## Pitfalls

* Forgetting `g` and wondering why only the **first** match appears.
* Using `.` to span lines without `s`.
* Expecting `\w`/`\b` to handle accents or CJK—use `\p{…}` + `u` or `Intl.Segmenter`.
* With `g`/`y`, forgetting that **`lastIndex` matters**—especially in loops.
* Building dynamic regex without **escaping** input.

---

## Exercises

### 1) `makeRegex(src, flags?, defaults?)` — safe factory

Create a `RegExp` from a **string or RegExp**. Rules:

* If `src` is a `RegExp`, merge its flags with `flags` (union), unless `flags` explicitly overrides (e.g., pass `""` to drop).
* Ensure flags are **deduplicated** and keep **`u` by default** (include `defaults = "u"` unless the caller sets it to `""`).

**Starter — `makeRegex.ts`**

```ts
export function makeRegex(
  src: string | RegExp,
  flags?: string,
  defaults = "u"
): RegExp {
  const baseSrc = typeof src === "string" ? src : src.source;
  const srcFlags = typeof src === "string" ? "" : src.flags;
  // If caller provided flags, use them; else merge src.flags with defaults
  const raw = flags ?? Array.from(new Set((srcFlags + (defaults || "")).split(""))).join("");
  // Deduplicate and sort flags for stability
  const dedup = Array.from(new Set(raw.split(""))).join("");
  return new RegExp(baseSrc, dedup);
}
```

---

### 2) `wildcardToRegex(pattern, opts?)` — `*` / `?` to regex

Convert a simple wildcard (like file globs) to a **RegExp** that matches the whole string:

* `*` → `.*`, `?` → `.`
* Escape everything else.
* Options: `{ caseInsensitive?: boolean, dotAll?: boolean }`. Always include `u`.

**Starter — `wildcardToRegex.ts`**

```ts
export function wildcardToRegex(
  pattern: string,
  opts: { caseInsensitive?: boolean; dotAll?: boolean } = {}
): RegExp {
  const esc = (s: string) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const src = "^" + esc(pattern).replace(/\\\*/g, ".*").replace(/\\\?/g, ".") + "$";
  const flags = "u" + (opts.caseInsensitive ? "i" : "") + (opts.dotAll ? "s" : "");
  return new RegExp(src, flags);
}
```

---

### 3) `findAllMatches(s, re)` — robust matcher

Return an array of `{ match: string; index: number }` for all **non-overlapping** matches.
Requirements:

* Accept a `RegExp` with or without `g`; always run in **global** mode.
* Preserve the original regex’s **flags** + ensure **`u`** if present originally.
* Use `matchAll` if available; otherwise loop with `exec`.

**Starter — `findAllMatches.ts`**

```ts
export function findAllMatches(s: string, re: RegExp): Array<{ match: string; index: number }> {
  const flags = re.flags.includes("g") ? re.flags : re.flags + "g";
  const rex = new RegExp(re.source, flags);
  const out: Array<{ match: string; index: number }> = [];
  if ((s as any).matchAll) {
    for (const m of s.matchAll(rex) as any) out.push({ match: m[0], index: m.index });
    return out;
  }
  let m: RegExpExecArray | null;
  while ((m = rex.exec(s))) out.push({ match: m[0], index: m.index! });
  return out;
}
```

---

### 4) `scanWithSticky(s, tokenRe)` — token stream with `y`

Given a **sticky** regex (must include `y`), return all matched tokens (strings). If the regex fails at a position, **throw** (indicates unexpected character).

**Starter — `scanWithSticky.ts`**

```ts
export function scanWithSticky(s: string, tokenRe: RegExp): string[] {
  if (!tokenRe.flags.includes("y")) throw new Error("tokenRe must be sticky (y)");
  const out: string[] = [];
  let i = 0, m: RegExpExecArray | null;
  tokenRe.lastIndex = 0;
  while (i < s.length) {
    m = tokenRe.exec(s);
    if (!m) throw new Error(`Unexpected character at ${i}: ${JSON.stringify(s[i])}`);
    out.push(m[0]);
    i = tokenRe.lastIndex;
    tokenRe.lastIndex = i;
  }
  return out;
}

// Example pattern for tests:
// const tok = /\s+|[A-Za-z]+|\d+|[.,:;!?]/y;
```

---

### 5) `isUnicodeWord(s)` — word-ish test with `\p{…}`

Return `true` if `s` is 1+ Unicode letters/numbers/marks (no spaces/punct). Use `/^\p{L}[\p{L}\p{M}\p{N}]*$/u`.

**Starter — `isUnicodeWord.ts`**

```ts
export function isUnicodeWord(s: string): boolean {
  return /^\p{L}[\p{L}\p{M}\p{N}]*$/u.test(s);
}
```

---

## Quiz (checks)

1. Which flag makes `.` match newlines?
   A) **`s` (dotAll)** ✅
   B) `m`
   C) `g`
   D) `y`

2. `/^.$/u.test("😀")` returns:
   A) false
   B) **true** ✅
   C) Throws
   D) Only with `s`

3. Which flag forces a match **exactly** at `lastIndex`?
   A) `g`
   B) **`y`** ✅
   C) `m`
   D) `i`

4. `\b` word boundaries in JS are:
   A) Fully Unicode aware
   B) **ASCII-oriented** ✅
   C) Locale-aware
   D) Deprecated

5. To build a dynamic regex from user text safely you should:
   A) Use `new RegExp(text)`
   B) **Escape metacharacters and set desired flags** ✅
   C) Always use `s` and `m`
   D) Use `matchAll`

---

## Takeaways

* Pick flags deliberately: most Unicode-aware patterns want **`u`**, use **`s`** to cross lines, **`m`** for line-anchored checks, **`y`** for streaming tokenizers, **`g`** for iteration, **`i`** for simple case-insensitive matches.
* Prefer **property escapes** (`\p{…}` with `u`) to match real-world letters/numbers/marks.
* Know your scanning tools: `exec`/`matchAll` + `lastIndex` for controlled iteration; `y` avoids silent skips.
* For dynamic patterns, **escape inputs** and construct with `RegExp`.

---

## What’s next

Next: **Strings L3 — Regex Groups, Captures & Backreferences** — named groups, non-capturing groups, backrefs, lookarounds, and composing powerful transforms safely.
