---
id: strings-l3-case-folding-and-simple-normalization
title: "Case Folding & Simple Normalization"
topic: strings
level: 3
lesson: 3.7
prereqs:
  - strings-l2-unicode-normalization-nfc-nfd
  - strings-l3-split-join-composition
  - strings-l3-regex-basics-flags
outcomes:
  - Choose between **simple** case folding and **locale-aware** folding
  - Build stable **keys** for equality, dedupe, and search: normalize → (compat width?) → accent fold (optional) → case fold
  - Use **`Intl.Collator`** for human-friendly compare/sort with `sensitivity`, `numeric`, and `ignorePunctuation`
  - Implement **case-/accent-insensitive** includes/startsWith/endsWith
  - Avoid classic pitfalls: Turkish **İ/i**, German **ß**, Greek final **ς/σ**, width variants
tags: ["strings","case-folding","normalize","Intl.Collator","search","dedupe","accent-fold","NFC","NFKC"]
est_minutes: 45
concepts_introduced:
  - strings.casefold.simple
  - strings.intl.collator.basics
concepts_reused:
  - strings.normalize.nfc
  - strings.normalize.accent_folding
  - strings.unicode.iteration.generators
crosslinks:
  - { to: strings-l2-unicode-normalization-nfc-nfd, why: "Normalize first to make canonically equivalent strings identical" }
  - { to: strings-l5-accent-insensitive-search-pipelines, why: "Extend folding into full locale/diacritic-aware search" }
  - { to: arrays-l2-sorting-basics-and-comparator, why: "Use collator compare as a comparator for stable sorts" }
checks:
  - type: quiz
    id: case-folding-and-simple-normalization-quiz
  - type: unit
    entry: foldCase.ts
    tests: foldCase.test.ts
  - type: unit
    entry: foldKey.ts
    tests: foldKey.test.ts
  - type: unit
    entry: collatorCompare.ts
    tests: collatorCompare.test.ts
  - type: unit
    entry: includesFolded.ts
    tests: includesFolded.test.ts
  - type: unit
    entry: uniqueByFold.ts
    tests: uniqueByFold.test.ts
---

## Why this matters

Users expect “São” to match “sao”, “straße” to match “STRASSE”, and “İstanbul” to match with Turkish rules. Computers… don’t—unless you **normalize** and **fold** intentionally. With a tiny, well-documented pipeline you can get predictable equality, dedupe, search, and sorting behavior across locales.

---

## The pipeline (pick & document your policy)

A practical default for many apps:

1) **Normalize** to **NFC** (composition) → stable binary form.  
2) Optionally **compat-width** normalize (**NFKC**) when you want full-width/half-width & styled forms treated the same (careful: this changes semantics).  
3) Optional **accent folding** (NFD → strip `\p{M}` → NFC) for accent-insensitive search.  
4) **Case fold**:
   - **Simple**: `toLowerCase()` — fast, ASCII-ish.
   - **Locale-aware**: `toLocaleLowerCase(locale)` — handles Turkish **İ/i**, Greek sigma, etc.

Use the **same pipeline for both sides** (data & query).

---

## Case folding options

```ts
// Simple (locale-neutral-ish)
"sTRASSE".toLowerCase();         // "strasse" (ß quirk shows up when uppercased first)

// Locale-aware (preferred for user text)
"İSTANBUL".toLocaleLowerCase("tr"); // "i̇stanbul" (dot preserved)
"ΜΟΣΧΑ".toLocaleLowerCase("el");   // handles sigma correctly ("σ"/"ς")
````

> **Note:** JavaScript lacks a full Unicode **case folding** API; `toLocaleLowerCase`/`toLowerCase` are your tools. For storage keys, pick **one locale** (e.g., `"en"` or `"tr"`) and stick to it; for end-user display/search, use the user’s locale.

---

## Collation (human sorting & compare)

`Intl.Collator` gives locale-aware compare with options:

* `sensitivity: "base" | "accent" | "case" | "variant"` (lower is looser)
* `numeric: true` lets "2" < "10" numerically
* `ignorePunctuation: true` to elide punctuation in comparison

```ts
const cmp = new Intl.Collator(undefined, { sensitivity: "base", numeric: true }).compare;
["file2","file10","file9"].sort(cmp); // ["file2","file9","file10"]
```

Use collator for **sorting** and **equality** (compare === 0) when you need user expectations, not just binary equality.

---

## Utilities

### 1) Simple vs locale-aware case fold

```ts
export function foldCase(s: string, locale?: string | string[], useLocale = true): string {
  return useLocale ? s.toLocaleLowerCase(locale) : s.toLowerCase();
}
```

### 2) Stable key builder (policy: NFC → (optional NFKC) → accentFold? → case fold)

```ts
import { accentFold } from "./accentFold"; // from L2
type Form = "NFC" | "NFD" | "NFKC" | "NFKD";

export type FoldKeyOpts = {
  locale?: string | string[];
  useLocale?: boolean;     // default true
  accent?: boolean;        // default false
  widthCompat?: boolean;   // if true, normalize with NFKC before accent/case
  form?: Form;             // final normalize form, default "NFC"
};

export function foldKey(s: string, opts: FoldKeyOpts = {}): string {
  const {
    locale, useLocale = true, accent = false, widthCompat = false, form = "NFC",
  } = opts;
  let x = s.normalize(widthCompat ? "NFKC" : "NFC");
  if (accent) x = accentFold(x);          // NFD -> strip marks -> NFC
  x = foldCase(x, locale, useLocale);
  return x.normalize(form);
}
```

### 3) Collator comparator factory

```ts
export function collatorCompare(
  locale?: string | string[],
  options: Intl.CollatorOptions = { sensitivity: "base", numeric: true, ignorePunctuation: false }
): (a: string, b: string) => number {
  const collator = new Intl.Collator(locale, options);
  return (a, b) => collator.compare(a, b);
}
```

### 4) Case-/accent-insensitive includes (and friends)

```ts
export type FoldSearchOpts = Omit<FoldKeyOpts, "form">;

export function includesFolded(hay: string, needle: string, opts: FoldSearchOpts = {}): boolean {
  return foldKey(hay, { ...opts }).includes(foldKey(needle, { ...opts }));
}

export function startsWithFolded(hay: string, needle: string, opts: FoldSearchOpts = {}): boolean {
  const H = foldKey(hay, opts); const N = foldKey(needle, opts);
  return H.startsWith(N);
}

export function endsWithFolded(hay: string, needle: string, opts: FoldSearchOpts = {}): boolean {
  const H = foldKey(hay, opts); const N = foldKey(needle, opts);
  return H.endsWith(N);
}
```

### 5) Unique by folded key (dedupe)

```ts
export function uniqueByFold(items: string[], opts: FoldKeyOpts = {}): string[] {
  const seen = new Set<string>();
  const out: string[] = [];
  for (const s of items) {
    const k = foldKey(s, opts);
    if (!seen.has(k)) { seen.add(k); out.push(s); }
  }
  return out;
}
```

---

## Pitfalls & guardrails

* **Locale surprises**: Turkish **İ/i** and Greek **sigma (Σ/σ/ς)** behave differently under locale rules. Use `toLocaleLowerCase(locale)` when results must match user language.
* **`ß` vs `SS`**: `"straße".toUpperCase()` yields `"STRASSE"` in many runtimes; folding with **lower** case avoids expanding characters.
* **NFKC** changes semantics\*\*:\*\* it folds compatibility forms (e.g., full-width “Ａ” → “A”). Use only when desired (e.g., search keys), never for cryptographic IDs.
* **Order matters**: normalize first; mixing normalized + raw then folding may create different keys for the “same-looking” text.
* **Collator in tight loops**: create once, reuse the comparator.

---

## Exercises

### 1) `foldCase.ts` — basic case folding

Implement `foldCase(s, locale?, useLocale?)` exactly as above and test with Turkish and Greek samples.

**Starter — `foldCase.ts`**

```ts
export function foldCase(s: string, locale?: string | string[], useLocale = true): string {
  return useLocale ? s.toLocaleLowerCase(locale) : s.toLowerCase();
}
```

---

### 2) `foldKey.ts` — stable key pipeline

Build `foldKey(s, opts)` with options `{ locale?, useLocale?, accent?, widthCompat?, form? }`. Default `useLocale: true`, `form: "NFC"`.

**Starter — `foldKey.ts`**

```ts
import { foldCase } from "./foldCase";
import { accentFold } from "./accentFold";

export type FoldKeyOpts = {
  locale?: string | string[];
  useLocale?: boolean;
  accent?: boolean;
  widthCompat?: boolean;
  form?: "NFC"|"NFD"|"NFKC"|"NFKD";
};

export function foldKey(s: string, opts: FoldKeyOpts = {}): string {
  const { locale, useLocale = true, accent = false, widthCompat = false, form = "NFC" } = opts;
  let x = s.normalize(widthCompat ? "NFKC" : "NFC");
  if (accent) x = accentFold(x);
  x = foldCase(x, locale, useLocale);
  return x.normalize(form);
}
```

---

### 3) `collatorCompare.ts` — human comparator

Export `collatorCompare(locale?, options?)` returning `(a,b)=>number`. Default `{ sensitivity: "base", numeric: true }`.

**Starter — `collatorCompare.ts`**

```ts
export function collatorCompare(
  locale?: string | string[],
  options: Intl.CollatorOptions = { sensitivity: "base", numeric: true }
): (a: string, b: string) => number {
  const collator = new Intl.Collator(locale, options);
  return (a, b) => collator.compare(a, b);
}
```

---

### 4) `includesFolded.ts` — case-/accent-insensitive search

Implement `includesFolded`, `startsWithFolded`, `endsWithFolded` using `foldKey`.

**Starter — `includesFolded.ts`**

```ts
import { foldKey, FoldKeyOpts } from "./foldKey";

export type FoldSearchOpts = Omit<FoldKeyOpts, "form">;

export const includesFolded = (hay: string, needle: string, opts: FoldSearchOpts = {}) =>
  foldKey(hay, opts).includes(foldKey(needle, opts));

export const startsWithFolded = (hay: string, needle: string, opts: FoldSearchOpts = {}) => {
  const H = foldKey(hay, opts), N = foldKey(needle, opts);
  return H.startsWith(N);
};

export const endsWithFolded = (hay: string, needle: string, opts: FoldSearchOpts = {}) => {
  const H = foldKey(hay, opts), N = foldKey(needle, opts);
  return H.endsWith(N);
};
```

---

### 5) `uniqueByFold.ts` — dedupe by folded key

Keep the **first** occurrence; drop later ones that fold to the same key.

**Starter — `uniqueByFold.ts`**

```ts
import { foldKey, FoldKeyOpts } from "./foldKey";

export function uniqueByFold(items: string[], opts: FoldKeyOpts = {}): string[] {
  const seen = new Set<string>();
  const out: string[] = [];
  for (const s of items) {
    const k = foldKey(s, opts);
    if (!seen.has(k)) { seen.add(k); out.push(s); }
  }
  return out;
}
```

---

## Quiz (checks)

1. A good default pipeline for search keys is:
   A) `toLowerCase` → normalize NFD → accentFold
   B) **Normalize NFC → (optional NFKC) → accentFold → toLocaleLowerCase(locale)** ✅
   C) Normalize NFKD → uppercase → accentFold
   D) toUpperCase → toLowerCase

2. `toLocaleLowerCase("tr")` differs from `toLowerCase()` notably for:
   A) Greek sigma
   B) **Dotted capital I (İ)** ✅
   C) Cyrillic yo
   D) Hebrew alef

3. For human sorting with numbers (“2” < “10”), configure:
   A) `sensitivity: "variant"`
   B) **`numeric: true` on `Intl.Collator`** ✅
   C) `ignorePunctuation: true` only
   D) Use `Array.sort()` with no comparator

4. Using **NFKC** in key building will:
   A) Never change meaning
   B) **Fold compatibility forms (e.g., full-width → ASCII)** ✅
   C) Remove accents automatically
   D) Be slower than NFC and otherwise identical

5. To make `"São"` match `"sao"` you should:
   A) Only lowercase both
   B) Only use `Intl.Collator`
   C) **Remove combining marks (accent fold) and case-fold** ✅
   D) Use `substring`

---

## Takeaways

* Pick and **document** a folding policy. Normalize first; add NFKC only when you truly want width/compatibility folding.
* Use **accent folding** + **case folding** for accent-insensitive search; use **`Intl.Collator`** for user-friendly compare/sort.
* Locale matters (Turkish, Greek, German). Use **`toLocaleLowerCase(locale)`** for user-facing behavior; keep a consistent locale for stored keys.

---

## What’s next

Onward to **Strings L4 — Search, Highlight & Snippets** where we combine folded matching, regex ranges, and grapheme-safe slicing to build robust highlighters and previews.