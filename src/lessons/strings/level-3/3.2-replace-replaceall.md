---
id: strings-l3-replace-replaceall
title: "replace & replaceAll (Function Replacers, Escaping, Maps)"
topic: strings
level: 3
lesson: 3.2
prereqs:
  - strings-l1-basic-search-compare
  - strings-l3-split-join-composition
  - strings-l2-unicode-normalization-nfc-nfd
outcomes:
  - Choose between `replace` (first match) and `replaceAll` (all non-overlapping matches)
  - "Use **string** vs **function** replacers, and special tokens: `$&`, `$1`, `$<name>`, `$'`, `$```, `$$`"
  - Safely **escape user input** for regex with `escapeRegex`
  - Build **map-based replacement** (many needles → one pass) with alternation ordering
  - "Implement practical transforms: **redaction**, **censoring**, **surround/highlight**, **case-preserving** replacements"
  - Understand Unicode implications (`u` flag) and overlapping-match strategies
tags: ["strings","replace","replaceAll","regex","escape","redact","map-replace","unicode"]
est_minutes: 45
concepts_introduced:
  - strings.replace.function_replacer
  - strings.regex.escape_input
concepts_reused:
  - strings.normalize.nfc
  - strings.unicode.iteration.generators
crosslinks:
  - { to: strings-l3-regex-basics-flags, why: "Deeper dive on flags, character classes, groups" }
  - { to: strings-l4-search-highlight-and-snippets, why: "Highlight pipelines build on replacers & boundaries" }
  - { to: strings-l2-safe-length-and-slicing, why: "Snap ranges for UI-safe surrounds" }
checks:
  - type: quiz
    id: strings-l3-replace-replaceall-quiz
  - type: unit
    entry: escapeRegex.ts
    tests: escapeRegex.test.ts
  - type: unit
    entry: replaceAllFn.ts
    tests: replaceAllFn.test.ts
  - type: unit
    entry: replaceWithMap.ts
    tests: replaceWithMap.test.ts
  - type: unit
    entry: redact.ts
    tests: redact.test.ts
  - type: unit
    entry: surroundMatches.ts
    tests: surroundMatches.test.ts
---

## Why this matters

Text transforms often boil down to **find → replace**. Doing it safely means:
- picking the right primitive (`replace` vs `replaceAll` vs regex),
- **escaping user input**,
- handling **multiple needles** in one pass,
- and respecting **Unicode** + UI boundaries.

This lesson gives you robust patterns you’ll reuse everywhere.

---

## The two entry points

### `String.prototype.replace(pattern, replacement)`
- If `pattern` is a **string** → replaces **first** occurrence only.
- If `pattern` is a **regex**:
  - without `g` → first occurrence.
  - with `g` → **all** non-overlapping occurrences.

### `String.prototype.replaceAll(pattern, replacement)`
- Replaces **all** non-overlapping matches.
- `pattern` can be a **string** or a **regex with `g`**.
- Throws if you pass a regex **without** `g`.

> **Overlaps?** Neither `replace`+`/g` nor `replaceAll` match overlaps. For overlapping work, use a loop with a **lookahead** or the **sticky `y`** flag (covered later).

---

## Replacement forms

### 1) String replacement with tokens
Inside the replacement string, you can reference:
- `$&` — whole match
- `$1` … `$99` — numbered captures
- `$<name>` — **named capture** (with `/(?<name>...)/`)
- ``$` `` — text **before** match
- `$'` — text **after** match
- `$$` — a single `$`

```ts
"2024-08-11".replace(/(\d{4})-(\d{2})-(\d{2})/, "$2/$3/$1"); // "08/11/2024"
"foo".replace(/f(?<rest>oo)/, "[$<rest>]");                  // "[oo]"
````

### 2) Function replacer

Signature: `(match, ...captures, offset, input, groups) => string`

```ts
"price: $5 and $15".replace(/\$(\d+)/g, (m, num) => `$${String(Number(num) * 2)}`);
// "price: $10 and $30"
```

Use function replacers for **computed** outputs, **case-preserving** logic, and **redaction** that depends on match length.

---

## Escaping user input for regex

Never shove raw user strings into a regex. Escape **metacharacters**: `.*+?^${}()|[]\`.

```ts
export function escapeRegex(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
```

Example:

```ts
const user = "(admin)*";
const safe = new RegExp(escapeRegex(user), "g"); // literal match "(admin)*"
"users: (admin)*".replace(safe, "[REDACTED]");
```

---

## One-pass **map replacement** (many needles)

Build an alternation regex from keys, **sorted by length desc** to avoid partial shadowing (`"cat"` before `"c"`).

```ts
export function replaceWithMap(
  s: string,
  map: Record<string, string>,
  opts: { ignoreCase?: boolean; wholeWord?: boolean } = {}
): string {
  const keys = Object.keys(map).sort((a,b) => b.length - a.length).map(escapeRegex);
  if (keys.length === 0) return s;

  const wb = opts.wholeWord ? "\\b" : "";
  const src = `${wb}(?:${keys.join("|")})${wb}`;
  const flags = "g" + (opts.ignoreCase ? "i" : "");
  const re = new RegExp(src, flags);

  return s.replace(re, (m) =>
    opts.ignoreCase ? mapKeyIC(map, m) ?? m : map[m] ?? m
  );
}

function mapKeyIC(map: Record<string, string>, m: string): string | undefined {
  const lower = m.toLowerCase();
  for (const k of Object.keys(map)) if (k.toLowerCase() === lower) return map[k];
}
```

---

## Practical patterns

### Redaction (length-preserving)

```ts
export function redact(s: string, pattern: RegExp, ch = "█"): string {
  const re = addGlobal(pattern);
  return s.replace(re, (m) => ch.repeat(Array.from(m).length)); // code point length
}

function addGlobal(re: RegExp): RegExp {
  const flags = re.flags.includes("g") ? re.flags : re.flags + "g";
  return new RegExp(re.source, flags);
}
// redact("visa 4111-1111-1111-1111", /\d{4}(?:-\d{4}){3}/) -> "visa ████-████-████-████"
```

### Surround / highlight (string or regex)

```ts
export function surroundMatches(
  s: string,
  needle: string | RegExp,
  before = "[", after = "]"
): string {
  const re = typeof needle === "string"
    ? new RegExp(escapeRegex(needle), "g")
    : addGlobal(needle);
  return s.replace(re, (m) => before + m + after);
}
```

### Case-preserving replacement (title → Title)

```ts
export function replaceWordCaseAware(s: string, from: string, to: string): string {
  const re = new RegExp(`\\b${escapeRegex(from)}\\b`, "gi");
  return s.replace(re, (m) => {
    if (m === m.toUpperCase()) return to.toUpperCase();
    if (m[0] === m[0].toUpperCase()) return to[0].toUpperCase() + to.slice(1);
    return to.toLowerCase();
  });
}
```

---

## Unicode notes

* Use the **`u` flag** for Unicode-safe escapes, dot behavior, and named groups: `/\p{L}+/u`, `/(?<name>…)/u`.
* If replacement visibility matters (e.g., **mask length equals characters**), count by **code points** (`Array.from(m).length`) or **graphemes** via `Intl.Segmenter` (see L2).
* Normalize to **NFC** before building keys/regex if your data mixes forms.

---

## Pitfalls

* `replace("x","y")` changes **only the first** "x". Use `/x/g` or **`replaceAll("x","y")`**.
* **Overlapping** matches don’t occur with `g` or `replaceAll`. For overlaps, use a **lookahead** like `/(?=(aba))/g` and compute spans in a loop (covered when we do regex groups).
* Building alternation without length sort can transform `"caterpillar"` wrong if `"cat"` and `"c"` both map.
* Forgetting to escape user input leads to **regex injection**.
* Using regex with captures but forgetting to add **`g`** → only one match.

---

## Exercises

### 1) `escapeRegex(s)` — escape user input for regex

**Starter — `escapeRegex.ts`**

```ts
export function escapeRegex(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
```

---

### 2) `replaceAllFn(s, needle, fn, flags?)`

Replace **all** occurrences using a function replacer. `needle` may be a **string** or a **regex** (ensure it’s global). If `flags` is provided for a string needle, create `new RegExp(escapeRegex(needle), "g" + flags)`.

**Starter — `replaceAllFn.ts`**

```ts
import { escapeRegex } from "./escapeRegex";

export function replaceAllFn(
  s: string,
  needle: string | RegExp,
  fn: (match: string, index: number, input: string) => string,
  flags = ""
): string {
  const re =
    typeof needle === "string"
      ? new RegExp(escapeRegex(needle), "g" + flags)
      : new RegExp(needle.source, needle.flags.includes("g") ? needle.flags : needle.flags + "g");

  return s.replace(re, (m, _1, index, input) => fn(m, index, input));
}
```

---

### 3) `replaceWithMap(s, map, opts?)` — one-pass dictionary replace

Implement as above (`ignoreCase`, `wholeWord` options).

**Starter — `replaceWithMap.ts`**

```ts
import { escapeRegex } from "./escapeRegex";

export function replaceWithMap(
  s: string,
  map: Record<string, string>,
  opts: { ignoreCase?: boolean; wholeWord?: boolean } = {}
): string {
  const keys = Object.keys(map).sort((a,b)=>b.length-a.length).map(escapeRegex);
  if (keys.length === 0) return s;
  const wb = opts.wholeWord ? "\\b" : "";
  const src = `${wb}(?:${keys.join("|")})${wb}`;
  const flags = "g" + (opts.ignoreCase ? "i" : "");
  const re = new RegExp(src, flags);
  return s.replace(re, (m) => {
    if (!opts.ignoreCase) return map[m] ?? m;
    const lower = m.toLowerCase();
    for (const k of Object.keys(map)) if (k.toLowerCase() === lower) return map[k];
    return m;
  });
}
```

---

### 4) `redact(s, re, ch?)` — length-preserving redaction

Redact all matches with a repeating character (`"█"` default) sized by **code points**.

**Starter — `redact.ts`**

```ts
export function redact(s: string, pattern: RegExp, ch = "█"): string {
  const re = pattern.flags.includes("g") ? pattern : new RegExp(pattern.source, pattern.flags + "g");
  return s.replace(re, (m) => ch.repeat(Array.from(m).length));
}
```

---

### 5) `surroundMatches(s, needle, before?, after?)`

Surround each match (string or regex) with `before`/`after`.

**Starter — `surroundMatches.ts`**

```ts
import { escapeRegex } from "./escapeRegex";

export function surroundMatches(
  s: string, needle: string | RegExp, before = "[", after = "]"
): string {
  const re = typeof needle === "string"
    ? new RegExp(escapeRegex(needle), "g")
    : (needle.flags.includes("g") ? needle : new RegExp(needle.source, needle.flags + "g"));
  return s.replace(re, (m) => before + m + after);
}
```

---

## Quiz (checks)

1. `replace("aa", "a", "b")` changes:
   A) **First** `"a"` only ✅
   B) All `"a"`
   C) Nothing without `/g`
   D) Throws

2. In a **replacement string**, `$&` refers to:
   A) The first capture group
   B) **The entire match** ✅
   C) The text after the match
   D) A literal `$&`

3. Passing a regex **without `g`** to `replaceAll` will:
   A) Work like `replace`
   B) Be ignored
   C) **Throw** ✅
   D) Add `g` automatically

4. To safely put user input into a regex you should:
   A) Lowercase it
   B) Trim whitespace
   C) **Escape metacharacters (`escapeRegex`)** ✅
   D) Use `new RegExp(input)` directly

5. To avoid partial matches when replacing many keywords in one pass, you should:
   A) Build alternation in any order
   B) Use multiple sequential replaces
   C) **Sort keys by length (desc) and use one alternation** ✅
   D) Add word boundaries always

---

## Takeaways

* `replace` vs `replaceAll`: first vs **all** non-overlapping matches; use **function replacers** for logic.
* Always **escape user input** put into regex.
* For many needles, use a **length-sorted alternation** and a single pass.
* Redaction and surround/highlight are straightforward with function replacers—mind Unicode length.
* Overlaps require special handling (lookaheads/sticky) you’ll learn alongside deeper **regex basics & groups** next.

---

## What’s next

Onward to **Strings L3 — Regex Basics & Flags**: literals vs `RegExp`, `gimsyu`, character classes, anchors, and when to reach for sticky `y` or dotAll `s`.