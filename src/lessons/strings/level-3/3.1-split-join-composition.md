---
id: strings-l3-split-join-composition
title: "split/join Composition"
topic: strings
level: 3
lesson: 3.1
prereqs:
  - strings-l1-slice-substring-substr
  - strings-l1-basic-search-compare
  - strings-l2-unicode-normalization-nfc-nfd
  - strings-l2-string-iteration-patterns
outcomes:
  - Use `split` with **string** or **regex** separators, limits, and handle edge cases (empty matches)
  - Keep or drop delimiters using **capturing groups** in regex splits
  - "Build tokenization pipelines: **multi-delimiter split**, **trim/filter**, **normalize → split → join**"
  - Compose transforms via `.split('')…join('')` and **code point / grapheme–aware** alternatives
  - Join arrays back efficiently and readably; implement common helpers (lines, words, CSV-ish, list joiners)
tags: ["strings","split","join","regex","composition","tokenize","normalize","pipelines"]
est_minutes: 45
concepts_introduced:
  - strings.split.join.composition
concepts_reused:
  - strings.normalize.nfc
  - strings.unicode.iteration.generators
crosslinks:
  - { to: arrays-l2-sorting-basics-and-comparator, why: "Char-sorting requires comparator basics" }
  - { to: strings-l3-regex-basics-flags, why: "Deeper regex knowledge for advanced tokenizers" }
  - { to: strings-l2-safe-length-and-slicing, why: "Split('') is unit-based; prefer code point/grapheme when needed" }
checks:
  - type: quiz
    id: strings-l3-split-join-composition-quiz
  - type: unit
    entry: splitMulti.ts
    tests: splitMulti.test.ts
  - type: unit
    entry: splitKeepSep.ts
    tests: splitKeepSep.test.ts
  - type: unit
    entry: lines.ts
    tests: lines.test.ts
  - type: unit
    entry: words.ts
    tests: words.test.ts
  - type: unit
    entry: sortChars.ts
    tests: sortChars.test.ts
  - type: unit
    entry: joinAndWrap.ts
    tests: joinAndWrap.test.ts
---

## Why this matters

Most practical text transforms are pipelines of **split → map/filter → join**. With a few patterns you can build tokenizers, formatters, and classic tricks like `.split('').sort().join('')`—while staying Unicode-safe when it matters.

> Reminder: `split('')` and `split(/./g)` operate on **code units** unless you prepare safer inputs (code points or graphemes). We’ll show alternatives.

---

## `split` fundamentals

### String vs regex separators

```ts
"one,two;three".split(",");          // ["one", "two;three"]
"one,two;three".split(/[,;]/);       // ["one", "two", "three"]
"foo--bar---baz".split(/-+/);        // ["foo", "bar", "baz"]
````

### Limit argument

```ts
"a,b,c,d".split(",", 2);             // ["a", "b"]
```

### Keeping the separators (capturing groups)

If your **regex has captures**, `split` **keeps** them in the output:

```ts
"1+2-3".split(/([+-])/);             // ["1", "+", "2", "-", "3"]
```

Great for re-joining with spacing, rendering, or parsing.

### Edge cases

* Empty pattern: `"abc".split("")` → `["a","b","c"]` (**code units**, not graphemes).
* No match: returns `[original]`.
* Leading/trailing delimiters: `"".split(",")` → `[""]`, `",a,".split(",")` → `["", "a", ""]`.

---

## Tokenize → clean → join (mini patterns)

### Multi-delimiter + trim + drop empties

```ts
const toks = "  a, b;  c |  d  "
  .split(/[,\|;]/)          // split by comma, pipe, semicolon
  .map(s => s.trim())       // clean
  .filter(Boolean);         // remove empty
// ["a","b","c","d"]
```

### Normalize → split → join (stable keys)

```ts
const key = "São  Tomé".normalize("NFC")
  .split(/\s+/).filter(Boolean).join(" ").toLowerCase();
// "são tomé"
```

### Keep operators, then format

```ts
const parts = "1+2-3".split(/([+\-])/); // ["1","+","2","-","3"]
const pretty = parts.map(p => /[+\-]/.test(p) ? ` ${p} ` : p).join("");
// "1 + 2 - 3"
```

---

## The classic: sort characters

**Unit-based (naïve):**

```ts
const sorted = "bca".split("").sort().join(""); // "abc"
// ⚠️ splits surrogate pairs; not for emoji
```

**Code point–safe:**

```ts
const cps = Array.from("A😀B");    // ["A","😀","B"]
const sortedCP = cps.sort().join(""); // default code point order
```

> For locale-aware ordering and case handling, cross-link to **Arrays L2** (comparator) and **Strings L5 (Intl.Collator)**.

**Grapheme-aware:** Use `Intl.Segmenter` to chunk first (see L2):

```ts
const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
const gs = Array.from(seg.segment("A👍🏽B") as any, (p: any) => p.segment);
gs.sort().join(""); // still code point order per grapheme
```

---

## Joining back (and friends)

```ts
["a","b","c"].join(", ");    // "a, b, c"
["line1","line2"].join("\n") // lines
["id","name"].join("\t")     // TSV
```

### “and” lists (simple English)

```ts
export function joinAnd(items: string[], conj = "and"): string {
  const xs = items.filter(Boolean);
  if (xs.length === 0) return "";
  if (xs.length === 1) return xs[0]!;
  if (xs.length === 2) return xs.join(` ${conj} `);
  return xs.slice(0, -1).join(", ") + `, ${conj} ` + xs.at(-1);
}
```

---

## Unicode safety notes

* `split('')` → **code units**. Prefer `Array.from(s)` for **code points** or `Intl.Segmenter` for **graphemes** before sorting or rejoining.
* When tokenizing human text (words), consider `Intl.Segmenter` with **`granularity: "word"`**; fall back to a regex if unavailable.

---

## Exercises

### 1) `splitMulti.ts` — split on multiple delimiters

Split on any of `[",", ";", "|"]`, **trim** tokens, and drop empties. Accept an optional `limit` on returned tokens.

**Starter — `splitMulti.ts`**

```ts
export function splitMulti(input: string, limit?: number): string[] {
  const parts = input.split(/[;,|]/).map(s => s.trim()).filter(Boolean);
  return typeof limit === "number" ? parts.slice(0, Math.max(0, limit)) : parts;
}
```

---

### 2) `splitKeepSep.ts` — keep the separators

Split on `+` or `-` and **keep** operators as tokens. Return `["1","+","2","-","3"]` for `"1+2-3"`.

**Starter — `splitKeepSep.ts`**

```ts
export function splitKeepSep(expr: string): string[] {
  return expr.split(/([+\-])/).filter(s => s.length > 0);
}
```

---

### 3) `lines.ts` — robust line splitting

Return an array of lines handling `\r\n`, `\n`, and lone `\r`. Preserve **empty** last line if the string ends with a newline.

**Starter — `lines.ts`**

```ts
export function lines(s: string): string[] {
  // Split on \r\n or \n or \r, preserving trailing empty after final newline
  if (s === "") return [""];
  const arr = s.split(/\r\n?|\n/);
  // If s ends with a newline, split drops the trailing empty; restore it:
  if (/\r\n?|\n$/.test(s)) arr.push("");
  return arr;
}
```

---

### 4) `words.ts` — word tokenizer with Intl fallback

Use `Intl.Segmenter(..., { granularity: "word" })` when available; otherwise fall back to `/[A-Za-z0-9_]+/g`. Return lowercase words by default.

**Starter — `words.ts`**

```ts
export function words(s: string, lower = true): string[] {
  if (typeof (Intl as any)?.Segmenter === "function") {
    const seg = new Intl.Segmenter(undefined, { granularity: "word" });
    const out: string[] = [];
    for (const p of seg.segment(s) as any) {
      if ((p as any).isWordLike) out.push(p.segment);
    }
    return lower ? out.map(w => w.toLowerCase()) : out;
  }
  const out = s.match(/[A-Za-z0-9_]+/g) ?? [];
  return lower ? out.map(w => w.toLowerCase()) : out;
}
```

---

### 5) `sortChars.ts` — safe char sorting

Implement `sortChars(s, mode)` where `mode` is `"unit" | "codepoint" | "grapheme"`. Return the **sorted** string.

**Starter — `sortChars.ts`**

```ts
export type SortMode = "unit" | "codepoint" | "grapheme";

export function sortChars(s: string, mode: SortMode = "unit"): string {
  if (mode === "unit") return s.split("").sort().join("");
  if (mode === "codepoint") return Array.from(s).sort().join("");
  // grapheme
  if (typeof (Intl as any)?.Segmenter === "function") {
    const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
    const gs = Array.from(seg.segment(s) as any, (p: any) => p.segment);
    return gs.sort().join("");
  }
  return Array.from(s).sort().join("");
}
```

---

### 6) `joinAndWrap.ts` — join items with per-item wrappers

Implement `joinAndWrap(items, { before, after, sep })` that wraps each item (`before+item+after`) and joins with `sep`.

**Starter — `joinAndWrap.ts`**

```ts
export function joinAndWrap(
  items: (string | null | undefined)[],
  opts: { before?: string; after?: string; sep?: string } = {}
): string {
  const { before = "", after = "", sep = ", " } = opts;
  return items.filter(Boolean).map(x => `${before}${x}${after}`).join(sep);
}
```

---

## Quiz (checks)

1. In `split`, **capturing groups** in the regex cause:
   A) An error
   B) **The captured delimiters to be included in the result** ✅
   C) Empty strings to be removed
   D) The split to be slower but identical

2. `"a,,b,".split(",")` yields:
   A) `["a","b"]`
   B) **`["a","","b",""]`** ✅
   C) `["a","", "b"]`
   D) Throws

3. `split('')` is unsafe for emoji because it operates on:
   A) Bytes
   B) **UTF-16 code units** ✅
   C) Grapheme clusters
   D) Words

4. Which sequence is best for stable, accent-insensitive keys?
   A) `split → join → normalize`
   B) **`normalize("NFC") → split(/\s+/) → filter → join(" ") → toLowerCase()`** ✅
   C) `toUpperCase → split → join`
   D) `normalize("NFD") only`

5. To sort visible characters safely you should first:
   A) Use `split('')`
   B) **Chunk by code point or grapheme (Segmenter)** ✅
   C) Replace emoji with `*`
   D) Use `localeCompare` without chunking

---

## Takeaways

* `split` + `join` is your workhorse; regex captures let you **keep delimiters** for formatting.
* Build pipelines: **normalize → split → map/filter → join** for clean, comparable text.
* For **emoji-safe** operations, chunk into **code points** or **graphemes** before sorting/joining.
* Reuse helpers for lines, words, and list joining to keep code tidy.

---

## What’s next

Up next: **Strings L3 — replace & replaceAll** (function replacers, escaping user input, and composing safe transformations without full regex wizardry).