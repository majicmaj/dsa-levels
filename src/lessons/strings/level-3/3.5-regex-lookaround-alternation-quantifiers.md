---
id: strings-l3-regex-lookaround-alternation-quantifiers
title: "Lookaround, Alternation & Quantifier Control"
topic: strings
level: 3
lesson: 3.5
prereqs:
  - strings-l3-regex-basics-flags
  - strings-l3-regex-groups-capture-and-backrefs
outcomes:
  - Use **lookaheads** `(?=...)`, `(?!...)` and **lookbehinds** `(?<=...)`, `(?<!...)` to assert context **without consuming** text
  - Control matching with **greedy vs lazy** quantifiers (`*`, `+`, `?`, `{m,n}` and `*?`, `+?`, `??`, `{m,n}?`)
  - Avoid runaway backtracking using **tempered dot** and **unambiguous alternation**
  - Apply **alternation precedence** and grouping to keep patterns linear-time where possible
  - "Implement practical utilities: **between (non-consuming)**, **findUnescaped**, **numbersNotInWords**, **untilNot**, and **overlapMatches**"
tags: ["strings","regex","lookahead","lookbehind","quantifiers","greedy","lazy","alternation","backtracking"]
est_minutes: 50
concepts_introduced:
  - strings.regex.lookaround
  - strings.regex.quantifiers.greedy_vs_lazy
  - strings.regex.alternation.precedence
concepts_reused:
  - strings.regex.flags
  - strings.regex.groups.captures
  - strings.regex.escape_input
crosslinks:
  - { to: strings-l4-search-highlight-and-snippets, why: "Use lookaround to compute highlight boundaries without consuming text" }
  - { to: strings-l2-string-iteration-patterns, why: "Bridge regex code-unit indices to grapheme-aligned ranges for UI" }
checks:
  - type: quiz
    id: strings-l3-regex-lookaround-quantifiers-quiz
  - type: unit
    entry: betweenAssert.ts
    tests: betweenAssert.test.ts
  - type: unit
    entry: findUnescaped.ts
    tests: findUnescaped.test.ts
  - type: unit
    entry: numbersNotInWords.ts
    tests: numbersNotInWords.test.ts
  - type: unit
    entry: untilNot.ts
    tests: untilNot.test.ts
  - type: unit
    entry: overlapMatches.ts
    tests: overlapMatches.test.ts
---

## Why this matters

Lookarounds let you **check context** (before/after) *without consuming* characters. Pair that with **greedy/lazy** control and sane alternation, and you can write patterns that are both **precise** and **fast**—great for parsing-ish tasks, tokenizing, or highlighting.

> JS supports **lookahead** and **lookbehind** (ES2018+). It does **not** have possessive quantifiers or atomic groups; we mitigate backtracking with pattern design.

---

## Lookaround 101

- **Positive lookahead** `X(?=Y)` — match `X` only if `Y` **follows**.
- **Negative lookahead** `X(?!Y)` — match `X` only if `Y` **doesn’t** follow.
- **Positive lookbehind** `(?<=Y)X` — match `X` only if `Y` **precedes**.
- **Negative lookbehind** `(?<!Y)X` — match `X` only if `Y` **doesn’t** precede.

Examples:

```ts
// A word followed by a colon, but don't consume the colon:
const key = /\b\w+(?=:)/g;

// A number not followed by a letter (avoid parts of words like "A1B"):
const bareNum = /\d+(?!\p{L})/gu;

// CSV-ish: commas that are NOT escaped with backslash
const unescapedComma = /(?<!\\),/g;

// Insert brackets *around* text between < and > without consuming them:
const insideAngles = /(?<=<)[^>]+(?=>)/g;
````

> Because lookarounds are **zero-width**, the match’s start/end indices don’t move across the asserted context. Perfect for **surrounding** or **splitting** without losing delimiters.

---

## Greedy vs lazy (quantifier control)

* **Greedy**: `*`, `+`, `?`, `{m,n}` — match as **much** as possible, then backtrack.
* **Lazy**: `*?`, `+?`, `??`, `{m,n}?` — match as **little** as possible, then expand.

```ts
// Greedy eats too much:
"<a> x <b>".match(/<.*>/);     // ["<a> x <b>"]
// Lazy stops at first '>':
"<a> x <b>".match(/<.*?>/g);   // ["<a>", "<b>"]
```

### Tempered dot (stop before token)

Use a **negative lookahead** inside a repeated group:

```ts
// "Any char except '>'" in a way that avoids catastrophic backtracking
const angleContent = /<(?:[^>]|(?<=\\)>|(?<!\\)>)*?>/g; // allows escaped '>'
// Simpler for "until '>' (not escaped)":
const simpleAngle = /<(?:(?<!\\)>|.)*?>/g; // see "untilNot" util below
```

> “Tempering” the `.` with a guard (`(?!END)`) or using a literal character class (`[^>]`) reduces backtracking risks.

---

## Alternation & precedence

* Alternation `A|B|C` is tried **left to right**. Put **longer/more specific** options first.
* Group alternations explicitly: `/pre(?:foo|bar|baz)/`, not `/prefoo|bar|baz/`.
* Avoid overlapping alternations with catastrophic branches like `/(a+)+$/` on long `a…b` strings.

Design tips:

* Prefer **explicit character classes** (`[^"]*`) over `.*` with backtracking.
* Anchor when you can (`^`, `$`, `\b` or lookarounds) to constrain the search space.

---

## Practical patterns

### 1) Between markers **without consuming** them

```ts
// Grab content between start and end tokens (single-line; see "untilNot" for dotAll)
export function betweenAssert(s: string, start: string, end: string): string[] {
  const esc = (x: string) => x.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const re = new RegExp(`(?<=${esc(start)})(.*?)(?=${esc(end)})`, "g");
  return Array.from(s.matchAll(re), m => m[1]);
}
```

### 2) Find **unescaped** separators

```ts
// indices of commas not preceded by backslash
export function findUnescaped(s: string, ch = ","): number[] {
  const esc = (x: string) => x.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const re = new RegExp(`(?<!\\\\)${esc(ch)}`, "g");
  return Array.from(s.matchAll(re), m => m.index!);
}
```

### 3) Whole numbers **not part of words**

```ts
// Use Unicode property escapes with u-flag
export const numbersNotInWords = (s: string) =>
  Array.from(s.matchAll(/(?<!\p{L})\d+(?!\p{L})/gu), m => m[0]);
```

### 4) “Until not” (tempered, dotAll-friendly)

```ts
// Match from `open` up to the next `close` that is NOT preceded by `escape`.
// Returns matches including delimiters.
export function untilNot(s: string, open: string, close: string, escape = "\\"): string[] {
  const esc = (x: string) => x.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const o = esc(open), c = esc(close), e = esc(escape);
  const re = new RegExp(`${o}(?:(?<=${e})${c}|[\\s\\S])*?${c}`, "g"); // dotAll via [\s\S]
  return s.match(re) ?? [];
}
```

### 5) Overlapping matches (via lookahead)

Built-ins return **non-overlapping** matches. Use a **lookahead** to slide by one:

```ts
export function overlapMatches(hay: string, needle: string): number[] {
  const esc = needle.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const re = new RegExp(`(?=(${esc}))`, "g");
  return Array.from(hay.matchAll(re), m => m.index!);
}
// overlapMatches("aaaa", "aa") -> [0,1,2]
```

---

## Pitfalls

* Lookbehinds require **fixed-length** patterns in JS. `(?<=\d{2})` is fine; `(?<=\d+)` is not.
* Don’t rely on `\w`, `\b` for international text; prefer `\p{L}`, `\p{N}` with the **`u`** flag or `Intl.Segmenter`.
* A lazy quantifier can still backtrack a lot if the stopper is vague. Use **tempered dot** (`(?:(?!END).)*?`) or explicit classes.
* Overlapping alternation pieces—put **longer first** and escape literal strings.

---

## Exercises

### 1) `betweenAssert(s, start, end)` — non-consuming capture

Return **only** the inner text between `start` and `end` (no delimiters). Use **lookbehind + lookahead**; non-greedy.

**Starter — `betweenAssert.ts`**

```ts
export function betweenAssert(s: string, start: string, end: string): string[] {
  const esc = (x: string) => x.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const re = new RegExp(`(?<=${esc(start)})(.*?)(?=${esc(end)})`, "g");
  return Array.from(s.matchAll(re), m => m[1]);
}
```

---

### 2) `findUnescaped(s, ch?)` — positions of unescaped separators

Return the **unit indices** of `ch` not preceded by `\`.

**Starter — `findUnescaped.ts`**

```ts
export function findUnescaped(s: string, ch = ","): number[] {
  const esc = (x: string) => x.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const re = new RegExp(`(?<!\\\\)${esc(ch)}`, "g");
  return Array.from(s.matchAll(re), m => m.index!);
}
```

---

### 3) `numbersNotInWords(s)` — standalone numbers

Return all digit runs not immediately adjacent to letters (Unicode-aware).

**Starter — `numbersNotInWords.ts`**

```ts
export function numbersNotInWords(s: string): string[] {
  return Array.from(s.matchAll(/(?<!\p{L})\d+(?!\p{L})/gu), m => m[0]);
}
```

---

### 4) `untilNot(s, open, close, escape?)` — tempered capture with escapes

Return substrings from `open` to the next **unescaped** `close` (include delimiters). Handle newlines.

**Starter — `untilNot.ts`**

```ts
export function untilNot(s: string, open: string, close: string, escape = "\\"): string[] {
  const esc = (x: string) => x.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const o = esc(open), c = esc(close), e = esc(escape);
  const re = new RegExp(`${o}(?:(?<=${e})${c}|[\\s\\S])*?${c}`, "g");
  return s.match(re) ?? [];
}
```

---

### 5) `overlapMatches(hay, needle)` — overlapping search

Return start indices of **overlapping** matches using a **lookahead**.

**Starter — `overlapMatches.ts`**

```ts
export function overlapMatches(hay: string, needle: string): number[] {
  const esc = needle.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const re = new RegExp(`(?=(${esc}))`, "g");
  return Array.from(hay.matchAll(re), m => m.index!);
}
```

---

## Quiz (checks)

1. Lookarounds are:
   A) Consuming groups
   B) **Zero-width assertions** ✅
   C) Backreferences
   D) Atomic subpatterns

2. Which matches a number **not followed** by a letter?
   A) `\d+\b`
   B) **`\d+(?!\p{L})` (with `u`)** ✅
   C) `(?<=\p{L})\d+`
   D) `\d+?`

3. Which is **lazy**?
   A) `.*`
   B) `.+`
   C) **`.*?`** ✅
   D) `{3}`

4. Why prefer a **tempered dot** like `(?:(?!END).)*?` over `.*?END`?
   A) It’s shorter
   B) **It prevents excessive backtracking and stops exactly before END** ✅
   C) It matches across lines automatically
   D) It uses atomic groups

5. Alternation tries branches:
   A) Randomly
   B) By complexity
   C) **Left to right; put longer/specific first** ✅
   D) Shortest first

---

## Takeaways

* Lookarounds give you **context checks** without consuming—perfect for “between”, “not escaped”, and boundary-sensitive matches.
* Use **lazy quantifiers** with a **clear stopper** (tempered dot or explicit class) to avoid runaway backtracking.
* Order alternations **longest-first** and group them for clarity/performance.
* JS lacks atomic groups/possessive quantifiers—design patterns to keep regexes predictable and fast.

---

## What’s next

Next up: **Strings L3 — Tokenize & Parse Lite** — combine regex groups, lookarounds, and iteration to build small, robust tokenizers (CSV-lite, key/value lists, quoted strings) without full parsers.