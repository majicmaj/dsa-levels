---
id: strings-l3-regex-groups-capture-and-backrefs
title: "Strings L3 — Regex Groups, Captures & Backreferences"
topic: strings
level: 3
lesson: 3.4
prereqs:
  - strings-l3-regex-basics-flags
  - strings-l3-replace-replaceall
  - strings-l3-split-join-composition
outcomes:
  - Use **capturing groups** vs **non-capturing groups** and **named groups** `(?<name>…)`
  - Reference groups in the **pattern** (`\1`, `\k<name>`) and in **replacements** (`$1`, `$<name>`, `$&`, `$'`, ``$` ``)
  - Extract structured data with `match`, `exec`, and **`matchAll`** + group objects
  - Enforce constraints with **backreferences** (duplicate words, balanced quotes)
  - "Build practical utilities: `extractQuoted`, `parseKeyValue`, `dedupeRepeatedWords`, and **map-by-group** helpers"
tags: ["strings","regex","groups","captures","named-groups","backreferences","non-capturing"]
est_minutes: 50
concepts_introduced:
  - strings.regex.groups.captures
  - strings.regex.backreferences
concepts_reused:
  - strings.regex.flags
  - strings.regex.escape_input
  - strings.unicode.codepoints
crosslinks:
  - { to: strings-l4-search-highlight-and-snippets, why: "Groups drive highlight ranges and snippets" }
  - { to: strings-l3-regex-basics-flags, why: "Flags `g|s|u` change capture/backref behavior" }
  - { to: strings-l2-string-iteration-patterns, why: "Bridge code-unit indices to grapheme-aligned UI" }
checks:
  - type: quiz
    id: strings-l3-regex-groups-capture-and-backrefs-quiz
  - type: unit
    entry: extractQuoted.ts
    tests: extractQuoted.test.ts
  - type: unit
    entry: parseKeyValue.ts
    tests: parseKeyValue.test.ts
  - type: unit
    entry: dedupeRepeatedWords.ts
    tests: dedupeRepeatedWords.test.ts
  - type: unit
    entry: groupMap.ts
    tests: groupMap.test.ts
  - type: unit
    entry: surroundGroup.ts
    tests: surroundGroup.test.ts
---

## Why this matters

Groups are where regex becomes **structured**. With them you can:
- **name** the pieces you care about,
- **reorder** them in replacements,
- and **constrain** matches (e.g., same quote opens and closes).

This unlocks robust transforms like date reformatting, parsers for `key=value` lists, and safe highlighters.

---

## Capturing vs non-capturing vs named

```ts
/(Mr|Ms)\.?\s+([A-Z][a-z]+)/            // 1: honorific, 2: last name
/(?:Mr|Ms)\.?\s+([A-Z][a-z]+)/          // non-capturing for the alternation
/^(?<y>\d{4})-(?<m>\d{2})-(?<d>\d{2})$/ // named groups: y, m, d
````

* **Capturing** `( … )` creates an index (`$1`, `$2`, …).
* **Non-capturing** `(?: … )` groups for precedence/quantifiers without capturing.
* **Named** `(?<name> … )` adds `groups.name` *and* lets you use `$<name>` in replacements or `\k<name>` in the pattern.

---

## Backreferences (pattern side)

* `\1`, `\2`, … refer to **prior** captures by index.
* `\k<name>` refers to a **named** group.

Examples:

```ts
// Same opening/closing quote:
const q = /(["'])(.*?)\1/gs;

// Duplicate word (Unicode-ish letters):
const dup = /\b(\p{L}+)\s+\1\b/giu;

// Date with matching separators: 2025-08-11 or 2025/08/11
const d = /(?<y>\d{4})(?<sep>[-\/])(?<m>\d{2})\k<sep>(?<d>\d{2})/;
```

> Backreferences are **zero-width checks**: they don’t consume new text; they demand the same text appears again.

---

## Using groups in replacements

String replacement tokens:

* `$1`…`$99` — numbered captures
* `$<name>` — named capture
* `$&` — whole match, ``$` `` — text before, `$'` — text after, `$$` — literal `$`

```ts
"2024-08-11".replace(
  /(?<y>\d{4})-(?<m>\d{2})-(?<d>\d{2})/,
  "$<m>/$<d>/$<y>"
); // "08/11/2024"
```

Function replacers receive `(match, ...captures, offset, input, groups)`:

```ts
"“hello” 'world'".replace(/(["'])(.*?)\1/gs, (m, _q, inner, i, _s, g) =>
  `[${inner}]` // or g is {<unnamed>?:...,} when using named groups
);
```

---

## Extracting with `exec` / `matchAll`

```ts
const re = /(?<key>[A-Za-z_]\w*)\s*=\s*(?<val>"[^"]*"|'[^']*'|[^,;]+)/gs;
const input = `name="Amina"; id=42, title='Engineer'`;
for (const m of input.matchAll(re)) {
  const { key, val } = m.groups as Record<string,string>;
  // key -> "name", val -> "\"Amina\"" (quotes included by pattern on purpose)
}
```

> Tip: prefer `matchAll` for a clean iterator over matches (requires `g`).

---

## Practical patterns

* **Case-preserving replace** with a group for the first letter:

  ```ts
  text.replace(/\b(?<w>[A-Za-z])(?<rest>[A-Za-z]*)\b/g,
    (_m, _1, _2, _i, _s, g) => g.w.toUpperCase() + g.rest.toLowerCase());
  ```
* **Surround only a sub-group**: capture pre/target/post and rebuild in a function replacer.
* **Balanced quotes**: `(["'])(.*?)\1` (with `s` to cross lines).

---

## Pitfalls

* **Index renumbering**: inserting a new capturing group changes `$1`, `$2`, …; prefer **named** groups for stability.
* Forgetting `g` → only the **first** match is processed in `replace`/`matchAll`.
* Using `.` without `s` when you need to cross lines.
* Assuming `\w`/`\b` are Unicode aware—use property escapes `\p{L}` + `u`.

---

## Exercises

### 1) `extractQuoted(s)` — get all quoted substrings and their quote type

Return an array of `{ quote: '"' | "'", value: string, index: number }` where `value` excludes the quotes, and `index` is the **start unit index** of the opening quote.

**Starter — `extractQuoted.ts`**

```ts
export type Quoted = { quote: '"' | "'"; value: string; index: number };

export function extractQuoted(s: string): Quoted[] {
  const re = /(["'])(.*?)\1/gs; // same quote opens/closes, dotAll
  const out: Quoted[] = [];
  for (const m of s.matchAll(re)) {
    const quote = m[1] as '"' | "'";
    out.push({ quote, value: m[2], index: m.index! });
  }
  return out;
}
```

---

### 2) `parseKeyValue(s)` — parse `key=value` pairs (`,` or `;` separators)

* Keys: `[A-Za-z_]\w*`
* Values: quoted (double/single, no escapes) **or** unquoted until next `,`/`;`
* Return `Record<string, string>` with **unquoted** values trimmed.

**Starter — `parseKeyValue.ts`**

```ts
export function parseKeyValue(s: string): Record<string,string> {
  const re = /(?<key>[A-Za-z_]\w*)\s*=\s*(?<val>"[^"]*"|'[^']*'|[^,;]+)\s*(?:[,;]|$)/gs;
  const out: Record<string,string> = {};
  for (const m of s.matchAll(re)) {
    const { key, val } = m.groups as Record<string,string>;
    const unq = (val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))
      ? val.slice(1, -1)
      : val.trim();
    out[key] = unq;
  }
  return out;
}
```

---

### 3) `dedupeRepeatedWords(s)` — collapse `word word` → `word`

Use a **backreference** to remove immediately duplicated words, case-insensitive, Unicode letters.

**Starter — `dedupeRepeatedWords.ts`**

```ts
export function dedupeRepeatedWords(s: string): string {
  // \b(\p{L}+)\s+\1\b  → keep first occurrence
  return s.replace(/\b(\p{L}+)\s+\1\b/giu, "$1");
}
```

---

### 4) `groupMap(re, s)` — first match → `{ [name]: value }`

Given a regex **with named groups**, return the groups object for the **first** match or `{}` if none. Keep the function generic and safe.

**Starter — `groupMap.ts`**

```ts
export function groupMap(re: RegExp, s: string): Record<string,string> {
  const m = re.exec(s);
  const g = (m && (m as any).groups) ? (m as any).groups as Record<string,string> : {};
  return { ...g };
}
```

---

### 5) `surroundGroup(s, re, name, before?, after?)` — wrap a specific group only

Wrap **just** the named group occurrences with `before/after`, leaving the rest of each match as-is. Assumes `re` has `g` and the named group.

**Starter — `surroundGroup.ts`**

```ts
export function surroundGroup(
  s: string,
  re: RegExp,
  name: string,
  before = "[",
  after = "]"
): string {
  if (!re.flags.includes("g")) re = new RegExp(re.source, re.flags + "g");
  return s.replace(re, (...args) => {
    const match = args[0] as string;
    const groups = args.at(-1) as Record<string,string> | undefined;
    const sub = groups?.[name];
    return sub ? match.replace(sub, before + sub + after) : match;
  });
}
```

> This simple approach assumes the subgroup text appears **once** within the match. For multiple occurrences or overlapping groups, capture **prefix/target/suffix** explicitly and reconstruct.

---

## Quiz (checks)

1. What does `(?: … )` do?
   A) Captures a group named `?`
   B) **Groups without capturing** ✅
   C) Creates a non-greedy capture
   D) Enables backreferences

2. Which replacement inserts the **named** group `user`?
   A) `$1`
   B) `$user`
   C) **`$<user>`** ✅
   D) `\k<user>`

3. Pattern to match **paired quotes** around any text (single or double):
   A) `("|')(.*)\1`
   B) **`(["'])(.*?)\1`** (with `s` if multi-line) ✅
   C) `('.+|".+)`
   D) `(["]).*\1`

4. What does `\k<sep>` refer to?
   A) The whole match
   B) The previous token
   C) **The **named** group `sep`** ✅
   D) The second capture group

5. Why prefer **named** groups over numeric ones?
   A) They’re faster
   B) **They don’t break when you add/reorder other groups** ✅
   C) They use fewer bytes
   D) They’re required for `matchAll`

---

## Takeaways

* Use **named groups** for stable, self-documenting patterns; reserve non-capturing groups for precedence only.
* **Backreferences** enforce relationships inside the match (duplicate words, same quotes).
* In replacements, you can reorder with `$1`/`$<name>` or compute via **function replacers**.
* Prefer `matchAll` for multi-match extraction; it pairs naturally with named groups.

---

## What’s next

Next up: **Strings L3 — Regex Groups: Lookaround, Alternation & Quantifier Control** — lookaheads/lookbehinds, atomic groups, lazy vs greedy, and building robust tokenizers without catastrophic backtracking.